{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mad-Pascal Mad-Pascal jest 32-bitowym kompilatorem Turbo Pascala dla Atari XE/XL . W za\u0142o\u017ceniu jest kompatybilny z Free Pascal Compilator (FPC) (prze\u0142\u0105cznik -MDelphi powinien by\u0107 aktywny), co oznacza mo\u017cliwo\u015b\u0107 otrzymania kodu uruchomieniowego dla XE/XL , PC i ka\u017cdej innej platformy dla kt\u00f3rej istnieje FPC . Mad-Pascal nie jest portem FPC , zosta\u0142 napisany na podstawie kompilator\u00f3w SUB-Pascal (2009), XD-Pascal (2010), kt\u00f3rych autorem jest Vasiliy Tereshkov . \u0179r\u00f3d\u0142a dost\u0119pne na GitHub wraz z release dla systemu Windows. Historia 1.7.0 modyfikator [STRIPED] dla tablic o maksymalnym zakresie 0..255 nowy target, neo6502 (-t neo) GRAPH.INC: Circle (szybsza wersja) poprawki lib/aplib.pas poprawki lib/zx0.pas poprawiona optymalizacja CASE dodana dyrektywa {$UNITPATH filename} jako odpowiednik {$LIBRARYPATH filename} dodana mo\u017cliwo\u015b\u0107 podania \u015bcie\u017cki dla modu\u0142u deklarowanego przez USES, np: uses crt, vector in '..\\3d\\vector.pas'; dodana obs\u0142uga modu\u0142\u00f3w LIBRARY dodany modyfikator EXTERNAL dla zmiennych, procedur, funkcji dodana mo\u017cliwo\u015b\u0107 ustawienia adresu kompilacji z poziomu programu, np.: program name : address; library name : address; 1.6.9 poprawiona alokacja pami\u0119ci dla tablic [0..0], wymuszany jest wst\u0119pnie 'ABSOLUTE $0000', oszcz\u0119dzamy 1 bajt pami\u0119ci dodana mo\u017cliwo\u015b\u0107 deklaracji tablic bez podania ich rozmiaru, np.: var tab: array of byte = [1,3,4,3,1]; var tb: array of char = 'abcdefghij'; nowa dyrektywa kompilatora {$bin2csv filename} pozwala inicjowa\u0107 tablice np.: var tb: array of byte = [ {$bin2csv filename} ]; nowa dyrektywa kompilatora {$optimization loopunroll} , {$optimization noloopunroll} , dokonuje rozp\u0119tlenia p\u0119tli FOR przy sta\u0142ych parametrach nowy modu\u0142 BLOWFISH pozwalaj\u0105cy szyfrowa\u0107, deszyfrowa\u0107 ci\u0105gi znakowe wg podanego klucza nowy przyk\u0142ad a8\\AES-Rijndeal 1.6.7-1.6.8 rezygnacja z rozszerzania typu dla wyra\u017ce\u0144 z SHR nowy typ zasobu SAPR, SAPRPLAY dla RMTPLAY jako drugi parametr mo\u017cna poda\u0107 adres dla zmiennych na stronie zerowej SizeOfResource(variable, name) unit SAPLZSS unit SHANTI unit SHA1 unit xSFX unit SYSTEM: NtoBE, RorByte, RorWord, RorDWord, RolByte, RolWord, RolDWord, SarShortint, SarSmallint, SarLongint mo\u017cliwo\u015b\u0107 zaincjowania tablicy typu CHAR przez STRING (je\u015bli string jest kr\u00f3tszy zostan\u0105 wstawione spacje), np.: tab: array [0..15] of char = '0123456789ABCDEF'; naprawione przekazywanie warto\u015bci funkcji przez tablice dodana obsluga przerwania VBLKI (natychmiastowe) przez SetIntVec, GetIntVec (https://mads.atari8.info/doc/pl/przerwania/) przepisany kod kompilatora na moddzielne modu\u0142y przepisany kod obs\u0142ugi tablic ze wska\u017anikami do rekord\u00f3w tab: array [0..x] of record^ dodana optymalizacja 'Common head/tail Sequence coalescing' 1.6.6 poprawiona implementacja EXIT dodano mo\u017cliwo\u015b\u0107 generowania kodu dla RAW (-target) dodano obs\u0142ug\u0119 modyfikatora INLINE dla procedur i funkcji dodano mo\u017cliwo\u015b\u0107 zadeklarowania zmiennej na stronie zerowej poprzez u\u017cycie modyfikatora REGISTER dodana obs\u0142uga typu TEXTFILE (TEXT) unit INIFILES unit ZX2 unit SYSUTILS: CompareMem, TryStrToInt unit SYSTEM: CompareByte, Pos, Delete poprawiono przekazywanie parametr\u00f3w do obiekt\u00f3w (OBJECT) bez udzia\u0142u stosu programu :STACKORIGIN (w wi\u0119kszo\u015bci przypadk\u00f3w) dodano mo\u017cliwo\u015b\u0107 oznaczenia zmiennej jako ulotnej [volatile] [volatile] vcount: byte absolute $d40b; dla OBJECT dodano metody CONSTRUCTOR, DESTRUCTOR dodano obs\u0142ug\u0119 makr {$define label (parametry) := wyra\u017cenie} dodana konstrukcja 'FOR element IN array' dla tablic nie przekraczaj\u0105cych 256 bajt\u00f3w wi\u0119cej wolnej pami\u0119ci na stronie zerowej, wska\u017aniki FXPTR, PSPTR s\u0105 teraz alokowane w zale\u017cno\u015bci od tego czy s\u0105 u\u017cywane dodana obs\u0142uga typu FLOAT16 dodana obs\u0142uga typu proceduralnego 1.6.5 przepisana obs\u0142uga CASE OF przepisany kod optymalizacji dla tablic nie przekraczaj\u0105cych 256 bajt\u00f3w optymalizacja dla warunk\u00f3w '>', '<=' dodana alokacja pami\u0119ci dla tablic typu STRING (do tej pory odk\u0142adany by\u0142 tylko wska\u017anik, dzia\u0142a\u0142o to jak 'tablica ^string') dodana nowa platforma, Commodore C4 Plus unit GRAPHICS: procedura Font(charset: pointer); unit STRINGUTILS unit MISC, RMT, CMC, MPT: DetectAntic unit SYSTEM zmieniony w celu uwzgl\u0119dnienia platform ATARI, C64, C4Plus unit ZX0 unit HCM2 dodano obs\u0142uga $resource (RCDATA, RCASM) dla platform C64, C4Plus, zasoby s\u0105 sortowane wed\u0142ug rosn\u0105cych adres\u00f3w rozszerzony zas\u00f3b RCDATA o mo\u017cliwo\u015b\u0107 okre\u015blenia ofsetu dla \u0142adowanego pliku dodano obs\u0142ug\u0119 sk\u0142adni zgodnej z Pascalem dla bloku ASM, nie s\u0105 wymagane nawiasy { } dodana nowa dyrektywa {$codealign proc = warto\u015b\u0107}, {$codealign loop = warto\u015b\u0107} pozwalaj\u0105ca na wyr\u00f3wnanie wygenerowanego kodu 1.6.4 procedury mno\u017cenie u8x8, u16x16 zast\u0105pione kodem z CC65 dodanie kodu resetujacego POKEY-a na pocz\u0105tku uruchomienia programu optymalizacje wyra\u017ce\u0144 warunkowych IF () and () and ... ; IF () or () or ... optymalizacja CMP_SHORTINT, CMP_SMALLINT GRAPH, FASTGRAPH: SetActiveBuffer, SetDisplayBuffer, NewDisplayBuffer, SwitchDisplayBuffer, przyk\u0142ad demoeffects\\lines2.pas, line3.pas, line4.pas GRAPH: procedure Ellipse(X, Y, StAngle, EndAngle, xRadius,yRadius: Word); MATH: Hypot SYSTEM: Length(string_array[element]) SYSTEM: GetMem, FreeMem SYSTEM: IntToStr(CARDINAL), Str(CARDINAL, STRING) SYSUTILS: ByteToStr(BYTE): STRING SYSUTILS: poprawione FindFirst, StrToFloat SYSTEM: poprawione Val(string, real, code) ; Val(string, single, code) nowy unit CIO: Opn, Cls, Get, Put, BGet, BPut, XIO nowy unit SIODISK, wydzielony z SYSTEM nowy unit S2, zintegrowany z instalatorem handlera VBXE S2: (S_VBXE.SYS) nowy unit DEFLATE, realizuj\u0105cy dekompresj\u0119 DEFLATE (procedure unDEF), przyk\u0142ad compression\\undef.pas nowy unit LZ4, realizuj\u0105cy dekompresj\u0119 LZ4 z pami\u0119ci lub dysku (procedure unLZ4), przyk\u0142ad compression\\unlz4.pas, unlz4_stream.pas nowy unit APLIB, realizuj\u0105cy dekompresj\u0119 apLib z pami\u0119ci RAM lub dysku (procedure unApl), przyk\u0142ad compression\\unapl.pas, unapl_stream.pas nowy unit CRC: function crc32(crc: cardinal; buf: Pbyte; len: word) nowy modyfikator procedur/funkcji PASCAL, powoduj\u0105cy przydzielenie/zwolnienie nowego bloku pami\u0119ci dla zmiennych przy ka\u017cdym wywo\u0142aniu procedury/funkcji, przyk\u0142ad 'math\\evaluate.pas' dodana mo\u017cliwo\u015b\u0107 wy\u0142\u0105czenia pami\u0119ci ROM z zachowaniem dzia\u0142ania systemu, {$DEFINE ROMOFF} kr\u00f3tsze nazwy prze\u0142acznikow -zpage (-z), -stack (-s), -data (-d), -code (-c), -define (-d), -ipath (-i) dodana mo\u017cliwo\u015b\u0107 generowania kodu dla C64 (-t c64) 1.6.3 poprawki, optymalizacje SYSUTILS: Trim SYSTEM: PByte, PByteArray, PWord GRAPH, FASTGRAPH: TFrameBuffer, DisplayBuffer, FrameBuffer, SwitchBuffer, Scanline BLIBS: unit GR10PP LIB: unit GR4PP 1.6.0 - 1.6.2 nowy unit EFAST dla przyspieszenia wyprowadzania znak\u00f3w na urz\u0105dzenie E: SYSTEM: function Copy(var S: String; Index: Byte; Count: Byte): String; SYSTEM: Palette, HPalette dodana obs\u0142uga tablic jednowymiarowych typu ^RECORD (wskaznik do rekordu) optymalizacja blok\u00f3w warunkowych, generowany jest mo\u017cliwie najkr\u00f3tszy, najszybszy kod wynikowy dodany typ PChar, [link]https://www.freepascal.org/docs-html/rtl/system/pchar.html dodana mo\u017cliwo\u015b\u0107 zwracania warto\u015bci funkcji przez typ wyliczeniowy dodany nowy prze\u0142\u0105cznik -define:symbol dodany nowy prze\u0142\u0105cznik -ipath:includepath 1.5.9 - 1.6.0 SYSTEM: TDateTime GRAPH, FASTGRAPH: Arc, PieSlice, TLastArcCoords, LastArcCoords SYSUTILS: Now, Date, DateToStr, DecodeDate, DecodeDateTime, DecodeTime, EncodeDate, EncodeDateTime, EncodeTime, IsLeapYear, BoolToStr, StrToBool STRUTILS: AddChar, AddCharR, PadLeft, PadRight dodana obs\u0142uga {$INCLUDE %DATE%}, {$INCLUDE %TIME%}, [link]https://www.freepascal.org/docs-html/prog/progsu41.html prze\u0142\u0105czniki -CODE:, -DATA:, -STACK:, -ZPAGE: domy\u015blnie wymagaj\u0105 podania warto\u015bci HEX bez znaku pocz\u0105tkowego '$' 1.5.8 GRAPHICS: Font, FontInitialize, FillRect, TextOut, TextWidth, MoveTo, LineTo SYSTEM: FileMode (RESET), [fmOpenRead, fmOpenWrite, fmOpenAppend, fmOpenReadWrite] dodana obs\u0142uga dyrektyw {$info user_defined}, {$warning user_defined}, {$error user_defined}, {$include filename}, {$resource filename} akceptuje zapis PROGRAM (par1, par2 ...) poprawione FillFlood, dodane FillFloodH (wype\u0142nianie poziomymi liniami) kompilator generuje kr\u00f3tszy kod gdy procedura/funkcja nie ma parametr\u00f3w dost\u0119p do definicji .DEFINE z poziomu ASM, MAIN.@DEFINES.nazwa procedury/funkcje INTERRUPT niezale\u017cnie czy zostan\u0105 u\u017cyte kompilator zawsze wygeneruje dla nich kod poprawiona optymalizacja blok\u00f3w REPEAT UNTIL dodana informacja o czasie kompilacji dodana obs\u0142uga inicjalizacji tablic dwuwymiarowych sta\u0142ych i zmiennych 1.5.6 - 1.5.7 SYSUTILS: Click SYSTEM: Sqrt(Integer): Single MATH: Sign dodana mo\u017cliwo\u015b\u0107 u\u017cycia nazwy funkcji dla zwracanej warto\u015bci, dotychczas tylko przez RESULT dodana obs\u0142uga tablic typu STRING dodana obs\u0142uga dyrektywy {$LIBRARYPATH path1;path2;...} nowa biblioteka BLIBS nowa dokumentacja dla LIB, BLIBS wygenerowana przez PASDOC 1.5.3 - 1.5.5 CRT: TextMode SYSUTILS: ExtractFilePath SYSTEM: EoLn dodana obs\u0142uga linii polece\u0144 z poziomu DOS II/D dla ParamCount, ParamStr OBJECT, mo\u017cna zdefiniowa\u0107 je bez zmiennych, tylko same metody OBJECT, mo\u017cna wywo\u0142a\u0107 metod\u0119 z poziomu metody dodana automatyczna konwersja wyra\u017ce\u0144 typu INTEGER na REAL 1.5.2 nowy typ FLOAT jako odpowiednik typu SINGLE SYSTEM unti: FileSize (SDX) SYSTEM unit: EXP:Single, LN:Single, LN:Real, EXP:Real (wysoka precyzja oblicze\u0144) SYSUTILS unit: AnsiUpperCase, ExtractFileExt TYPES unit: Bounds, CenterPoint, EqualRect, InflateRect, IntersectRect, IsRectEmpty, NormalizeRect, OffsetRect, Point, PointsEqual, PtInRect, PtInEllipse, Rect, RectWidth, RectHeight, Size, UnionRect IMAGE unit: LoadMIC, LoadPIC, LoadBMP, LoadPCX, LoadGIF VIMAGE unit: LoadVBMP, LoadVPCX, LoadVGIF GRAPH, FASTGRAPH unit: SetClipRect, ClipLine, FillRect(TRect), Rectangle(TRect) 1.5.1 dodane nowe prze\u0142\u0105czniki -CODE:$address, -DATA:$address -STACK:$address, -ZPAGE:$address SYSTEM unit: RandomF (Result as Single), VAL (Integer, Single) GRAPH, FASTGRAPH unit: Bar, Bar3D, GetX, GetY, MoveRel, FloodFill MATH unit: RandomRange, RandomRangeF, RandG (gaussian distributed random number) CRT unit: SOUND (dzia\u0142a identycznie jak SOUND w Atari BASIC) VBXE unit: TVBXEMemoryStream dodany komunikat ostrze\u017cenia 'Comparison might be always true/false due to range of constant and expression' zasoby RCASM, CMCPLAY, MPTPLAY mo\u017cna teraz \u0142adowa\u0107 pod ROM dodana mo\u017cliwo\u015b\u0107 oznaczenia kodowania ci\u0105gu znakowego jako internal ANTIC-a poprzez znak tyldy ~ , np.: txt0: string = 'Atari'~; // ci\u0105g w kodach ANTIC-a txt1: string = 'Spectrum'*~; // ci\u0105g w inwersie w kodach ANTIC-a 1.5.0 poprawiona i uzupe\u0142niona inicjalizacja tablic typu POINTER poprawiona i uzupe\u0142niona inicjalizacja zmiennych typu wyliczeniowego wprowadzony typ LONGWORD, DWORD, UINT32 jako odpowiednik CARDINAL wprowadzony typ LONGINT jako odpowiednik INTEGER zreorganizowane typy rzeczywiste, typ ShortReal (fixed point Q8.8), Real (fixed point Q24.8), Single (32bit IEEE-754) unit SYSTEM (const SINGLE): NaN, Infinity, NegInfinity unit SYSTEM (type SINGLE): SIN, COS, ABS, SQRT, ISQRT, ROUND, TRUNC unit MATH (type SINGLE): LOG2, LOG10, LOGN, IsNaN dla WRITE/WRITELN akceptowane i ingorowane jest formatowanie wyniku, np.: writeln(f:8:8) 1.4.8 / 1.4.9 zmniejszenie wska\u017anika stosu programowego w przypadku wywo\u0142ania funkcji bez odebrania jej warto\u015bci lepsza ocena mo\u017cliwo\u015bci ustalenia adresu sta\u0142ej/zmiennej, dodany komunikat \"Can't take the address of constant expressions\" 1.4.7 optymalizacja dla imulBYTE, imulWORD, imulCARD, mulSHORTINT, mulSMALLINT, mulINTEGER dodana obs\u0142uga wska\u017anika rekordu, np.: type TPoint = record x,y: smallint end; var a,b: ^TPoint; begin a^.y := b^.x; a^ := b^; end. dodana obs\u0142uga sekcji INITIALIZATION w modu\u0142ach UNIT dodany nowy typ EXTMEM dla pliku resource $R, pozwalajacy \u0142adowa\u0107 dane do pami\u0119ci dodatkowej dodany nowy typ OBJECT, czyli RECORD z dodatkowymi metodami type TMemoryStream = Object Position: cardinal; Size: cardinal; procedure Create; procedure ReadBuffer(var Buffer; Count: word); procedure WriteBuffer(var Buffer; Count: word); end; poprawione biblioteki CMC, MPT, RMT 1.4.6 dodana obs\u0142uga dyrektyw warunkowych $IFDEF, $IFNDEF, $ELSE, $ENDIF, $DEFINE, $UNDEF przez DMSC {$define test} const {$ifdef test} a=1; {$else} a=2; {$endif} dodana mo\u017cliwo\u015b\u0107 przekazania warto\u015bci funkcji przez EXIT(expression) dodana podstawowa implementacja dla typu wyliczeniowego (w pliku wynikowym nie s\u0105 zapisywane nazwy etykiet) dodana obs\u0142uga tablic dwuwymiarowych 1.4.4/1.4.5 poprawione por\u00f3wnanie typ\u00f3w tego samego rozmiaru ale o przeciwnych znakach dodana mo\u017cliwo\u015b\u0107 u\u017cycia klauzuli USES w blokach modu\u0142\u00f3w UNIT dodany wym\u00f3g deklaracji funkcji/procedur w sekcji INTERFACE modu\u0142\u00f3w UNIT poprawione zauwa\u017cone b\u0142\u0119dy optymalizatora 1.4.3 dodana mo\u017cliwo\u015b\u0107 zwr\u00f3cenia warto\u015bci funkcji przez RECORD, np: var p: TPoint; p:=Point(x,y); {$f page} FAST_MUL, procedury szybkiego mno\u017cenia dla BYTE, SHORTINT, WORD, SMALLINT, SINGLE SYSTEM: ReadConfig, ReadSector, WriteSector SYSTEM: Point, Rect, Bounds, PointsEqual link DOS: CurrentMinuteOfDay, CurrentSec100OfDay, CurrentSecondOfDay, MinuteOfDay, MinutesToTime, SecondOfDay, SecondsToTime link MATH: Power, ArcTan2, InRange, EnsureRange, CycleToRad, DegNormalize, DegToGrad, DegToRad, DivMod, GradToDeg, GradToRad, RadToCycle, RadToDeg, RadToGrad link nowy typ LABEL dodana obs\u0142uga GOTO label 1.4.1 / 1.4.2 optymalizacja kodu wynikowego 6502 generowanego dla p\u0119tli FOR poprawiony odczyt plik\u00f3w include i resource MISC: DetectCPUSpeed dodatkowy typ danych rzeczywistych SINGLE <-128..127> 1.4.0 w parametrach formalnych procedur i funkcji dodana mo\u017cliwo\u015b\u0107 podania typu UNTYPED (tylko przez VAR), np. procedure move(var x,y; count: word); begin end; move(tab[100], tab[200], 50); SYSTEM: poprawki dla FILLCHAR, FILLBYTE, MOVE fillchar(pointer($bc40+40*8), 100, ord('a')); fillchar(scr[40*8], 100, ord('a')); // teraz takie wywo\u0142anie te\u017c jest mo\u017cliwe funkcja INTTOREAL usuni\u0119ta, zast\u0105piona przez wbudowan\u0105 konwersj\u0119 typu REAL, np. var f: real; i: word; f:=real(i); FASTGRAPH: SetClipRect, ClipLine (Cohen-Sutherland algorithm) poprawki dla {$i filename}, poprawne liczenie linii kompilowanego programu 1.3.8 SYSTEM: RANDOM(RANGE: BYTE): BYTE; RANDOM(RANGE: INTEGER): SMALLINT; CRT: WHEREX, WHEREY SYSUTILS: BEEP dodatkowy znak * po apostrofie ' oznacza inwers znak\u00f3w, np.: writeln('inwers'*'bez inwersu'); 1.3.7 dodana mo\u017cliwo\u015b\u0107 \u0142adowania bloku resource {$R} pod adres tablicy 1.3.6 dodane rozkazy GetIntVec, SetIntVec w zast\u0119pstwie rozkazu Intr umo\u017cliwione zwracanie warto\u015bci RESULT dla funkcji poprzez tablice poprawki dla MOVE (downwards, upwards) optymalizacja ASM dla procedur/funkcji POKE, DPOKE, PEEK, DPEEK, FILLCHAR, MOVE, INTTOREAL SYSTEM: ParamCount, ParamStr (SDX, BWDOS) 1.3.5 dodana mo\u017cliwo\u015b\u0107 odczytu adresu sta\u0142ej, np.: const tb: array [0..0] of byte = ( lo(word(@tb)) ); - dodany odczyt wektor\u00f3w DLI, VBL przez rozkaz INTR intr(rVBL, label); intr(rDLI, label); 1.3.4 dodana dodatkowa informacja o zajmowanej pami\u0119ci przez kolejne kompilowane modu\u0142y dodany nowy modu\u0142 VBXE (tryb OVERLAY, BLITTER) dodana obs\u0142uga b\u0142\u0119d\u00f3w dla operacji I/O {I+} {I-} IOCHECK ON/OFF dwie dodatkowe poprawki Greblusa dla $I, $R z my\u015bl\u0105 o dzia\u0142aniu w \u015brodowisku Linuxa 1.3.3 Greblus doda\u0142 poprawki umo\u017cliwiaj\u0105ce dzia\u0142anie kompilatora z Linux-em dodana mo\u017cliwo\u015b\u0107 zaincjowania wska\u017anika tmp: byte; p: pointer = @tmp; a: ^byte = @tmp; dodana mo\u017cliwo\u015b\u0107 przypisania rekordu type a = record x,y: byte end; var k,w: a; k:=w; GRAPH: SetVideoBank, SetColorMapDimensions, SetColorMapEntry VBXE: GetXDL, SetXDL, RunBlit, ClrVideoBank 1.3.2 DOS: GetTime, SetTime MATH: Ceil SYSUTILS: GetTickCount FindFirst ... obs\u0142uga Attributes wbudowanie funkcji w kompilator: INT, FRAC, TRUNC, ROUND, ODD 1.3.1 dodana obs\u0142uga rekord\u00f3w RECORD {$i filename} {$r filename}, Resource Type: RCDATA, DOSFILE, RELOC, RMT, MPT, CMC dodany prze\u0142\u0105cznik -o Optimize code mo\u017cliwo\u015b\u0107 wymuszenia typu dla CONST const a: word = 5; // WORD b = 5; // BYTE dodana obs\u0142uga modyfikator\u00f3w INTERRUPT, FORWARD, REGISTER dla procedur i funkcji dodana obs\u0142uga mapy kolor\u00f3w (40x30x8x8) VBXE (modu\u0142 GRAPH, CRT), SetColorMap, SetColorCell, SetVideoBank SYSUTILS: TSearchRec, FindFirst, FindNext, FindClose GRAPH, FASTGRAPH: FillRect, FillEllipse SYSTEM: ODD, INT, LOW, HIGH, SIZEOF, INTR (INTERRUPT_NUMBER), BinStr, OctStr, HexStr, Pause, Sound, NoSound, Concat RMT: RMTINIT, RMTPLAY, RMTSTOP MPT: MPTINIT, MPTPLAY, MPTSTOP CMC: CMCINIT, CMCPLAY, CMCSTOP","title":"Mad-Pascal"},{"location":"#mad-pascal","text":"Mad-Pascal jest 32-bitowym kompilatorem Turbo Pascala dla Atari XE/XL . W za\u0142o\u017ceniu jest kompatybilny z Free Pascal Compilator (FPC) (prze\u0142\u0105cznik -MDelphi powinien by\u0107 aktywny), co oznacza mo\u017cliwo\u015b\u0107 otrzymania kodu uruchomieniowego dla XE/XL , PC i ka\u017cdej innej platformy dla kt\u00f3rej istnieje FPC . Mad-Pascal nie jest portem FPC , zosta\u0142 napisany na podstawie kompilator\u00f3w SUB-Pascal (2009), XD-Pascal (2010), kt\u00f3rych autorem jest Vasiliy Tereshkov . \u0179r\u00f3d\u0142a dost\u0119pne na GitHub wraz z release dla systemu Windows.","title":"Mad-Pascal"},{"location":"#historia","text":"","title":"Historia"},{"location":"#170","text":"modyfikator [STRIPED] dla tablic o maksymalnym zakresie 0..255 nowy target, neo6502 (-t neo) GRAPH.INC: Circle (szybsza wersja) poprawki lib/aplib.pas poprawki lib/zx0.pas poprawiona optymalizacja CASE dodana dyrektywa {$UNITPATH filename} jako odpowiednik {$LIBRARYPATH filename} dodana mo\u017cliwo\u015b\u0107 podania \u015bcie\u017cki dla modu\u0142u deklarowanego przez USES, np: uses crt, vector in '..\\3d\\vector.pas'; dodana obs\u0142uga modu\u0142\u00f3w LIBRARY dodany modyfikator EXTERNAL dla zmiennych, procedur, funkcji dodana mo\u017cliwo\u015b\u0107 ustawienia adresu kompilacji z poziomu programu, np.: program name : address; library name : address;","title":"1.7.0"},{"location":"#169","text":"poprawiona alokacja pami\u0119ci dla tablic [0..0], wymuszany jest wst\u0119pnie 'ABSOLUTE $0000', oszcz\u0119dzamy 1 bajt pami\u0119ci dodana mo\u017cliwo\u015b\u0107 deklaracji tablic bez podania ich rozmiaru, np.: var tab: array of byte = [1,3,4,3,1]; var tb: array of char = 'abcdefghij'; nowa dyrektywa kompilatora {$bin2csv filename} pozwala inicjowa\u0107 tablice np.: var tb: array of byte = [ {$bin2csv filename} ]; nowa dyrektywa kompilatora {$optimization loopunroll} , {$optimization noloopunroll} , dokonuje rozp\u0119tlenia p\u0119tli FOR przy sta\u0142ych parametrach nowy modu\u0142 BLOWFISH pozwalaj\u0105cy szyfrowa\u0107, deszyfrowa\u0107 ci\u0105gi znakowe wg podanego klucza nowy przyk\u0142ad a8\\AES-Rijndeal","title":"1.6.9"},{"location":"#167-168","text":"rezygnacja z rozszerzania typu dla wyra\u017ce\u0144 z SHR nowy typ zasobu SAPR, SAPRPLAY dla RMTPLAY jako drugi parametr mo\u017cna poda\u0107 adres dla zmiennych na stronie zerowej SizeOfResource(variable, name) unit SAPLZSS unit SHANTI unit SHA1 unit xSFX unit SYSTEM: NtoBE, RorByte, RorWord, RorDWord, RolByte, RolWord, RolDWord, SarShortint, SarSmallint, SarLongint mo\u017cliwo\u015b\u0107 zaincjowania tablicy typu CHAR przez STRING (je\u015bli string jest kr\u00f3tszy zostan\u0105 wstawione spacje), np.: tab: array [0..15] of char = '0123456789ABCDEF'; naprawione przekazywanie warto\u015bci funkcji przez tablice dodana obsluga przerwania VBLKI (natychmiastowe) przez SetIntVec, GetIntVec (https://mads.atari8.info/doc/pl/przerwania/) przepisany kod kompilatora na moddzielne modu\u0142y przepisany kod obs\u0142ugi tablic ze wska\u017anikami do rekord\u00f3w tab: array [0..x] of record^ dodana optymalizacja 'Common head/tail Sequence coalescing'","title":"1.6.7-1.6.8"},{"location":"#166","text":"poprawiona implementacja EXIT dodano mo\u017cliwo\u015b\u0107 generowania kodu dla RAW (-target) dodano obs\u0142ug\u0119 modyfikatora INLINE dla procedur i funkcji dodano mo\u017cliwo\u015b\u0107 zadeklarowania zmiennej na stronie zerowej poprzez u\u017cycie modyfikatora REGISTER dodana obs\u0142uga typu TEXTFILE (TEXT) unit INIFILES unit ZX2 unit SYSUTILS: CompareMem, TryStrToInt unit SYSTEM: CompareByte, Pos, Delete poprawiono przekazywanie parametr\u00f3w do obiekt\u00f3w (OBJECT) bez udzia\u0142u stosu programu :STACKORIGIN (w wi\u0119kszo\u015bci przypadk\u00f3w) dodano mo\u017cliwo\u015b\u0107 oznaczenia zmiennej jako ulotnej [volatile] [volatile] vcount: byte absolute $d40b; dla OBJECT dodano metody CONSTRUCTOR, DESTRUCTOR dodano obs\u0142ug\u0119 makr {$define label (parametry) := wyra\u017cenie} dodana konstrukcja 'FOR element IN array' dla tablic nie przekraczaj\u0105cych 256 bajt\u00f3w wi\u0119cej wolnej pami\u0119ci na stronie zerowej, wska\u017aniki FXPTR, PSPTR s\u0105 teraz alokowane w zale\u017cno\u015bci od tego czy s\u0105 u\u017cywane dodana obs\u0142uga typu FLOAT16 dodana obs\u0142uga typu proceduralnego","title":"1.6.6"},{"location":"#165","text":"przepisana obs\u0142uga CASE OF przepisany kod optymalizacji dla tablic nie przekraczaj\u0105cych 256 bajt\u00f3w optymalizacja dla warunk\u00f3w '>', '<=' dodana alokacja pami\u0119ci dla tablic typu STRING (do tej pory odk\u0142adany by\u0142 tylko wska\u017anik, dzia\u0142a\u0142o to jak 'tablica ^string') dodana nowa platforma, Commodore C4 Plus unit GRAPHICS: procedura Font(charset: pointer); unit STRINGUTILS unit MISC, RMT, CMC, MPT: DetectAntic unit SYSTEM zmieniony w celu uwzgl\u0119dnienia platform ATARI, C64, C4Plus unit ZX0 unit HCM2 dodano obs\u0142uga $resource (RCDATA, RCASM) dla platform C64, C4Plus, zasoby s\u0105 sortowane wed\u0142ug rosn\u0105cych adres\u00f3w rozszerzony zas\u00f3b RCDATA o mo\u017cliwo\u015b\u0107 okre\u015blenia ofsetu dla \u0142adowanego pliku dodano obs\u0142ug\u0119 sk\u0142adni zgodnej z Pascalem dla bloku ASM, nie s\u0105 wymagane nawiasy { } dodana nowa dyrektywa {$codealign proc = warto\u015b\u0107}, {$codealign loop = warto\u015b\u0107} pozwalaj\u0105ca na wyr\u00f3wnanie wygenerowanego kodu","title":"1.6.5"},{"location":"#164","text":"procedury mno\u017cenie u8x8, u16x16 zast\u0105pione kodem z CC65 dodanie kodu resetujacego POKEY-a na pocz\u0105tku uruchomienia programu optymalizacje wyra\u017ce\u0144 warunkowych IF () and () and ... ; IF () or () or ... optymalizacja CMP_SHORTINT, CMP_SMALLINT GRAPH, FASTGRAPH: SetActiveBuffer, SetDisplayBuffer, NewDisplayBuffer, SwitchDisplayBuffer, przyk\u0142ad demoeffects\\lines2.pas, line3.pas, line4.pas GRAPH: procedure Ellipse(X, Y, StAngle, EndAngle, xRadius,yRadius: Word); MATH: Hypot SYSTEM: Length(string_array[element]) SYSTEM: GetMem, FreeMem SYSTEM: IntToStr(CARDINAL), Str(CARDINAL, STRING) SYSUTILS: ByteToStr(BYTE): STRING SYSUTILS: poprawione FindFirst, StrToFloat SYSTEM: poprawione Val(string, real, code) ; Val(string, single, code) nowy unit CIO: Opn, Cls, Get, Put, BGet, BPut, XIO nowy unit SIODISK, wydzielony z SYSTEM nowy unit S2, zintegrowany z instalatorem handlera VBXE S2: (S_VBXE.SYS) nowy unit DEFLATE, realizuj\u0105cy dekompresj\u0119 DEFLATE (procedure unDEF), przyk\u0142ad compression\\undef.pas nowy unit LZ4, realizuj\u0105cy dekompresj\u0119 LZ4 z pami\u0119ci lub dysku (procedure unLZ4), przyk\u0142ad compression\\unlz4.pas, unlz4_stream.pas nowy unit APLIB, realizuj\u0105cy dekompresj\u0119 apLib z pami\u0119ci RAM lub dysku (procedure unApl), przyk\u0142ad compression\\unapl.pas, unapl_stream.pas nowy unit CRC: function crc32(crc: cardinal; buf: Pbyte; len: word) nowy modyfikator procedur/funkcji PASCAL, powoduj\u0105cy przydzielenie/zwolnienie nowego bloku pami\u0119ci dla zmiennych przy ka\u017cdym wywo\u0142aniu procedury/funkcji, przyk\u0142ad 'math\\evaluate.pas' dodana mo\u017cliwo\u015b\u0107 wy\u0142\u0105czenia pami\u0119ci ROM z zachowaniem dzia\u0142ania systemu, {$DEFINE ROMOFF} kr\u00f3tsze nazwy prze\u0142acznikow -zpage (-z), -stack (-s), -data (-d), -code (-c), -define (-d), -ipath (-i) dodana mo\u017cliwo\u015b\u0107 generowania kodu dla C64 (-t c64)","title":"1.6.4"},{"location":"#163","text":"poprawki, optymalizacje SYSUTILS: Trim SYSTEM: PByte, PByteArray, PWord GRAPH, FASTGRAPH: TFrameBuffer, DisplayBuffer, FrameBuffer, SwitchBuffer, Scanline BLIBS: unit GR10PP LIB: unit GR4PP","title":"1.6.3"},{"location":"#160-162","text":"nowy unit EFAST dla przyspieszenia wyprowadzania znak\u00f3w na urz\u0105dzenie E: SYSTEM: function Copy(var S: String; Index: Byte; Count: Byte): String; SYSTEM: Palette, HPalette dodana obs\u0142uga tablic jednowymiarowych typu ^RECORD (wskaznik do rekordu) optymalizacja blok\u00f3w warunkowych, generowany jest mo\u017cliwie najkr\u00f3tszy, najszybszy kod wynikowy dodany typ PChar, [link]https://www.freepascal.org/docs-html/rtl/system/pchar.html dodana mo\u017cliwo\u015b\u0107 zwracania warto\u015bci funkcji przez typ wyliczeniowy dodany nowy prze\u0142\u0105cznik -define:symbol dodany nowy prze\u0142\u0105cznik -ipath:includepath","title":"1.6.0 - 1.6.2"},{"location":"#159-160","text":"SYSTEM: TDateTime GRAPH, FASTGRAPH: Arc, PieSlice, TLastArcCoords, LastArcCoords SYSUTILS: Now, Date, DateToStr, DecodeDate, DecodeDateTime, DecodeTime, EncodeDate, EncodeDateTime, EncodeTime, IsLeapYear, BoolToStr, StrToBool STRUTILS: AddChar, AddCharR, PadLeft, PadRight dodana obs\u0142uga {$INCLUDE %DATE%}, {$INCLUDE %TIME%}, [link]https://www.freepascal.org/docs-html/prog/progsu41.html prze\u0142\u0105czniki -CODE:, -DATA:, -STACK:, -ZPAGE: domy\u015blnie wymagaj\u0105 podania warto\u015bci HEX bez znaku pocz\u0105tkowego '$'","title":"1.5.9 - 1.6.0"},{"location":"#158","text":"GRAPHICS: Font, FontInitialize, FillRect, TextOut, TextWidth, MoveTo, LineTo SYSTEM: FileMode (RESET), [fmOpenRead, fmOpenWrite, fmOpenAppend, fmOpenReadWrite] dodana obs\u0142uga dyrektyw {$info user_defined}, {$warning user_defined}, {$error user_defined}, {$include filename}, {$resource filename} akceptuje zapis PROGRAM (par1, par2 ...) poprawione FillFlood, dodane FillFloodH (wype\u0142nianie poziomymi liniami) kompilator generuje kr\u00f3tszy kod gdy procedura/funkcja nie ma parametr\u00f3w dost\u0119p do definicji .DEFINE z poziomu ASM, MAIN.@DEFINES.nazwa procedury/funkcje INTERRUPT niezale\u017cnie czy zostan\u0105 u\u017cyte kompilator zawsze wygeneruje dla nich kod poprawiona optymalizacja blok\u00f3w REPEAT UNTIL dodana informacja o czasie kompilacji dodana obs\u0142uga inicjalizacji tablic dwuwymiarowych sta\u0142ych i zmiennych","title":"1.5.8"},{"location":"#156-157","text":"SYSUTILS: Click SYSTEM: Sqrt(Integer): Single MATH: Sign dodana mo\u017cliwo\u015b\u0107 u\u017cycia nazwy funkcji dla zwracanej warto\u015bci, dotychczas tylko przez RESULT dodana obs\u0142uga tablic typu STRING dodana obs\u0142uga dyrektywy {$LIBRARYPATH path1;path2;...} nowa biblioteka BLIBS nowa dokumentacja dla LIB, BLIBS wygenerowana przez PASDOC","title":"1.5.6 - 1.5.7"},{"location":"#153-155","text":"CRT: TextMode SYSUTILS: ExtractFilePath SYSTEM: EoLn dodana obs\u0142uga linii polece\u0144 z poziomu DOS II/D dla ParamCount, ParamStr OBJECT, mo\u017cna zdefiniowa\u0107 je bez zmiennych, tylko same metody OBJECT, mo\u017cna wywo\u0142a\u0107 metod\u0119 z poziomu metody dodana automatyczna konwersja wyra\u017ce\u0144 typu INTEGER na REAL","title":"1.5.3 - 1.5.5"},{"location":"#152","text":"nowy typ FLOAT jako odpowiednik typu SINGLE SYSTEM unti: FileSize (SDX) SYSTEM unit: EXP:Single, LN:Single, LN:Real, EXP:Real (wysoka precyzja oblicze\u0144) SYSUTILS unit: AnsiUpperCase, ExtractFileExt TYPES unit: Bounds, CenterPoint, EqualRect, InflateRect, IntersectRect, IsRectEmpty, NormalizeRect, OffsetRect, Point, PointsEqual, PtInRect, PtInEllipse, Rect, RectWidth, RectHeight, Size, UnionRect IMAGE unit: LoadMIC, LoadPIC, LoadBMP, LoadPCX, LoadGIF VIMAGE unit: LoadVBMP, LoadVPCX, LoadVGIF GRAPH, FASTGRAPH unit: SetClipRect, ClipLine, FillRect(TRect), Rectangle(TRect)","title":"1.5.2"},{"location":"#151","text":"dodane nowe prze\u0142\u0105czniki -CODE:$address, -DATA:$address -STACK:$address, -ZPAGE:$address SYSTEM unit: RandomF (Result as Single), VAL (Integer, Single) GRAPH, FASTGRAPH unit: Bar, Bar3D, GetX, GetY, MoveRel, FloodFill MATH unit: RandomRange, RandomRangeF, RandG (gaussian distributed random number) CRT unit: SOUND (dzia\u0142a identycznie jak SOUND w Atari BASIC) VBXE unit: TVBXEMemoryStream dodany komunikat ostrze\u017cenia 'Comparison might be always true/false due to range of constant and expression' zasoby RCASM, CMCPLAY, MPTPLAY mo\u017cna teraz \u0142adowa\u0107 pod ROM dodana mo\u017cliwo\u015b\u0107 oznaczenia kodowania ci\u0105gu znakowego jako internal ANTIC-a poprzez znak tyldy ~ , np.: txt0: string = 'Atari'~; // ci\u0105g w kodach ANTIC-a txt1: string = 'Spectrum'*~; // ci\u0105g w inwersie w kodach ANTIC-a","title":"1.5.1"},{"location":"#150","text":"poprawiona i uzupe\u0142niona inicjalizacja tablic typu POINTER poprawiona i uzupe\u0142niona inicjalizacja zmiennych typu wyliczeniowego wprowadzony typ LONGWORD, DWORD, UINT32 jako odpowiednik CARDINAL wprowadzony typ LONGINT jako odpowiednik INTEGER zreorganizowane typy rzeczywiste, typ ShortReal (fixed point Q8.8), Real (fixed point Q24.8), Single (32bit IEEE-754) unit SYSTEM (const SINGLE): NaN, Infinity, NegInfinity unit SYSTEM (type SINGLE): SIN, COS, ABS, SQRT, ISQRT, ROUND, TRUNC unit MATH (type SINGLE): LOG2, LOG10, LOGN, IsNaN dla WRITE/WRITELN akceptowane i ingorowane jest formatowanie wyniku, np.: writeln(f:8:8)","title":"1.5.0"},{"location":"#148-149","text":"zmniejszenie wska\u017anika stosu programowego w przypadku wywo\u0142ania funkcji bez odebrania jej warto\u015bci lepsza ocena mo\u017cliwo\u015bci ustalenia adresu sta\u0142ej/zmiennej, dodany komunikat \"Can't take the address of constant expressions\"","title":"1.4.8 / 1.4.9"},{"location":"#147","text":"optymalizacja dla imulBYTE, imulWORD, imulCARD, mulSHORTINT, mulSMALLINT, mulINTEGER dodana obs\u0142uga wska\u017anika rekordu, np.: type TPoint = record x,y: smallint end; var a,b: ^TPoint; begin a^.y := b^.x; a^ := b^; end. dodana obs\u0142uga sekcji INITIALIZATION w modu\u0142ach UNIT dodany nowy typ EXTMEM dla pliku resource $R, pozwalajacy \u0142adowa\u0107 dane do pami\u0119ci dodatkowej dodany nowy typ OBJECT, czyli RECORD z dodatkowymi metodami type TMemoryStream = Object Position: cardinal; Size: cardinal; procedure Create; procedure ReadBuffer(var Buffer; Count: word); procedure WriteBuffer(var Buffer; Count: word); end; poprawione biblioteki CMC, MPT, RMT","title":"1.4.7"},{"location":"#146","text":"dodana obs\u0142uga dyrektyw warunkowych $IFDEF, $IFNDEF, $ELSE, $ENDIF, $DEFINE, $UNDEF przez DMSC {$define test} const {$ifdef test} a=1; {$else} a=2; {$endif} dodana mo\u017cliwo\u015b\u0107 przekazania warto\u015bci funkcji przez EXIT(expression) dodana podstawowa implementacja dla typu wyliczeniowego (w pliku wynikowym nie s\u0105 zapisywane nazwy etykiet) dodana obs\u0142uga tablic dwuwymiarowych","title":"1.4.6"},{"location":"#144145","text":"poprawione por\u00f3wnanie typ\u00f3w tego samego rozmiaru ale o przeciwnych znakach dodana mo\u017cliwo\u015b\u0107 u\u017cycia klauzuli USES w blokach modu\u0142\u00f3w UNIT dodany wym\u00f3g deklaracji funkcji/procedur w sekcji INTERFACE modu\u0142\u00f3w UNIT poprawione zauwa\u017cone b\u0142\u0119dy optymalizatora","title":"1.4.4/1.4.5"},{"location":"#143","text":"dodana mo\u017cliwo\u015b\u0107 zwr\u00f3cenia warto\u015bci funkcji przez RECORD, np: var p: TPoint; p:=Point(x,y); {$f page} FAST_MUL, procedury szybkiego mno\u017cenia dla BYTE, SHORTINT, WORD, SMALLINT, SINGLE SYSTEM: ReadConfig, ReadSector, WriteSector SYSTEM: Point, Rect, Bounds, PointsEqual link DOS: CurrentMinuteOfDay, CurrentSec100OfDay, CurrentSecondOfDay, MinuteOfDay, MinutesToTime, SecondOfDay, SecondsToTime link MATH: Power, ArcTan2, InRange, EnsureRange, CycleToRad, DegNormalize, DegToGrad, DegToRad, DivMod, GradToDeg, GradToRad, RadToCycle, RadToDeg, RadToGrad link nowy typ LABEL dodana obs\u0142uga GOTO label","title":"1.4.3"},{"location":"#141-142","text":"optymalizacja kodu wynikowego 6502 generowanego dla p\u0119tli FOR poprawiony odczyt plik\u00f3w include i resource MISC: DetectCPUSpeed dodatkowy typ danych rzeczywistych SINGLE <-128..127>","title":"1.4.1 / 1.4.2"},{"location":"#140","text":"w parametrach formalnych procedur i funkcji dodana mo\u017cliwo\u015b\u0107 podania typu UNTYPED (tylko przez VAR), np. procedure move(var x,y; count: word); begin end; move(tab[100], tab[200], 50); SYSTEM: poprawki dla FILLCHAR, FILLBYTE, MOVE fillchar(pointer($bc40+40*8), 100, ord('a')); fillchar(scr[40*8], 100, ord('a')); // teraz takie wywo\u0142anie te\u017c jest mo\u017cliwe funkcja INTTOREAL usuni\u0119ta, zast\u0105piona przez wbudowan\u0105 konwersj\u0119 typu REAL, np. var f: real; i: word; f:=real(i); FASTGRAPH: SetClipRect, ClipLine (Cohen-Sutherland algorithm) poprawki dla {$i filename}, poprawne liczenie linii kompilowanego programu","title":"1.4.0"},{"location":"#138","text":"SYSTEM: RANDOM(RANGE: BYTE): BYTE; RANDOM(RANGE: INTEGER): SMALLINT; CRT: WHEREX, WHEREY SYSUTILS: BEEP dodatkowy znak * po apostrofie ' oznacza inwers znak\u00f3w, np.: writeln('inwers'*'bez inwersu');","title":"1.3.8"},{"location":"#137","text":"dodana mo\u017cliwo\u015b\u0107 \u0142adowania bloku resource {$R} pod adres tablicy","title":"1.3.7"},{"location":"#136","text":"dodane rozkazy GetIntVec, SetIntVec w zast\u0119pstwie rozkazu Intr umo\u017cliwione zwracanie warto\u015bci RESULT dla funkcji poprzez tablice poprawki dla MOVE (downwards, upwards) optymalizacja ASM dla procedur/funkcji POKE, DPOKE, PEEK, DPEEK, FILLCHAR, MOVE, INTTOREAL SYSTEM: ParamCount, ParamStr (SDX, BWDOS)","title":"1.3.6"},{"location":"#135","text":"dodana mo\u017cliwo\u015b\u0107 odczytu adresu sta\u0142ej, np.: const tb: array [0..0] of byte = ( lo(word(@tb)) ); - dodany odczyt wektor\u00f3w DLI, VBL przez rozkaz INTR intr(rVBL, label); intr(rDLI, label);","title":"1.3.5"},{"location":"#134","text":"dodana dodatkowa informacja o zajmowanej pami\u0119ci przez kolejne kompilowane modu\u0142y dodany nowy modu\u0142 VBXE (tryb OVERLAY, BLITTER) dodana obs\u0142uga b\u0142\u0119d\u00f3w dla operacji I/O {I+} {I-} IOCHECK ON/OFF dwie dodatkowe poprawki Greblusa dla $I, $R z my\u015bl\u0105 o dzia\u0142aniu w \u015brodowisku Linuxa","title":"1.3.4"},{"location":"#133","text":"Greblus doda\u0142 poprawki umo\u017cliwiaj\u0105ce dzia\u0142anie kompilatora z Linux-em dodana mo\u017cliwo\u015b\u0107 zaincjowania wska\u017anika tmp: byte; p: pointer = @tmp; a: ^byte = @tmp; dodana mo\u017cliwo\u015b\u0107 przypisania rekordu type a = record x,y: byte end; var k,w: a; k:=w; GRAPH: SetVideoBank, SetColorMapDimensions, SetColorMapEntry VBXE: GetXDL, SetXDL, RunBlit, ClrVideoBank","title":"1.3.3"},{"location":"#132","text":"DOS: GetTime, SetTime MATH: Ceil SYSUTILS: GetTickCount FindFirst ... obs\u0142uga Attributes wbudowanie funkcji w kompilator: INT, FRAC, TRUNC, ROUND, ODD","title":"1.3.2"},{"location":"#131","text":"dodana obs\u0142uga rekord\u00f3w RECORD {$i filename} {$r filename}, Resource Type: RCDATA, DOSFILE, RELOC, RMT, MPT, CMC dodany prze\u0142\u0105cznik -o Optimize code mo\u017cliwo\u015b\u0107 wymuszenia typu dla CONST const a: word = 5; // WORD b = 5; // BYTE dodana obs\u0142uga modyfikator\u00f3w INTERRUPT, FORWARD, REGISTER dla procedur i funkcji dodana obs\u0142uga mapy kolor\u00f3w (40x30x8x8) VBXE (modu\u0142 GRAPH, CRT), SetColorMap, SetColorCell, SetVideoBank SYSUTILS: TSearchRec, FindFirst, FindNext, FindClose GRAPH, FASTGRAPH: FillRect, FillEllipse SYSTEM: ODD, INT, LOW, HIGH, SIZEOF, INTR (INTERRUPT_NUMBER), BinStr, OctStr, HexStr, Pause, Sound, NoSound, Concat RMT: RMTINIT, RMTPLAY, RMTSTOP MPT: MPTINIT, MPTPLAY, MPTSTOP CMC: CMCINIT, CMCPLAY, CMCSTOP","title":"1.3.1"},{"location":"ados/","text":"Alternatywa dla DOS-a foxDOS instaluje urz\u0105dzenie D: jak ka\u017cdy inny DOS Atari przy starcie wczytuje plik uruchamialny o nazwie AUTORUN obs\u0142uguje standardowy system plik\u00f3w DOS 2 obs\u0142ugiwany rozmiar sektora (128 lub 256 bajt\u00f3w) jest ustalany na etapie kompilacji foxDOS-a foxDOS umo\u017cliwia odczyt pliku przez D: obs\u0142uguje funkcj\u0119 BINARY LOAD, np. XIO 40,#1,0,0,\u201dD:FILE.EXE\u201d foxDOS mie\u015bci si\u0119 w ca\u0142o\u015bci w sektorach odczytu wst\u0119pnego (boot sectors) foxDOS nie ustawia MEMLO, ale zajmuje tylko obszar pami\u0119ci $0700..$097F foxDOS nie wy\u0142\u0105cza ROM-u podczas transmisji ograniczenia: jednocze\u015bnie mo\u017cna czyta\u0107 tylko jeden plik, ale mo\u017ce on by\u0107 dowolnej d\u0142ugo\u015bci umo\u017cliwia nadpisanie istniej\u0105cego pliku mieszcz\u0105cego si\u0119 w tylko jednym sektorze inne operacje, jak odczyt katalogu, kasowanie, zmiana nazwy itd. nie s\u0105 obs\u0142ugiwane copy filename.obx disk\\autorun. dir2atr.exe -md -B foxdos.obx disk.atr disk\\ xBootDOS MEMLO = $980, nie u\u017cywa strony $04xx,$05xx ani $06x po wczytaniu automatycznie uruchamia program zapisany pod nazw\u0105 \u201eAUTO\u201d automatycznie konfiguruje si\u0119 do odpowiedniej wielko\u015bci sektora (128/256) SD/ED/DD oraz wersji systemu plik\u00f3w DOS2 (rozmiar obrazu dysku do 16 MB) obs\u0142uguje tak\u017ce systemy BiboDOS i TopDOS z 64/128 wpisami katalogowymi pozwala nadpisywa\u0107 istniej\u0105ce pliki obs\u0142uguje funkcj\u0119 BINARY LOAD, np. XIO 40,#1,0,0,\u201dD:FILE.EXE\u201d dodatkowe komendy NOTE i POINT znajduj\u0105 si\u0119 w pliku xBDext (mog\u0105 by\u0107 za\u0142adowane automatycznie \u2013 zmie\u0144 nazw\u0119 na AUTO) ograniczenia: jednocze\u015bnie mo\u017cna czyta\u0107 tylko jeden plik, ale mo\u017ce on by\u0107 dowolnej d\u0142ugo\u015bci inne operacje, jak odczyt katalogu, kasowanie, zmiana nazwy itd. nie s\u0105 obs\u0142ugiwane copy filename.obx disk\\autorun. dir2atr.exe -md -B xBootDOS.obx disk.atr disk\\ dir2atr Program dla Windows przy pomocy kt\u00f3rego mo\u017cna tworzy\u0107 obrazy dyskietek Atari XE/XL ATR","title":"Alternatywa dla DOS-a"},{"location":"ados/#alternatywa-dla-dos-a","text":"","title":"Alternatywa dla DOS-a"},{"location":"ados/#foxdos","text":"instaluje urz\u0105dzenie D: jak ka\u017cdy inny DOS Atari przy starcie wczytuje plik uruchamialny o nazwie AUTORUN obs\u0142uguje standardowy system plik\u00f3w DOS 2 obs\u0142ugiwany rozmiar sektora (128 lub 256 bajt\u00f3w) jest ustalany na etapie kompilacji foxDOS-a foxDOS umo\u017cliwia odczyt pliku przez D: obs\u0142uguje funkcj\u0119 BINARY LOAD, np. XIO 40,#1,0,0,\u201dD:FILE.EXE\u201d foxDOS mie\u015bci si\u0119 w ca\u0142o\u015bci w sektorach odczytu wst\u0119pnego (boot sectors) foxDOS nie ustawia MEMLO, ale zajmuje tylko obszar pami\u0119ci $0700..$097F foxDOS nie wy\u0142\u0105cza ROM-u podczas transmisji ograniczenia: jednocze\u015bnie mo\u017cna czyta\u0107 tylko jeden plik, ale mo\u017ce on by\u0107 dowolnej d\u0142ugo\u015bci umo\u017cliwia nadpisanie istniej\u0105cego pliku mieszcz\u0105cego si\u0119 w tylko jednym sektorze inne operacje, jak odczyt katalogu, kasowanie, zmiana nazwy itd. nie s\u0105 obs\u0142ugiwane copy filename.obx disk\\autorun. dir2atr.exe -md -B foxdos.obx disk.atr disk\\","title":"foxDOS"},{"location":"ados/#xbootdos","text":"MEMLO = $980, nie u\u017cywa strony $04xx,$05xx ani $06x po wczytaniu automatycznie uruchamia program zapisany pod nazw\u0105 \u201eAUTO\u201d automatycznie konfiguruje si\u0119 do odpowiedniej wielko\u015bci sektora (128/256) SD/ED/DD oraz wersji systemu plik\u00f3w DOS2 (rozmiar obrazu dysku do 16 MB) obs\u0142uguje tak\u017ce systemy BiboDOS i TopDOS z 64/128 wpisami katalogowymi pozwala nadpisywa\u0107 istniej\u0105ce pliki obs\u0142uguje funkcj\u0119 BINARY LOAD, np. XIO 40,#1,0,0,\u201dD:FILE.EXE\u201d dodatkowe komendy NOTE i POINT znajduj\u0105 si\u0119 w pliku xBDext (mog\u0105 by\u0107 za\u0142adowane automatycznie \u2013 zmie\u0144 nazw\u0119 na AUTO) ograniczenia: jednocze\u015bnie mo\u017cna czyta\u0107 tylko jeden plik, ale mo\u017ce on by\u0107 dowolnej d\u0142ugo\u015bci inne operacje, jak odczyt katalogu, kasowanie, zmiana nazwy itd. nie s\u0105 obs\u0142ugiwane copy filename.obx disk\\autorun. dir2atr.exe -md -B xBootDOS.obx disk.atr disk\\","title":"xBootDOS"},{"location":"ados/#dir2atr","text":"Program dla Windows przy pomocy kt\u00f3rego mo\u017cna tworzy\u0107 obrazy dyskietek Atari XE/XL ATR","title":"dir2atr"},{"location":"asm/","text":"ASM Bloki assemblera ASM nie s\u0105 przez kompilator weryfikowane pod wzgl\u0119dem sk\u0142adni, dokonuje tego dopiero Mad Assembler . UWAGA: Wymagane jest aby zachowa\u0107 stan rejestru X CPU6502 , kt\u00f3ry u\u017cywany jest do obs\u0142ugi stosu programowego Mad-Pascal . Kompilator dopuszcza dwie sk\u0142adnie bloku ASM , z klamrami { } jak dla komentarza i standardow\u0105 bez klamer. ASM lda #10 sta 712 END; ASM { lda #10 sta 712 }; procedure name; assembler; asm lda #10 sta 712 end; procedure name; assembler; asm { lda #10 sta 712 }; end; $LINK {$link filename} Dyrektywa kompilatora {$link filename} pozwala do\u0142\u0105czy\u0107 plik relokowalny z Mad Assembler -a do kompilowanego programu Mad-Pascal . .reloc .extrn edx .dword .extrn print .proc (.dword edx) .var .public prc .proc prc (.dword a .dword b .dword c) .var .var a,b,c .dword print a print b print c rts .endp W powy\u017cszym przyk\u0142adzie korzystamy z procedury PRINT , kt\u00f3ra jest zdefiniowana w Mad-Pascal . uses crt; procedure prc(a,b,c: integer); external; procedure print(value: dword); keep; register; begin writeln(value); end; {$link test.obx} // link PRC procedure begin prc(11, 347, 321785); repeat until keypressed; end. Z poziomu assemblera mamy dost\u0119p do procedur Mad-Pascal ale tylko oznaczonych modyfikatorem REGISTER , czyli takich kt\u00f3rych parametry przekazywane s\u0105 przez programowe rejestry EDX , ECX , EAX (jeste\u015bmy ograniczeni do maksymalnie trzech parametr\u00f3w). Modyfikator KEEP wymusza pozostawienie procedury w kompilowanym kodzie niezale\u017cnie od tego czy wyst\u0105pi\u0142o jej u\u017cycie czy nie (normalnie procedury/funkcje kt\u00f3re nie s\u0105 u\u017cywane s\u0105 eliminowane). Mad-Pascal natomiast ma dost\u0119p do procedur z linkowanego pliku assemblera, kt\u00f3rych parametry przekazywane s\u0105 przez zmienne, modyfikator .VAR . .proc prc (.dword a .dword b .dword c) .var W programie relokowalnym Mad Assembler -a potrzebujemy dodatkowej deklaracji zewn\u0119trzych symboli EDX , ECX , EAX . .extrn edx, ecx, eax .dword Sama procedura Mad-Pascal do kt\u00f3rej chcemy mie\u0107 dost\u0119p z poziomu assemblera jest deklarowana jako procedura zewn\u0119trzna z parametrami oznaczaj\u0105cymi rejestry programowe EDX , ECX , EAX . Wi\u0119cej informacji na temat modyfikatora REGISTER i kolejno\u015bci alokacji parametr\u00f3w w rejestrach programowych w rozdziale Procedury i funkcje . .extrn print .proc (.dword edx) .var Dost\u0119p do procedury PRC z poziomu Mad-Pascal zapewni nam jej upublicznienie przez dyrektyw\u0119 assemblera .PUBLIC . .public prc Po assemblacji naszego przyk\u0142adowego relokowalnego programu assemblera TEST.ASM otrzymujemy plik TEST.OBX , kt\u00f3ry mo\u017cemy po\u0142\u0105czy\u0107 z programem Mad-PAscal dyrektyw\u0105 {$LINK} . {$link test.obx}","title":"Wstawki assemblera"},{"location":"asm/#_1","text":"","title":""},{"location":"asm/#asm","text":"Bloki assemblera ASM nie s\u0105 przez kompilator weryfikowane pod wzgl\u0119dem sk\u0142adni, dokonuje tego dopiero Mad Assembler . UWAGA: Wymagane jest aby zachowa\u0107 stan rejestru X CPU6502 , kt\u00f3ry u\u017cywany jest do obs\u0142ugi stosu programowego Mad-Pascal . Kompilator dopuszcza dwie sk\u0142adnie bloku ASM , z klamrami { } jak dla komentarza i standardow\u0105 bez klamer. ASM lda #10 sta 712 END; ASM { lda #10 sta 712 }; procedure name; assembler; asm lda #10 sta 712 end; procedure name; assembler; asm { lda #10 sta 712 }; end;","title":"ASM"},{"location":"asm/#link","text":"{$link filename} Dyrektywa kompilatora {$link filename} pozwala do\u0142\u0105czy\u0107 plik relokowalny z Mad Assembler -a do kompilowanego programu Mad-Pascal . .reloc .extrn edx .dword .extrn print .proc (.dword edx) .var .public prc .proc prc (.dword a .dword b .dword c) .var .var a,b,c .dword print a print b print c rts .endp W powy\u017cszym przyk\u0142adzie korzystamy z procedury PRINT , kt\u00f3ra jest zdefiniowana w Mad-Pascal . uses crt; procedure prc(a,b,c: integer); external; procedure print(value: dword); keep; register; begin writeln(value); end; {$link test.obx} // link PRC procedure begin prc(11, 347, 321785); repeat until keypressed; end. Z poziomu assemblera mamy dost\u0119p do procedur Mad-Pascal ale tylko oznaczonych modyfikatorem REGISTER , czyli takich kt\u00f3rych parametry przekazywane s\u0105 przez programowe rejestry EDX , ECX , EAX (jeste\u015bmy ograniczeni do maksymalnie trzech parametr\u00f3w). Modyfikator KEEP wymusza pozostawienie procedury w kompilowanym kodzie niezale\u017cnie od tego czy wyst\u0105pi\u0142o jej u\u017cycie czy nie (normalnie procedury/funkcje kt\u00f3re nie s\u0105 u\u017cywane s\u0105 eliminowane). Mad-Pascal natomiast ma dost\u0119p do procedur z linkowanego pliku assemblera, kt\u00f3rych parametry przekazywane s\u0105 przez zmienne, modyfikator .VAR . .proc prc (.dword a .dword b .dword c) .var W programie relokowalnym Mad Assembler -a potrzebujemy dodatkowej deklaracji zewn\u0119trzych symboli EDX , ECX , EAX . .extrn edx, ecx, eax .dword Sama procedura Mad-Pascal do kt\u00f3rej chcemy mie\u0107 dost\u0119p z poziomu assemblera jest deklarowana jako procedura zewn\u0119trzna z parametrami oznaczaj\u0105cymi rejestry programowe EDX , ECX , EAX . Wi\u0119cej informacji na temat modyfikatora REGISTER i kolejno\u015bci alokacji parametr\u00f3w w rejestrach programowych w rozdziale Procedury i funkcje . .extrn print .proc (.dword edx) .var Dost\u0119p do procedury PRC z poziomu Mad-Pascal zapewni nam jej upublicznienie przez dyrektyw\u0119 assemblera .PUBLIC . .public prc Po assemblacji naszego przyk\u0142adowego relokowalnego programu assemblera TEST.ASM otrzymujemy plik TEST.OBX , kt\u00f3ry mo\u017cemy po\u0142\u0105czy\u0107 z programem Mad-PAscal dyrektyw\u0105 {$LINK} . {$link test.obx}","title":"$LINK"},{"location":"biblioteki-podstawowe/","text":"W katalogu LIB Mad-Pascala znajduj\u0105 si\u0119 potrzebne do kompilacji podstawowe modu\u0142y UNIT , takie jak SYSTEM CRT GRAPH SYSUTILS MATH DOS . Modu\u0142 SYSTEM jest kompilowany zawsze domy\u015blnie jako pierwszy. SYSTEM Constants M_PI_2 = 6.283285; // pi * 2 D_PI_2 = 1.570796; // pi / 2 D_PI_180 = 0.017453; // pi / 180 mGTIA = 0; mVBXE = $80; WINDOW = $10; NARROW = $20; VBXE_XDLADR = $0000; // XDLIST VBXE_MAPADR = $1000; // COLOR MAP ADDRESS VBXE_BCBADR = $0100; // BLITTER LIST ADDRESS VBXE_OVRADR = $5000; // OVERLAY ADDRESS VBXE_WINDOW = $B000; // 4K WINDOW $B000..$BFFF iDLI = 0; iVBL = 1; CH_DELCHR = $FE; CH_ENTER = $9B; CH_ESC = $1B; CH_CURS_UP = 28; CH_CURS_DOWN = 29; CH_CURS_LEFT = 30; CH_CURS_RIGHT = 31; CH_TAB = $7F; CH_EOL = $9B; CH_CLR = $7D; CH_BEL = $FD; CH_DEL = $7E; CH_DELLINE = $9C; CH_INSLINE = $9D; COLOR_BLACK = $00; COLOR_WHITE = $0e; COLOR_RED = $32; COLOR_CYAN = $96; COLOR_VIOLET = $68; COLOR_GREEN = $c4; COLOR_BLUE = $74; COLOR_YELLOW = $ee; COLOR_ORANGE = $4a; COLOR_BROWN = $e4; COLOR_LIGHTRED = $3c; COLOR_GRAY1 = $04; COLOR_GRAY2 = $06; COLOR_GRAY3 = $0a; COLOR_LIGHTGREEN = $cc; COLOR_LIGHTBLUE = $7c; Types TPoint TPoint = record x,y: SmallInt end; Definicja wsp\u00f3\u0142rz\u0119dnych (x,y). TRect TRect = record left, top, right, bottom: smallint end; Definicja po\u0142o\u017cenia i rozmiaru czworok\u0105ta o parametrach (left, top) - lewy g\u00f3rny naro\u017cnik, (right, bottom) - prawy dolny naro\u017cnik. TString TString = string[32]; Definicja kr\u00f3tkiego ci\u0105gu znakowego wykorzystywanego do przekazywania nazw plik\u00f3w itp. Variables IOResult IOResult: byte; Zmienna przechowuje ostatni b\u0142\u0105d operacji I/O . Kody b\u0142\u0119d\u00f3w I/O . Dla PC brak b\u0142\u0119d\u00f3w I/O oznacza IORresult = 0 , dla Atari XE/XL IOResult = 1 . ScreenWidth ScreenWidth: word = 40 Zmienna przechowuj\u0105ca aktualn\u0105 szeroko\u015b\u0107 ekranu. Domy\u015blnie jest to warto\u015b\u0107 40 dla ekranu edytora. ScreenHeight: word = 24; ScreenHeight Zmienna przechowuj\u0105\u0107a aktualn\u0105 wysoko\u015b\u0107 ekranu. Domy\u015blnie jest to warto\u015b\u0107 24 dla ekranu edytora. Procedures and functions Abs Append ArcTan Assign BinStr Concat Blockread Blockwrite Chr Cos Close Dec DeleteFile DPeek DPoke Eof Exit Exp FilePos FileSize FillChar Frac GetIntVec Halt Hi HexStr Inc Ln Lo LowerCase Move OctStr Odd Ord ParamCount ParamStr Pause Peek Point PointsEqual Poke Pred Random ReadConfig ReadSecto Rect RenameFile Reset Rewrite Round Seek SetLength SetIntVec Sin Succ Space SizeOf Str StringOfChar Sqr Sqrt Trunc UpCase Val WriteSector Abs function Abs(x: real): real; function Abs(x: integer): integer; Funkcja obliczaj\u0105ca warto\u015b\u0107 bezwzgl\u0119dn\u0105 podanej liczby (ang. Absolute value ). Warto\u015b\u0107 bezwzgl\u0119dna liczby nieujemnej to ta sama liczba, a liczby ujemnej - liczba do niej przeciwna. Funkcja w przypadku podania jej argumentu ca\u0142kowitego zwraca wynik r\u00f3wnie\u017c typu ca\u0142kowitego. Append Append(var F: text) Otwiera istniej\u0105cy zbi\u00f3r tekstowy w trybie dopisywania (wska\u017anik zbioru jest ustawiany na ko\u0144cu zbioru). F jest tekstow\u0105 zmienn\u0105 plikow\u0105, kt\u00f3ra musi by\u0107 skojarzona z istniej\u0105cym zbiorem dyskowym (przy u\u017cyciu procedury Assign ). ArcTan function ArcTan(x: real): real; Funkcja (arcus tangens) zwraca warto\u015b\u0107 k\u0105ta, kt\u00f3rego tangens wynosi x . Assign procedure Assign(var F:File; FileName:string) Procedura przypisuje zmiennej plikowej F plik o nazwie FileName . Aby m\u00f3c odwo\u0142ywa\u0107 si\u0119 do jakiego\u015b pliku, zawsze nale\u017cy najpierw u\u017cy\u0107 procedury Assign . Przy dalszych operacjach pliki s\u0105 identyfikowane przy pomocy zmiennej plikowej, a nie nazwy. BinStr function BinStr(Value: cardinal; Digits: byte): TString; Funkcja zwraca ci\u0105g znakowy z reprezentacj\u0105 binarn\u0105 warto\u015bci Value . Digits okre\u015bla d\u0142ugo\u015b\u0107 ci\u0105gu, kt\u00f3ry maksymalnie mo\u017ce liczy\u0107 32 znaki. Concat function Concat(a,b: string): string; assembler function Concat(a: string; b: char): string; assembler; function Concat(a: char; b: string): string; assembler; function Concat(a,b: char): string; Funkcja \u0142\u0105czy dwa ci\u0105gi tekstowe w nowy ci\u0105g znakowy. Blockread procedure BlockRead(var f: file; var Buf; Count: word; var Result: word); Procedura wczytuje z pliku plik do zmiennej Buf nie wi\u0119cej ni\u017c Count bajt\u00f3w i umieszcza w zmiennej Result ilo\u015b\u0107 rzeczywi\u015bcie przeczytanych bajt\u00f3w (kt\u00f3ra mo\u017ce by\u0107 mniejsza od oczekiwanej np. ze wzgl\u0119du na rzeczywist\u0105 d\u0142ugo\u015b\u0107 pliku). Blockwrite procedure BlockWrite(var f: file; var Buf; Count: word; var Result: word); Procedura zapisuje do pliku ze zmiennej Buf nie wi\u0119cej ni\u017c Count bajt\u00f3w. Chr Chr(65); // Zwraca znak A Chr(90); // Zwraca znak Z Chr(32); // Zwraca znak spacji Writeln(#65); // Znak A Writeln(#65#32#65); // Napisze 'A Z' Funkcja zwraca znak Char o odpowiadaj\u0105cym kodzie ATASCII podanym w parametrze. Zamiennie z funkcj\u0105 Chr , chc\u0105c uzyska\u0107 odpowiedni znak mo\u017cemy u\u017cy\u0107 jego kodu ATASCII poprzedzaj\u0105c go # . Cos function Cos(x: real): real; Cosinus k\u0105ta, x w radianach. Close procedure Close(var f: file); Procedura s\u0142u\u017c\u0105ca do zamykania otwartego pliku dowolnego typu. Ka\u017cdy plik otwarty przy pomocy Reset lub Rewrite powinno si\u0119 zamkn\u0105\u0107 przy pomocy Close . Dec procedure Dec(var X [, N: int]); Procedura zmniejsza warto\u015b\u0107 parametru X o 1 lub warto\u015b\u0107 parametru N . Warto\u015b\u0107 parametru X mo\u017ce by\u0107 typu CHAR BYTE WORD CARDINAL . Procedura DEC generuje optymalny kod, jest zalecana do u\u017cywania w p\u0119tlach, zamiast operatora odejmowania - . dec(tmp); dec(tmp[2]); DeleteFile function DeleteFile(FileName: string): Boolean; Funkcja pozwala skasowa\u0107 plik z dysku o nazwie FileName , zwraca TRUE kiedy operacja powiod\u0142a si\u0119, FALSE w przypadku wyst\u0105pienia b\u0142\u0119du (najcz\u0119\u015bciej z powodu zabezpieczenia przed zapisem lub b\u0142\u0119dnej nazwy pliku). DPeek function DPeek(a: word): word; Funkcja zwraca s\u0142owo spod adresu a . DPoke procedure DPoke(a: word; value: word); Procedura zapisuje s\u0142owo value pod adresem a . Eof function Eof(var f: file): Boolean; Funkcja zwraca warto\u015b\u0107 logiczn\u0105 TRUE je\u015bli osi\u0105gni\u0119ty zosta\u0142 koniec pliku. Exit Wywo\u0142anie procedury Exit powoduje natychmiastowe opuszczenie bloku programu, w kt\u00f3rym to wywo\u0142anie nast\u0105pi\u0142o. Mo\u017cna jej u\u017cy\u0107 do opuszczenia p\u0119tli, wyj\u015bcia z procedury/funkcji lub programu g\u0142\u00f3wnego. Exp function Exp(x: real): real; Funkcja podnosz\u0105ca liczb\u0119 e (=2.71) do pot\u0119gi podanej przez argument x . FilePos function FilePos(var f: file): cardinal; Funkcja zwraca aktualn\u0105 pozycj\u0119 pliku. Plik nie mo\u017ce by\u0107 tekstowy i musi by\u0107 otwarty (np. poleceniem Reset ). Bity 0..15 zwr\u00f3conej warto\u015bci to numer sektora dysku, bity 16..23 pozycja w sektorze [0..255] . Jest to odpowiednik instrukcji NOTE . FileSize function FileSize(var f: file): cardinal; Funkcja zwraca d\u0142ugo\u015b\u0107 pliku w bajtach ( Sparta DOS X ). Plik nie mo\u017ce by\u0107 tekstowy i musi by\u0107 otwarty (np. poleceniem Reset ). FillChar procedure FillChar(x: pointer; count: word; value: char); Procedura wype\u0142nia bufor okre\u015blony w parametrze X identycznymi znakami lub bajtami. Parametr value musi okre\u015bla\u0107 dane, natomiast count - ilo\u015b\u0107 danych jakie zostan\u0105 przypisane do bufora. var Buffer : array[0..100] of Char; begin FillChar(Buffer, SizeOf(Buffer), 'A'); end. Frac function Frac(x: real): real; Zwraca cz\u0119\u015b\u0107 u\u0142amkow\u0105 liczby x w postaci rzeczywistej. GetIntVec procedure GetIntVec(intno: byte; var vector: pointer); Procedura odczytuje adres wektora przerwa\u0144 wg. kodu INTNO . Obecnie dopuszczalnymi kodami s\u0105: iDLI przerwanie DLI, iVBL przerwanie VBL. Halt procedure halt; Wywo\u0142anie powoduje natychmiastowe wyj\u015bcie z programu. Mo\u017cna (opcjonalnie) poda\u0107 kod b\u0142\u0119du, w przypadku Mad-Pascal jest on ignorowany. Hi function Hi(x): byte Funkcja zwracaj\u0105ca starszy bajt parametru x . HexStr function HexStr(Value: cardinal; Digits: byte): TString; Funkcja zwraca ci\u0105g znakowy z reprezentacj\u0105 heksadecymaln\u0105 warto\u015bci Value . Digits okre\u015bla d\u0142ugo\u015b\u0107 ci\u0105gu, kt\u00f3ry maksymalnie mo\u017ce liczy\u0107 32 znaki. Inc Inc procedure Inc(var X [, N: int]); Procedura zwi\u0119ksza warto\u015b\u0107 parametru X o 1 lub warto\u015b\u0107 parametru N . Warto\u015b\u0107 parametru X mo\u017ce by\u0107 typu CHAR BYTE WORD CARDINAL . Procedura INC generuje optymalny kod, jest zalecana do u\u017cywania w p\u0119tlach, zamiast operatora dodawania + . inc(tmp); inc(tmp[2]); Int function Int(x: real): real; Funkcja zwraca cz\u0119\u015b\u0107 ca\u0142kowit\u0105 argumentu b\u0119d\u0105cego liczb\u0105 rzeczywist\u0105. Ln function Ln(x: real): real; Funkcja licz\u0105ca logarytm naturalny (o podstawie e) z podanej liczby. Argument funkcji musi by\u0107 dodatni ! Lo function Lo(x): byte; Funkcja zwracaj\u0105ca m\u0142odszy bajt parametru X . LowerCase function LowerCase(a: char): char; Funkcja zmieniaj\u0105ca znaki 'A'..'Z' na odpowiednie ma\u0142e znaki 'a'..'z'. Move procedure Move(source, dest: pointer; count: word); Procedura s\u0142u\u017cy do kopiowania danych ze \u017ar\u00f3d\u0142a, parametr Source , do bufora oznaczonego jako przeznaczenie, parametr Dest . Ilo\u015b\u0107 kopiowanych danych okre\u015bla parametr Count . OctStr function OctStr(Value: cardinal; Digits: byte): TString; Funkcja zwraca ci\u0105g znakowy z reprezentacj\u0105 \u00f3semkow\u0105 warto\u015bci Value . Digits okre\u015bla d\u0142ugo\u015b\u0107 ci\u0105gu, kt\u00f3ry maksymalnie mo\u017ce liczy\u0107 32 znaki. Odd function Odd(x: cardinal): Boolean; function Odd(x: integer): Boolean; Funkcja zwraca warto\u015b\u0107 True je\u017celi liczba okre\u015blona w parametrze X jest nieparzysta, False je\u017celi jest parzysta. Ord function Ord(X); Funkcja ta dzia\u0142a odwrotnie do Chr . Z podanego znaku jako parametr zwraca nam jego kod w ATASCII . Ord('A'); // Zwraca 65 Ord('Z'); // Zwraca 90 Ord(' '); // Zwraca 32 ParamCount function ParamCount: byte; Funkcja zwraca ilo\u015b\u0107 dost\u0119pnych argument\u00f3w ( Sparta Dos X , BWDos ), tzn. maksymalny indeks dla procedury ParamStr . ParamCount okre\u015bla ilo\u015b\u0107 parametr\u00f3w przekazanych do programu z linii polece\u0144. ParamStr function ParamStr(Index: byte): TString; Funkcja zwraca parametry programu ( Sparta Dos X , BWDos ). Index to numer parametru, czyli ci\u0105gu znak\u00f3w oddzielonego spacj\u0105. Je\u017celi uruchomimy program TEST.EXE w taki spos\u00f3b: TEST.EXE parametr1 parametr2 parametr3 To aby uzyska\u0107 parametr3 nale\u017cy poda\u0107 Index=3 , za\u015b aby uzyska\u0107 parametr1 nale\u017cy Index=1 . Index=0 to specjalny argument, wtedy funkcja zwraca nap\u0119d z kt\u00f3rego zosta\u0142 uruchomiony programu, np. D1: . Pause procedure Pause; procedure Pause(n: word); Procedura zatrzymuje dzia\u0142anie programu na N * 1.50 sek. Peek function Peek(a: word): byte; Funkcja zwraca bajt spod adresu a . Point function Point(AX, AY: smallint): TPoint; Funkcja na podstawie parametr\u00f3w AX oraz AY tworzony jest rekord typu TPoint . PointsEqual function PointsEqual(const P1, P2: TPoint): Boolean; Funkcja sprawdza czy warto\u015bci wsp\u00f3\u0142rz\u0119dnych okre\u015blone w parametrach P1 oraz P2 s\u0105 sobie r\u00f3wne. W takim wypadku funkcja zwraca warto\u015b\u0107 True . Poke procedure Poke(a: word; value: byte); Procedura zapisuje bajt value pod adresem a . Pred function Pred(X: TOrdinal): TOrdinal; Poprzednik elementu X . Random function Random: Real; assembler; Funkcja zwraca losow\u0105 warto\u015b\u0107 z przedzia\u0142u <0 .. 1> . function Random(range: byte): byte; assembler; Funkcja zwraca losow\u0105 warto\u015b\u0107 z przedzia\u0142u <0 .. range-1> , w przypadku Range=0 zwraca warto\u015b\u0107 losow\u0105 z przedzia\u0142u <0 .. 255 > . function Random(range: smallint): smallint; Funkcja zwraca losow\u0105 warto\u015b\u0107 z przedzia\u0142u <0 .. range-1> . ReadConfig function ReadConfig(devnum: byte): cardinal; Odczyt statusu stacji devnum . Wynikiem s\u0105 cztery bajty DVSTAT ($02EA..$02ED) . Byte 0 ($02ea): Bit 0:Indicates the last command frame had an error. Bit 1:Checksum, indicates that there was a checksum error in the last command or data frame Bit 2:Indicates that the last operation by the drive was in error. Bit 3:Indicates a write protected diskette. 1=Write protect Bit 4:Indicates the drive motor is on. 1=motor on Bit 5:A one indicates MFM format (double density) Bit 6:Not used Bit 7:Indicates Density and a Half if 1 Byte 1 ($02eb): Bit 0:FDC Busy should always be a 1 Bit 1:FDC Data Request should always be 1 Bit 2:FDC Lost data should always be 1 Bit 3:FDC CRC error, a 0 indicates the last sector read had a CRC error Bit 4:FDC Record not found, a 0 indicates last sector not found Bit 5:FDC record type, a 0 indicates deleted data mark Bit 6:FDC write protect, indicates write protected disk Bit 7:FDC door is open, 0 indicates door is open Byte 2 ($2ec): Timeout value for doing a format. Byte 3 ($2ed): not used, should be zero ReadSector procedure ReadSector(devnum: byte; sector: word; var buf); Procedura odczytuje sektora sector dyskietki w stacji dysk\u00f3w devnum i zapisanie go w buforze buf . Rect function Rect(ALeft, ATop, ARight, ABottom: smallint): TRect; Funckja na podstawie parametr\u00f3w tworzy rekord typu TRect . RenameFile function RenameFile(OldName, NewName: string): Boolean; Funkcja pozwala zmieni\u0107 nazw\u0119 pliku OldName na now\u0105 nazw\u0119 NewName , zwraca TRUE kiedy operacja powiod\u0142a si\u0119, FALSE w przypadku wyst\u0105pienia b\u0142\u0119du (najcz\u0119\u015bciej z powodu zabezpieczenia przed zapisem lub b\u0142\u0119dnej nazwy pliku). RenameFile('D:OLDNAME.TMP', 'NEWNAME.TMP'); Reset procedure Reset(var f: file; l: Word); Procedura otwiera istniej\u0105cy plik z nazw\u0105 przekazan\u0105 do F poleceniem Assign . Opcjonalnie mo\u017cemy poda\u0107 rozmiar rekordu w bajtach L , domy\u015blnie jest to warto\u015b\u0107 128. Rewrite procedure Rewrite(var f: file; l: Word); Procedura tworzy i otwiera nowy plik. f jest nazw\u0105 przekazan\u0105 za pomoc\u0105 polecenia Assign . Opcjonalnie mo\u017cemy poda\u0107 rozmiar rekordu w bajtach l , domy\u015blnie jest to warto\u015b\u0107 128. Round function Round(x: real): integer; Funkcja dokonuje zaokr\u0105glenia podanej liczby rzeczywistej do najbli\u017cszej liczby ca\u0142kowitej. Seek procedure Seek(var f: file; N: cardinal); Procedura ustawia pozycj\u0119 w pliku na N . N powinno by\u0107 warto\u015bci\u0105 zwr\u00f3con\u0105 przez FilePos . Jest to odpowiednik instrukcji POINT . SetLength procedure SetLength(var S: string; Len: byte); Procedura ustawia d\u0142ugo\u015b\u0107 ci\u0105gu S na LEN . SetIntVec procedure SetIntVec(intno: Byte; vector: pointer); Procedura ustawia adres wektora przerwa\u0144 wg. kodu INTNO . Obecnie dopuszczalnymi kodami s\u0105: iDLI przerwanie DLI, iVBL przerwanie VBL. Sin function Sin(x: real): real; Sinus k\u0105ta. x w radianach. Succ function Succ(X: TOrdinal): TOrdinal; Nast\u0119pnik elementu X . Space function Space(Len: Byte): ^char; Funkcja generuje nowy ci\u0105g znakowy o d\u0142ugo\u015bci Len wype\u0142niony znakami spacji. SizeOf function SizeOf(X: AnyType): byte; Funkcja zwraca rozmiar podanej zmiennej (lub typu) w bajtach. Str procedure Str(var X: TNumericType; var S: string); Procedura zamienia liczb\u0119 X na \u0142a\u0144cuch znak\u00f3w S . StringOfChar procedure StringOfChar(ch: Char; len: byte): ^char; Funkcja generuje nowy ci\u0105g znakowy o d\u0142ugo\u015bci len wype\u0142niony znakami ch . Sqr function Sqr(x: real): real; function Sqr(x: integer): integer; Funkcja obliczaj\u0105ca kwadrat podanej liczby (ang. Square ). Sqrt function Sqrt(x: real): real; function Sqrt(x: single): single; function Sqrt(x: integer): single; Funkcja obliczaj\u0105ca pierwiastek kwadratowy podanej liczby (ang. Square root ). Trunc function Trunc(x: real): integer; Funkcja zwraca cz\u0119\u015b\u0107 ca\u0142kowit\u0105 liczby rzeczywistej w postaci liczby ca\u0142kowitej. UpCase function UpCase(a: char): char; Funkcja zmieniaj\u0105ca znaki 'a'..'z' na odpowiednie du\u017ce znaki 'A'..'Z' . Val procedure Val(const S: string; var V; var Code: Byte); Procedura przekszta\u0142ca ci\u0105g znak\u00f3w S na liczb\u0119 V . Code przyjmie warto\u015b\u0107 0 je\u015bli nie by\u0142o b\u0142\u0119dnych znak\u00f3w, w przeciwnym wypadku przyjmie numer znaku kt\u00f3ry spowodowa\u0142 b\u0142\u0105d konwersji. WriteSector procedure WriteSector(devnum: byte; sector: word; var buf); Procedura zapisuje sektora sector dyskietki w stacji devnum na podstawie bufora buf . CRT Constants CN_START_SELECT_OPTION = 0; CN_SELECT_OPTION = 1; CN_START_OPTION = 2; CN_OPTION = 3; CN_START_SELECT = 4; CN_SELECT = 5; CN_START = 6; CN_NONE = 7; Variables Consol Consol: byte absolute $d01f Zmienna zwraca kod naci\u015bni\u0119tego klawisza/klawiszy konsoli. TextAttr TextAttr: byte = 0 Zmienna przechowuje warto\u015b\u0107 jaka jest dodawana do ka\u017cdego wy\u015bwietlanego znaku, np. TextAttr = $80 spowoduje \u017ce znaki b\u0119d\u0105 wy\u015bwietlane w inwersie. WhereX WhereX: byte absolute $54; Zmienna przechowuje aktualn\u0105 poziom\u0105 pozycj\u0119 kursora. WhereY WhereY: byte absolute $55; Zmienna przechowuje aktualn\u0105 pionow\u0105 pozycj\u0119 kursora. Procedures and functions ClrEol ClrScr CursorOff CursorOn Delay DelLine GotoXY InsLine Keypressed NoSound ReadKey Sound TextBackground TextColor ClrEol procedure ClrEol; Procedura czy\u015bci wiersz od aktualnej pozycji kursora do prawej strony kraw\u0119dzi ekranu. Pozycja kursora nie ulega zmianie. ClrScr procedure ClrScr; Procedura czy\u015bci ekran edytora, wykonuje kod znaku CH_CLR . CursorOff procedure CursorOff; Procedura wy\u0142\u0105cza kursor. CursorOn procedure CursorOn; Procedura w\u0142\u0105cza kursor. Delay procedure Delay(MS: Word); Procedura czeka zadan\u0105 ilo\u015b\u0107 milisekund MS . W przybli\u017ceniu Delay(1000) generuje op\u00f3\u017anienie jednej sekundy. DelLine procedure DelLine; Procedura kasuje wiersz na aktualnej pozycji kursora, wykonuje kod znaku CH_DELLINE . GotoXY procedure GotoXY(x, y: byte); Procedura ustawia now\u0105 pozycj\u0119 kursora. InsLine procedure InsLine; Procedura wstawia pusty wiersz na aktualnej pozycji kursora, wykonuje kod znaku CH_INSLINE . Keypressed function Keypressed: Boolean; Funkcja zwraca TRUE gdy zosta\u0142 naci\u015bni\u0119ty jaki\u015b klawisz klawiatury, w przeciwnym razie zwraca FALSE . NoSound procedure NoSound; Procedura wycisza kana\u0142y obu POKEY-i $D200 $D210) . ReadKey function ReadKey: char; Funkcja zwraca kod naci\u015bni\u0119tego klawisza klawiatury. Sound procedure Sound(Chan,Freq,Dist,Vol: byte); Procedura odtwarza d\u017awi\u0119k na kanale POKEY-a CHAN (0..3, 4..7) , o cz\u0119stotliwo\u015bci FREQ (0..255) , filtrach DIST (0..7) , g\u0142o\u015bno\u015bci VOL (0..15) . TextBackground procedure TextBackground(a: byte); Procedura ustawia nowy kolor t\u0142a znak\u00f3w (dzia\u0142a najlepiej z w\u0142\u0105czonym VBXE ). TextColor procedure TextColor(a: byte); Procedura ustawia nowy kolor znak\u00f3w (dzia\u0142a najlepiej z w\u0142\u0105czonym VBXE ). GRAPH Constants { graphic drivers } D1bit = 11; D2bit = 12; D4bit = 13; D6bit = 14; // 64 colors Half-brite mode - Amiga D8bit = 15; D12bit = 16; // 4096 color modes HAM mode - Amiga m640x480 = 8 + 16; { error codes } grOK = 0; grNoInitGraph = -1; grNotDetected = -2; grFileNotFound = -3; grInvalidDriver = -4; grNoLoadMem = -5; grNoScanMem = -6; grNoFloodMem = -7; grFontNotFound = -8; grNoFontMem = -9; grInvalidMode = -10; grError = -11; grIOerror = -12; grInvalidFont = -13; grInvalidFontNum = -14; grInvalidVersion = -18; Variables GraphResult GraphResult : byte Procedures and functions Bar Bar3D Circle ClipLine Ellipse FillEllipse FillRect FloodFill GetColor GetMaxX GetMaxY GetPixel GetX GetY InitGraph Line LineTo MoveRel MoveTo PutPixel Rectangle SetBkColor SetClipRect SetColor SetColorMapEntry SetColorMapDimensions Bar procedure Bar(x1, y1, x2, y2: Smallint); Prostok\u0105t, np. dla wykres\u00f3w s\u0142upkowych. Bar3D procedure Bar3D(x1, y1, x2, y2: smallint; depth: word; top: boolean); S\u0142upek dla wykres\u00f3w tr\u00f3jwymiarowych. Circle procedure Circle(x0,y0,radius: word); Okr\u0105g. ClipLine procedure ClipLine(x1, y1, x2, y2: smallint); Ellipse procedure Ellipse(x0, y0, a, b: word); Elipsa. FillEllipse procedure FillEllipse(x0, y0, a, b: word); Elipsa wype\u0142niona wewn\u0105trz. FillRect procedure FillRect(Rect: TRect); Prostok\u0105t wype\u0142niony wewn\u0105trz. FloodFill procedure FloodFill(x, y: smallint; color: byte); Wype\u0142nienie zamkni\u0119tego obszaru ekranu. GetColor function GetColor: byte; assembler; Podaj bie\u017c\u0105cy kolor rysowania. GetMaxX function GetMaxX: word; Podaj najwy\u017csz\u0105 warto\u015b\u0107 wsp\u00f3\u0142rz\u0119dnej X na ekranie. GetMaxY function GetMaxY: word; Podaj najwy\u017csz\u0105 warto\u015b\u0107 wsp\u00f3\u0142rz\u0119dnej Y na ekranie. GetPixel function GetPixel(x,y: smallint): byte; Podaj kolor danego punktu na ekranie. GetX function GetX: smallint; Podaj bie\u017c\u0105c\u0105 wsp\u00f3\u0142rz\u0119dn\u0105 X kursora graficznego. GetY function GetY: smallint; Podaj bie\u017c\u0105c\u0105 wsp\u00f3\u0142rz\u0119dn\u0105 Y kursora graficznego. InitGraph procedure InitGraph(mode: byte); procedure InitGraph(driver, mode: byte; pth: TString); Zainicjuj tryb graficzny. Line procedure Line(x0, y0, x1, y1: smallint); Linia prosta. LineTo procedure LineTo(x, y: smallint); Linia od bie\u017c\u0105cej pozycji kursora do wskazanego punktu. MoveRel procedure MoveRel(Dx, Dy: smallint); Przesu\u0144 kursor graficzny. MoveTo procedure MoveTo(x, y: smallint); Przesu\u0144 kursor graficzny do wskazanego punktu. PutPixel procedure PutPixel(x,y: smallint); procedure PutPixel(x,y: smallint; color: byte); Zapal punkt na ekranie. Rectangle procedure Rectangle(x1, y1, x2, y2: smallint); procedure Rectangle(Rect: TRect); Prostok\u0105t. SetBkColor procedure SetBkColor(color: byte); Ustaw kolor t\u0142a. SetClipRect procedure SetClipRect(x0,y0,x1,y1: smallint); procedure SetClipRect(Rect: TRect); SetColor procedure SetColor(color: byte); Ustaw kolor pisaka. SetColorMapEntry procedure SetColorMapEntry; procedure SetColorMapEntry(a,b,c: byte); SetColorMapDimensions procedure SetColorMapDimensions(w,h: byte); SYSUTILS Constants faReadOnly = $01; faHidden = $02; faSysFile = $04; faVolumeID = $08; faDirectory = $10; faArchive = $20; faAnyFile = $3f; Types TSearchRec TSearchRec = record Attr: Byte; Name: TString; FindHandle: Pointer; end; Procedures and functions AnsiUpperCase Beep Click DeleteFile ExtractFileExt FileExists FindFirst FindNext FindClose GetTickCount IntToHex IntToStr RenameFile StrToFloat StrToInt AnsiUpperCase function AnsiUpperCase(const a: string): string; Funkcja konwertuje znaki z \u0142a\u0144cucha a na wielkie. Beep procedure Beep; Sygna\u0142 brz\u0119czka (buzzer). Click procedure Click; Sygna\u0142 klawiatury. DeleteFile function DeleteFile(var FileName: TString): Boolean; Funkcja kasuje plik okre\u015blony w parametrze FileName , zwraca TRUE gdy operacja si\u0119 powiod\u0142a. ExtractFileExt function ExtractFileExt(const FileName: string): TString; Na podstawie nazwy pliku lub pe\u0142nej \u015bcie\u017cki do pliku okre\u015blonej w parametrze FileName , funkcja zwraca rozszerzenie (poprzedzone kropk\u0105 - np. .txt ). FileExists function FileExists(const FileName: string): Boolean; Funkcja sprawdza czy plik okre\u015blony w parametrze FileName , istnieje True czy te\u017c nie False . FindFirst function FindFirst(const FileMask: TString; Attributes: Byte; var SearchResult: TSearchRec): byte; Funkcja wyszukuje pliki pasuj\u0105ce do wzorca FileMask i posiadaj\u0105ce atrybuty okre\u015blone w Attributes . Je\u015bli zosta\u0142y znalezione pliki pasuj\u0105ce do szablonu to pierwszy z nich jest zwracany w zmiennej SerchResult . FindNext function FindNext(var f: TSearchRec): byte; Funkcja przechodzi do nast\u0119pnego rekordu znalezionego wcze\u015bniej przy pomocy FindFirst . W parametrze musi zosta\u0107 przekazane wskazanie na rekord, kt\u00f3ry wcze\u015bniej zosta\u0142 u\u017cyty w funkcji FindFirst . FindClose procedure FindClose(var f: TSearchRec); Procedura zwalnia zasoby (pami\u0119\u0107) zaalokowan\u0105 przez funkcj\u0119 FindFirst . Procedura ta powinna by\u0107 wywo\u0142ywana za ka\u017cdym razem po zako\u0144czeniu procesu wyszukiwania. GetTickCount function GetTickCount: cardinal; GetTickCount zwraca 24-bitowy licznik czasu (PEEK(RTCLOK+2) + PEEK(RTCLOK+1)*256 + PEEK(RTCLOK)*65536) . Jest to przydatne do pomiaru czasu. IntToHex function IntToHex(Value: cardinal; Digits: byte): TString; Funkcja konwertuje warto\u015b\u0107 liczbow\u0105 na jej odpowiednik \u0142a\u0144cuchowy w systemie szesnastkowym. IntToStr function IntToStr(a: integer): ^char; Funkcja s\u0142u\u017cy do konwersji liczby ca\u0142kowitej podanej w parametrze do postaci \u0142a\u0144cuchowej. RenameFile function RenameFile(var OldName,NewName: TString): Boolean; Funkcja pr\u00f3buje zmieni\u0107 nazw\u0119 pliku okre\u015blonego w parametrze OldName na NewName . Je\u017celi operacja si\u0119 powiedzie, funkcja zwr\u00f3ci warto\u015b\u0107 True w przeciwnym wypadku False . Mo\u017ce si\u0119 zdarzy\u0107, \u017ce funkcja nie b\u0119dzie mog\u0142a zmieni\u0107 nazwy (np. gdy aplikacja nie ma prawa do tego) - w\u00f3wczas funkcja zwr\u00f3ci False . StrToFloat function StrToFloat(var s: TString): real; Funkcja konwertuje \u0142a\u0144cuch do postaci zmiennoprzenkowej typu Real . StrToInt function StrToInt(const S: char): byte; function StrToInt (const S: TString): integer; Funkcja s\u0142u\u017cy do konwersji tekstu zapisanego w zmiennej S na liczb\u0119 ca\u0142kowit\u0105 - o ile to mo\u017cliwe. VBXE Mapa pami\u0119ci dla VBXE zdefiniowana jest w module SYSTEM . VBXE_XDLADR = $0000; // XDLIST VBXE_MAPADR = $1000; // COLOR MAP ADDRESS VBXE_BCBADR = $0100; // BLITTER LIST ADDRESS VBXE_OVRADR = $5000; // OVERLAY ADDRESS VBXE_WINDOW = $B000; // 4K WINDOW $B000..$BFFF Constants LoRes = 1; // 160x240x256c MedRes = 2; // 320x240x256c HiRes = 3; // 640x240x16c Types TUInt24 record byte0: byte; byte1: byte; byte2: byte; end; Typ 24-bitowy wykorzystywany do definicji adres\u00f3w pami\u0119ci VBXE . TXDL record xdlc_: word; rptl_: byte; xdlc: word; rptl: byte; ov_adr: TUInt24; ov_step: word; mp_adr: TUInt24; mp_step: word; mp_hscrol: byte; mp_vscrol: byte; mp_width: byte; mp_height: byte; ov_width: byte; ov_prior: byte; end; Typ TXDL wykorzystywany przez procedury GetXDL i SetXDL . Pozwala na modyfikacj\u0119 programu dla VBXE wykorzystywanego przez Mad-Pascal . TBCB record src_adr: TUInt24; src_step_y: smallint; src_step_x: shortint; dst_adr: TUInt24; dst_step_y: smallint; dst_step_x: shortint; blt_width: word; blt_height: byte; blt_and_mask: byte; blt_xor_mask: byte; blt_collision_mask: byte; blt_zoom: byte; pattern_feature: byte; blt_control: byte; end; Typ TBCB (21 bajt\u00f3w), Blitter Code Block . Definicja typu bloku programu dla Blittera VBXE . TVBXEMemoryStream Object Position: cardinal; Size: cardinal; // 0..Size-1 procedure Create; procedure Clear; procedure SetBank; procedure ReadBuffer(var Buffer; Count: word); procedure WriteBuffer(var Buffer; Count: word); function ReadByte: Byte; function ReadWord: Word; function ReadDWord: Cardinal; procedure WriteByte(b: Byte); procedure WriteWord(w: Word); procedure WriteDWord(d: Cardinal); end; Obiekt TVBXEMemoryStream pozwala na liniowy dost\u0119p do pami\u0119ci VBXE . Procedures and functions BlitterBusy ColorMapOff ColorMapOn DstBCB ExtractFileExt GetXDL IniBCB OverlayOff RunBCB SetHorizontalRes VBXEMemoryBank SetXDL SrcBCB VBXEControl VBXEOff BlitterBusy function BlitterBusy: Boolean; assembler; Funkcja zwraca TRUE je\u015bli blitter VBXE zaj\u0119ty jest wykonywaniem programu blittera. ColorMapOff procedure ColorMapOff; assembler; Wy\u0142\u0105czenie mapy kolor\u00f3w w programie XDLIST dla VBXE . ColorMapOn procedure ColorMapOn; assembler; W\u0142\u0105czenie mapy kolor\u00f3w w programie XDLIST dla VBXE . DstBCB procedure DstBCB(var a: TBCB; dst: cardinal); Procedura zmieniaj\u0105ca adres docelowy dst_adr w programie blittera A . GetXDL procedure GetXDL(var a: txdl); register; assembler; Procedura przepisuje do zmiennej A program XDLIST spod adresu VBXE_XDLADR w pami\u0119ci VBXE . IniBCB procedure IniBCB(var a: TBCB; src,dst: cardinal; w0, w1: smallint; w: word; h: byte; ctrl: byte); Procedura pozwala zaincjowa\u0107 pami\u0119\u0107 dla programu blittera pod adresem A . Dodatkowe parametry okre\u015blaj\u0105 adres spod kt\u00f3rego b\u0119d\u0105 kopiowane dane SRC , adres docelowy kopiowanych danych DST , szeroko\u015b\u0107 okna danych \u017ar\u00f3d\u0142owych W0 , docelowych W1 , rozmiar okna wynikowego, jego szeroko\u015b\u0107 W , wysoko\u015b\u0107 H , oraz okre\u015bli\u0107 parametry ko\u0144cowe bloku programu blittera CTRL (ustawiony bit 3 CTRL nakazuje blitterowi odczyt kolejnego programu i jego wykonanie). OverlayOff procedure OverlayOff; assembler; Wy\u0142\u0105czenie trybu overlay w programie XDLIST . RunBCB procedure RunBCB(var a: TBCB); assembler; Wystartowanie blittera VBXE na podstawie adresu programu A . SetHorizontalRes procedure SetHorizontalRes(a: byte); assembler; procedure SetHRes(a: byte); assembler; Ustanowienie trybu overlay w programie XDLIST . VBXEMemoryBank procedure VBXEMemoryBank(b: byte); assembler; W\u0142\u0105czenie 4K banku VBXE w okno pami\u0119ci XE/XL $B000..$BCFF . SetXDL procedure SetXDL(var a: txdl); register; assembler; Procedura przepisuje program A pod adres VBXE_XDLADR w pami\u0119ci VBXE . SrcBCB procedure SrcBCB(var a: TBCB; src: cardinal); Procedura zmieniaj\u0105ca adres \u017ar\u00f3d\u0142owy src_adr w programie blittera A . VBXEControl procedure VBXEControl(a: byte); assembler; Procedura ustawia warto\u015bc FX_VIDEO_CONTROL . VBXEOff procedure VBXEOff Wy\u0142\u0105czenie, reset VBXE . MATH Procedures and functions ArcCos ArcSin ArcTan2 Ceil CycleToRad DegNormalize DegToGrad DegToRad DivMod EnsureRange Floor FMod GradToDeg GradToRad InRange IsNan Log2 Log10 LogN Max Min Power RadToCycle RadToDeg RadToGrad RandG RandomRange RandomRangeF Tan ArcCos function ArcCos(x: real): real; ArcCos jest funkcj\u0105 odwrotn\u0105 do funkcji Cos . Warto\u015b\u0107 parametru X musi nale\u017ce\u0107 do przedzia\u0142u obustronnie domkni\u0119tego <-1; 1> . Warto\u015bci\u0105 zwracan\u0105 przez funkcj\u0119 jest k\u0105t z przedzia\u0142u <0; ?> wyra\u017cony w mierze \u0142ukowej (radianach). ArcSin function ArcSin(x: real): real; Funkcja s\u0142u\u017cy do obliczenia funkcji matematycznej arcus sinus z liczby X . Jest to funkcja odwrotna do funkcji sinus, tzn. sin(arcsin(x)) = x . ArcTan2 function ArcTan2(y, x: real) : real; Funkcja oblicza arcus tangens (odwrotno\u015b\u0107 tangensa) z liczby Y/X i zwraca warto\u015b\u0107 w radianach. Ceil function Ceil(a: real): smallint; Funkcja zwraca najmniejsz\u0105 liczb\u0119 ca\u0142kowit\u0105 wi\u0119ksz\u0105 lub r\u00f3wn\u0105 od tej podanej w parametrze. CycleToRad function CycleToRad(cycle : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w cyklach (obrotach) na k\u0105t wyra\u017cony w radianach. DegNormalize function DegNormalize(deg : real) : real; DegToGrad function DegToGrad(deg : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w stopniach na k\u0105t wyra\u017cony w gradach. DegToRad function DegToRad(deg : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w stopniach na k\u0105t wyra\u017cony w mierze \u0142ukowej, czyli radianach. DivMod procedure DivMod(Dividend: integer; Divisor: Word; var r, Remainder: Word); procedure DivMod(Dividend: integer; Divisor: Word; var r, Remainder: smallint); EnsureRange function EnsureRange(const AValue, AMin, AMax: byte): Integer; function EnsureRange(const AValue, AMin, AMax: Integer): Integer; Floor function Floor(a: real): smallint; Funkcja zwraca najbli\u017csz\u0105 liczb\u0119 ca\u0142kowit\u0105 mniejsz\u0105 lub r\u00f3wn\u0105 od tej podanej w parametrze. FMod function FMod(a, b: real): real; Funkcja zwraca reszt\u0119 z dzielenia dw\u00f3ch liczb rzeczywistych. GradToDeg function GradToDeg(grad : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w gradach na k\u0105t wyra\u017cony w stopniach. GradToRad function GradToRad(grad : real) : real; Funkcja GradToRad przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w gradach na k\u0105t wyra\u017cony w radianach. InRange function InRange(const AValue, AMin, AMax: byte): Boolean; function InRange(const AValue, AMin, AMax: Integer): Boolean; IsNan function IsNan(const d : Single): Boolean; Funkcja sprawdza czy warto\u015b\u0107 parametru d jest poprawn\u0105 liczb\u0105. Log2 function log2(x : single): single; Funkcja zwraca warto\u015b\u0107 logarytmu przy podstawie 2 dla parametru rzeczywistego X>0. Log10 function log10(x : single): single; Funkcja zwraca warto\u015b\u0107 logarytmu dziesi\u0119tnego (logarytmu przy podstawie 10) dla parametru rzeczywistego X>0. LogN function logN(n,x : single): single; Funkcja zwraca warto\u015b\u0107 logarytmu przy podstawie N>0 dla parametru rzeczywistego X>0. Max function Max(a, b: real): real; function Max(a, b: integer): integer; Przeci\u0105\u017cona funkcja por\u00f3wnuje warto\u015bci dw\u00f3ch parametr\u00f3w: a i b , oraz zwraca ten, kt\u00f3ry jest wi\u0119kszy. Min function Min(a, b: real): real; function Min(a, b: integer): integer; Przeci\u0105\u017cona funkcja por\u00f3wnuje warto\u015bci dw\u00f3ch parametr\u00f3w a i b , oraz zwraca warto\u015b\u0107 tego kt\u00f3ry jest mniejszy. Power function Power(base : real; const exponent : shortint): real; power(base : integer; const exponent : shortint): integer; Funkcja podnosi liczb\u0119 A do dowolnej pot\u0119gi N, pot\u0119ga mo\u017ce by\u0107 u\u0142amkiem. RadToCycle function RadToCycle(rad : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w radianach na k\u0105t wyra\u017cony w cyklach (obrotach). RadToDeg function RadToDeg(rad : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w radianach na k\u0105t wyra\u017cony w stopniach (deg). RadToGrad function RadToGrad(rad : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w radianach na k\u0105t wyra\u017cony w gradach. RandG function RandG(mean, StdDev : single) : single; RandG reprezentuje generator liczb pseudolosowych o rozk\u0142adzie Gaussa wok\u00f3\u0142 \u015bredniej mean . Parametr StdDev jest odchyleniem standardowym generowanych liczb od warto\u015bci \u015bredniej mean . RandomRange function RandomRange(const aFrom, aTo: smallint): smallint; Funkcja zwraca losow\u0105 liczb\u0119 z przedzia\u0142u AFrom - ATo , \u0142\u0105cznie z warto\u015bci\u0105 ATo . RandomRangeF function RandomRangeF(const min, max: single): single; Tan function Tan(x: Real): Real; Funkcja zwraca warto\u015b\u0107 tangensa k\u0105ta podanego w parametrze x .","title":"Biblioteki podstawowe"},{"location":"biblioteki-podstawowe/#_1","text":"W katalogu LIB Mad-Pascala znajduj\u0105 si\u0119 potrzebne do kompilacji podstawowe modu\u0142y UNIT , takie jak SYSTEM CRT GRAPH SYSUTILS MATH DOS . Modu\u0142 SYSTEM jest kompilowany zawsze domy\u015blnie jako pierwszy.","title":""},{"location":"biblioteki-podstawowe/#system","text":"","title":"SYSTEM"},{"location":"biblioteki-podstawowe/#constants","text":"M_PI_2 = 6.283285; // pi * 2 D_PI_2 = 1.570796; // pi / 2 D_PI_180 = 0.017453; // pi / 180 mGTIA = 0; mVBXE = $80; WINDOW = $10; NARROW = $20; VBXE_XDLADR = $0000; // XDLIST VBXE_MAPADR = $1000; // COLOR MAP ADDRESS VBXE_BCBADR = $0100; // BLITTER LIST ADDRESS VBXE_OVRADR = $5000; // OVERLAY ADDRESS VBXE_WINDOW = $B000; // 4K WINDOW $B000..$BFFF iDLI = 0; iVBL = 1; CH_DELCHR = $FE; CH_ENTER = $9B; CH_ESC = $1B; CH_CURS_UP = 28; CH_CURS_DOWN = 29; CH_CURS_LEFT = 30; CH_CURS_RIGHT = 31; CH_TAB = $7F; CH_EOL = $9B; CH_CLR = $7D; CH_BEL = $FD; CH_DEL = $7E; CH_DELLINE = $9C; CH_INSLINE = $9D; COLOR_BLACK = $00; COLOR_WHITE = $0e; COLOR_RED = $32; COLOR_CYAN = $96; COLOR_VIOLET = $68; COLOR_GREEN = $c4; COLOR_BLUE = $74; COLOR_YELLOW = $ee; COLOR_ORANGE = $4a; COLOR_BROWN = $e4; COLOR_LIGHTRED = $3c; COLOR_GRAY1 = $04; COLOR_GRAY2 = $06; COLOR_GRAY3 = $0a; COLOR_LIGHTGREEN = $cc; COLOR_LIGHTBLUE = $7c;","title":"Constants"},{"location":"biblioteki-podstawowe/#types","text":"","title":"Types"},{"location":"biblioteki-podstawowe/#tpoint","text":"TPoint = record x,y: SmallInt end; Definicja wsp\u00f3\u0142rz\u0119dnych (x,y).","title":"TPoint"},{"location":"biblioteki-podstawowe/#trect","text":"TRect = record left, top, right, bottom: smallint end; Definicja po\u0142o\u017cenia i rozmiaru czworok\u0105ta o parametrach (left, top) - lewy g\u00f3rny naro\u017cnik, (right, bottom) - prawy dolny naro\u017cnik.","title":"TRect"},{"location":"biblioteki-podstawowe/#tstring","text":"TString = string[32]; Definicja kr\u00f3tkiego ci\u0105gu znakowego wykorzystywanego do przekazywania nazw plik\u00f3w itp.","title":"TString"},{"location":"biblioteki-podstawowe/#variables","text":"","title":"Variables"},{"location":"biblioteki-podstawowe/#ioresult","text":"IOResult: byte; Zmienna przechowuje ostatni b\u0142\u0105d operacji I/O . Kody b\u0142\u0119d\u00f3w I/O . Dla PC brak b\u0142\u0119d\u00f3w I/O oznacza IORresult = 0 , dla Atari XE/XL IOResult = 1 .","title":"IOResult"},{"location":"biblioteki-podstawowe/#screenwidth","text":"ScreenWidth: word = 40 Zmienna przechowuj\u0105ca aktualn\u0105 szeroko\u015b\u0107 ekranu. Domy\u015blnie jest to warto\u015b\u0107 40 dla ekranu edytora. ScreenHeight: word = 24;","title":"ScreenWidth"},{"location":"biblioteki-podstawowe/#screenheight","text":"Zmienna przechowuj\u0105\u0107a aktualn\u0105 wysoko\u015b\u0107 ekranu. Domy\u015blnie jest to warto\u015b\u0107 24 dla ekranu edytora.","title":"ScreenHeight"},{"location":"biblioteki-podstawowe/#procedures-and-functions","text":"Abs Append ArcTan Assign BinStr Concat Blockread Blockwrite Chr Cos Close Dec DeleteFile DPeek DPoke Eof Exit Exp FilePos FileSize FillChar Frac GetIntVec Halt Hi HexStr Inc Ln Lo LowerCase Move OctStr Odd Ord ParamCount ParamStr Pause Peek Point PointsEqual Poke Pred Random ReadConfig ReadSecto Rect RenameFile Reset Rewrite Round Seek SetLength SetIntVec Sin Succ Space SizeOf Str StringOfChar Sqr Sqrt Trunc UpCase Val WriteSector","title":"Procedures and functions"},{"location":"biblioteki-podstawowe/#abs","text":"function Abs(x: real): real; function Abs(x: integer): integer; Funkcja obliczaj\u0105ca warto\u015b\u0107 bezwzgl\u0119dn\u0105 podanej liczby (ang. Absolute value ). Warto\u015b\u0107 bezwzgl\u0119dna liczby nieujemnej to ta sama liczba, a liczby ujemnej - liczba do niej przeciwna. Funkcja w przypadku podania jej argumentu ca\u0142kowitego zwraca wynik r\u00f3wnie\u017c typu ca\u0142kowitego.","title":"Abs"},{"location":"biblioteki-podstawowe/#append","text":"Append(var F: text) Otwiera istniej\u0105cy zbi\u00f3r tekstowy w trybie dopisywania (wska\u017anik zbioru jest ustawiany na ko\u0144cu zbioru). F jest tekstow\u0105 zmienn\u0105 plikow\u0105, kt\u00f3ra musi by\u0107 skojarzona z istniej\u0105cym zbiorem dyskowym (przy u\u017cyciu procedury Assign ).","title":"Append"},{"location":"biblioteki-podstawowe/#arctan","text":"function ArcTan(x: real): real; Funkcja (arcus tangens) zwraca warto\u015b\u0107 k\u0105ta, kt\u00f3rego tangens wynosi x .","title":"ArcTan"},{"location":"biblioteki-podstawowe/#assign","text":"procedure Assign(var F:File; FileName:string) Procedura przypisuje zmiennej plikowej F plik o nazwie FileName . Aby m\u00f3c odwo\u0142ywa\u0107 si\u0119 do jakiego\u015b pliku, zawsze nale\u017cy najpierw u\u017cy\u0107 procedury Assign . Przy dalszych operacjach pliki s\u0105 identyfikowane przy pomocy zmiennej plikowej, a nie nazwy.","title":"Assign"},{"location":"biblioteki-podstawowe/#binstr","text":"function BinStr(Value: cardinal; Digits: byte): TString; Funkcja zwraca ci\u0105g znakowy z reprezentacj\u0105 binarn\u0105 warto\u015bci Value . Digits okre\u015bla d\u0142ugo\u015b\u0107 ci\u0105gu, kt\u00f3ry maksymalnie mo\u017ce liczy\u0107 32 znaki.","title":"BinStr"},{"location":"biblioteki-podstawowe/#concat","text":"function Concat(a,b: string): string; assembler function Concat(a: string; b: char): string; assembler; function Concat(a: char; b: string): string; assembler; function Concat(a,b: char): string; Funkcja \u0142\u0105czy dwa ci\u0105gi tekstowe w nowy ci\u0105g znakowy.","title":"Concat"},{"location":"biblioteki-podstawowe/#blockread","text":"procedure BlockRead(var f: file; var Buf; Count: word; var Result: word); Procedura wczytuje z pliku plik do zmiennej Buf nie wi\u0119cej ni\u017c Count bajt\u00f3w i umieszcza w zmiennej Result ilo\u015b\u0107 rzeczywi\u015bcie przeczytanych bajt\u00f3w (kt\u00f3ra mo\u017ce by\u0107 mniejsza od oczekiwanej np. ze wzgl\u0119du na rzeczywist\u0105 d\u0142ugo\u015b\u0107 pliku).","title":"Blockread"},{"location":"biblioteki-podstawowe/#blockwrite","text":"procedure BlockWrite(var f: file; var Buf; Count: word; var Result: word); Procedura zapisuje do pliku ze zmiennej Buf nie wi\u0119cej ni\u017c Count bajt\u00f3w.","title":"Blockwrite"},{"location":"biblioteki-podstawowe/#chr","text":"Chr(65); // Zwraca znak A Chr(90); // Zwraca znak Z Chr(32); // Zwraca znak spacji Writeln(#65); // Znak A Writeln(#65#32#65); // Napisze 'A Z' Funkcja zwraca znak Char o odpowiadaj\u0105cym kodzie ATASCII podanym w parametrze. Zamiennie z funkcj\u0105 Chr , chc\u0105c uzyska\u0107 odpowiedni znak mo\u017cemy u\u017cy\u0107 jego kodu ATASCII poprzedzaj\u0105c go # .","title":"Chr"},{"location":"biblioteki-podstawowe/#cos","text":"function Cos(x: real): real; Cosinus k\u0105ta, x w radianach.","title":"Cos"},{"location":"biblioteki-podstawowe/#close","text":"procedure Close(var f: file); Procedura s\u0142u\u017c\u0105ca do zamykania otwartego pliku dowolnego typu. Ka\u017cdy plik otwarty przy pomocy Reset lub Rewrite powinno si\u0119 zamkn\u0105\u0107 przy pomocy Close .","title":"Close"},{"location":"biblioteki-podstawowe/#dec","text":"procedure Dec(var X [, N: int]); Procedura zmniejsza warto\u015b\u0107 parametru X o 1 lub warto\u015b\u0107 parametru N . Warto\u015b\u0107 parametru X mo\u017ce by\u0107 typu CHAR BYTE WORD CARDINAL . Procedura DEC generuje optymalny kod, jest zalecana do u\u017cywania w p\u0119tlach, zamiast operatora odejmowania - . dec(tmp); dec(tmp[2]);","title":"Dec"},{"location":"biblioteki-podstawowe/#deletefile","text":"function DeleteFile(FileName: string): Boolean; Funkcja pozwala skasowa\u0107 plik z dysku o nazwie FileName , zwraca TRUE kiedy operacja powiod\u0142a si\u0119, FALSE w przypadku wyst\u0105pienia b\u0142\u0119du (najcz\u0119\u015bciej z powodu zabezpieczenia przed zapisem lub b\u0142\u0119dnej nazwy pliku).","title":"DeleteFile"},{"location":"biblioteki-podstawowe/#dpeek","text":"function DPeek(a: word): word; Funkcja zwraca s\u0142owo spod adresu a .","title":"DPeek"},{"location":"biblioteki-podstawowe/#dpoke","text":"procedure DPoke(a: word; value: word); Procedura zapisuje s\u0142owo value pod adresem a .","title":"DPoke"},{"location":"biblioteki-podstawowe/#eof","text":"function Eof(var f: file): Boolean; Funkcja zwraca warto\u015b\u0107 logiczn\u0105 TRUE je\u015bli osi\u0105gni\u0119ty zosta\u0142 koniec pliku.","title":"Eof"},{"location":"biblioteki-podstawowe/#exit","text":"Wywo\u0142anie procedury Exit powoduje natychmiastowe opuszczenie bloku programu, w kt\u00f3rym to wywo\u0142anie nast\u0105pi\u0142o. Mo\u017cna jej u\u017cy\u0107 do opuszczenia p\u0119tli, wyj\u015bcia z procedury/funkcji lub programu g\u0142\u00f3wnego.","title":"Exit"},{"location":"biblioteki-podstawowe/#exp","text":"function Exp(x: real): real; Funkcja podnosz\u0105ca liczb\u0119 e (=2.71) do pot\u0119gi podanej przez argument x .","title":"Exp"},{"location":"biblioteki-podstawowe/#filepos","text":"function FilePos(var f: file): cardinal; Funkcja zwraca aktualn\u0105 pozycj\u0119 pliku. Plik nie mo\u017ce by\u0107 tekstowy i musi by\u0107 otwarty (np. poleceniem Reset ). Bity 0..15 zwr\u00f3conej warto\u015bci to numer sektora dysku, bity 16..23 pozycja w sektorze [0..255] . Jest to odpowiednik instrukcji NOTE .","title":"FilePos"},{"location":"biblioteki-podstawowe/#filesize","text":"function FileSize(var f: file): cardinal; Funkcja zwraca d\u0142ugo\u015b\u0107 pliku w bajtach ( Sparta DOS X ). Plik nie mo\u017ce by\u0107 tekstowy i musi by\u0107 otwarty (np. poleceniem Reset ).","title":"FileSize"},{"location":"biblioteki-podstawowe/#fillchar","text":"procedure FillChar(x: pointer; count: word; value: char); Procedura wype\u0142nia bufor okre\u015blony w parametrze X identycznymi znakami lub bajtami. Parametr value musi okre\u015bla\u0107 dane, natomiast count - ilo\u015b\u0107 danych jakie zostan\u0105 przypisane do bufora. var Buffer : array[0..100] of Char; begin FillChar(Buffer, SizeOf(Buffer), 'A'); end.","title":"FillChar"},{"location":"biblioteki-podstawowe/#frac","text":"function Frac(x: real): real; Zwraca cz\u0119\u015b\u0107 u\u0142amkow\u0105 liczby x w postaci rzeczywistej.","title":"Frac"},{"location":"biblioteki-podstawowe/#getintvec","text":"procedure GetIntVec(intno: byte; var vector: pointer); Procedura odczytuje adres wektora przerwa\u0144 wg. kodu INTNO . Obecnie dopuszczalnymi kodami s\u0105: iDLI przerwanie DLI, iVBL przerwanie VBL.","title":"GetIntVec"},{"location":"biblioteki-podstawowe/#halt","text":"procedure halt; Wywo\u0142anie powoduje natychmiastowe wyj\u015bcie z programu. Mo\u017cna (opcjonalnie) poda\u0107 kod b\u0142\u0119du, w przypadku Mad-Pascal jest on ignorowany.","title":"Halt"},{"location":"biblioteki-podstawowe/#hi","text":"function Hi(x): byte Funkcja zwracaj\u0105ca starszy bajt parametru x .","title":"Hi"},{"location":"biblioteki-podstawowe/#hexstr","text":"function HexStr(Value: cardinal; Digits: byte): TString; Funkcja zwraca ci\u0105g znakowy z reprezentacj\u0105 heksadecymaln\u0105 warto\u015bci Value . Digits okre\u015bla d\u0142ugo\u015b\u0107 ci\u0105gu, kt\u00f3ry maksymalnie mo\u017ce liczy\u0107 32 znaki.","title":"HexStr"},{"location":"biblioteki-podstawowe/#inc","text":"Inc procedure Inc(var X [, N: int]); Procedura zwi\u0119ksza warto\u015b\u0107 parametru X o 1 lub warto\u015b\u0107 parametru N . Warto\u015b\u0107 parametru X mo\u017ce by\u0107 typu CHAR BYTE WORD CARDINAL . Procedura INC generuje optymalny kod, jest zalecana do u\u017cywania w p\u0119tlach, zamiast operatora dodawania + . inc(tmp); inc(tmp[2]);","title":"Inc"},{"location":"biblioteki-podstawowe/#int","text":"function Int(x: real): real; Funkcja zwraca cz\u0119\u015b\u0107 ca\u0142kowit\u0105 argumentu b\u0119d\u0105cego liczb\u0105 rzeczywist\u0105.","title":"Int"},{"location":"biblioteki-podstawowe/#ln","text":"function Ln(x: real): real; Funkcja licz\u0105ca logarytm naturalny (o podstawie e) z podanej liczby. Argument funkcji musi by\u0107 dodatni !","title":"Ln"},{"location":"biblioteki-podstawowe/#lo","text":"function Lo(x): byte; Funkcja zwracaj\u0105ca m\u0142odszy bajt parametru X .","title":"Lo"},{"location":"biblioteki-podstawowe/#lowercase","text":"function LowerCase(a: char): char; Funkcja zmieniaj\u0105ca znaki 'A'..'Z' na odpowiednie ma\u0142e znaki 'a'..'z'.","title":"LowerCase"},{"location":"biblioteki-podstawowe/#move","text":"procedure Move(source, dest: pointer; count: word); Procedura s\u0142u\u017cy do kopiowania danych ze \u017ar\u00f3d\u0142a, parametr Source , do bufora oznaczonego jako przeznaczenie, parametr Dest . Ilo\u015b\u0107 kopiowanych danych okre\u015bla parametr Count .","title":"Move"},{"location":"biblioteki-podstawowe/#octstr","text":"function OctStr(Value: cardinal; Digits: byte): TString; Funkcja zwraca ci\u0105g znakowy z reprezentacj\u0105 \u00f3semkow\u0105 warto\u015bci Value . Digits okre\u015bla d\u0142ugo\u015b\u0107 ci\u0105gu, kt\u00f3ry maksymalnie mo\u017ce liczy\u0107 32 znaki.","title":"OctStr"},{"location":"biblioteki-podstawowe/#odd","text":"function Odd(x: cardinal): Boolean; function Odd(x: integer): Boolean; Funkcja zwraca warto\u015b\u0107 True je\u017celi liczba okre\u015blona w parametrze X jest nieparzysta, False je\u017celi jest parzysta.","title":"Odd"},{"location":"biblioteki-podstawowe/#ord","text":"function Ord(X); Funkcja ta dzia\u0142a odwrotnie do Chr . Z podanego znaku jako parametr zwraca nam jego kod w ATASCII . Ord('A'); // Zwraca 65 Ord('Z'); // Zwraca 90 Ord(' '); // Zwraca 32","title":"Ord"},{"location":"biblioteki-podstawowe/#paramcount","text":"function ParamCount: byte; Funkcja zwraca ilo\u015b\u0107 dost\u0119pnych argument\u00f3w ( Sparta Dos X , BWDos ), tzn. maksymalny indeks dla procedury ParamStr . ParamCount okre\u015bla ilo\u015b\u0107 parametr\u00f3w przekazanych do programu z linii polece\u0144.","title":"ParamCount"},{"location":"biblioteki-podstawowe/#paramstr","text":"function ParamStr(Index: byte): TString; Funkcja zwraca parametry programu ( Sparta Dos X , BWDos ). Index to numer parametru, czyli ci\u0105gu znak\u00f3w oddzielonego spacj\u0105. Je\u017celi uruchomimy program TEST.EXE w taki spos\u00f3b: TEST.EXE parametr1 parametr2 parametr3 To aby uzyska\u0107 parametr3 nale\u017cy poda\u0107 Index=3 , za\u015b aby uzyska\u0107 parametr1 nale\u017cy Index=1 . Index=0 to specjalny argument, wtedy funkcja zwraca nap\u0119d z kt\u00f3rego zosta\u0142 uruchomiony programu, np. D1: .","title":"ParamStr"},{"location":"biblioteki-podstawowe/#pause","text":"procedure Pause; procedure Pause(n: word); Procedura zatrzymuje dzia\u0142anie programu na N * 1.50 sek.","title":"Pause"},{"location":"biblioteki-podstawowe/#peek","text":"function Peek(a: word): byte; Funkcja zwraca bajt spod adresu a .","title":"Peek"},{"location":"biblioteki-podstawowe/#point","text":"function Point(AX, AY: smallint): TPoint; Funkcja na podstawie parametr\u00f3w AX oraz AY tworzony jest rekord typu TPoint .","title":"Point"},{"location":"biblioteki-podstawowe/#pointsequal","text":"function PointsEqual(const P1, P2: TPoint): Boolean; Funkcja sprawdza czy warto\u015bci wsp\u00f3\u0142rz\u0119dnych okre\u015blone w parametrach P1 oraz P2 s\u0105 sobie r\u00f3wne. W takim wypadku funkcja zwraca warto\u015b\u0107 True .","title":"PointsEqual"},{"location":"biblioteki-podstawowe/#poke","text":"procedure Poke(a: word; value: byte); Procedura zapisuje bajt value pod adresem a .","title":"Poke"},{"location":"biblioteki-podstawowe/#pred","text":"function Pred(X: TOrdinal): TOrdinal; Poprzednik elementu X .","title":"Pred"},{"location":"biblioteki-podstawowe/#random","text":"function Random: Real; assembler; Funkcja zwraca losow\u0105 warto\u015b\u0107 z przedzia\u0142u <0 .. 1> . function Random(range: byte): byte; assembler; Funkcja zwraca losow\u0105 warto\u015b\u0107 z przedzia\u0142u <0 .. range-1> , w przypadku Range=0 zwraca warto\u015b\u0107 losow\u0105 z przedzia\u0142u <0 .. 255 > . function Random(range: smallint): smallint; Funkcja zwraca losow\u0105 warto\u015b\u0107 z przedzia\u0142u <0 .. range-1> .","title":"Random"},{"location":"biblioteki-podstawowe/#readconfig","text":"function ReadConfig(devnum: byte): cardinal; Odczyt statusu stacji devnum . Wynikiem s\u0105 cztery bajty DVSTAT ($02EA..$02ED) . Byte 0 ($02ea): Bit 0:Indicates the last command frame had an error. Bit 1:Checksum, indicates that there was a checksum error in the last command or data frame Bit 2:Indicates that the last operation by the drive was in error. Bit 3:Indicates a write protected diskette. 1=Write protect Bit 4:Indicates the drive motor is on. 1=motor on Bit 5:A one indicates MFM format (double density) Bit 6:Not used Bit 7:Indicates Density and a Half if 1 Byte 1 ($02eb): Bit 0:FDC Busy should always be a 1 Bit 1:FDC Data Request should always be 1 Bit 2:FDC Lost data should always be 1 Bit 3:FDC CRC error, a 0 indicates the last sector read had a CRC error Bit 4:FDC Record not found, a 0 indicates last sector not found Bit 5:FDC record type, a 0 indicates deleted data mark Bit 6:FDC write protect, indicates write protected disk Bit 7:FDC door is open, 0 indicates door is open Byte 2 ($2ec): Timeout value for doing a format. Byte 3 ($2ed): not used, should be zero","title":"ReadConfig"},{"location":"biblioteki-podstawowe/#readsector","text":"procedure ReadSector(devnum: byte; sector: word; var buf); Procedura odczytuje sektora sector dyskietki w stacji dysk\u00f3w devnum i zapisanie go w buforze buf .","title":"ReadSector"},{"location":"biblioteki-podstawowe/#rect","text":"function Rect(ALeft, ATop, ARight, ABottom: smallint): TRect; Funckja na podstawie parametr\u00f3w tworzy rekord typu TRect .","title":"Rect"},{"location":"biblioteki-podstawowe/#renamefile","text":"function RenameFile(OldName, NewName: string): Boolean; Funkcja pozwala zmieni\u0107 nazw\u0119 pliku OldName na now\u0105 nazw\u0119 NewName , zwraca TRUE kiedy operacja powiod\u0142a si\u0119, FALSE w przypadku wyst\u0105pienia b\u0142\u0119du (najcz\u0119\u015bciej z powodu zabezpieczenia przed zapisem lub b\u0142\u0119dnej nazwy pliku). RenameFile('D:OLDNAME.TMP', 'NEWNAME.TMP');","title":"RenameFile"},{"location":"biblioteki-podstawowe/#reset","text":"procedure Reset(var f: file; l: Word); Procedura otwiera istniej\u0105cy plik z nazw\u0105 przekazan\u0105 do F poleceniem Assign . Opcjonalnie mo\u017cemy poda\u0107 rozmiar rekordu w bajtach L , domy\u015blnie jest to warto\u015b\u0107 128.","title":"Reset"},{"location":"biblioteki-podstawowe/#rewrite","text":"procedure Rewrite(var f: file; l: Word); Procedura tworzy i otwiera nowy plik. f jest nazw\u0105 przekazan\u0105 za pomoc\u0105 polecenia Assign . Opcjonalnie mo\u017cemy poda\u0107 rozmiar rekordu w bajtach l , domy\u015blnie jest to warto\u015b\u0107 128.","title":"Rewrite"},{"location":"biblioteki-podstawowe/#round","text":"function Round(x: real): integer; Funkcja dokonuje zaokr\u0105glenia podanej liczby rzeczywistej do najbli\u017cszej liczby ca\u0142kowitej.","title":"Round"},{"location":"biblioteki-podstawowe/#seek","text":"procedure Seek(var f: file; N: cardinal); Procedura ustawia pozycj\u0119 w pliku na N . N powinno by\u0107 warto\u015bci\u0105 zwr\u00f3con\u0105 przez FilePos . Jest to odpowiednik instrukcji POINT .","title":"Seek"},{"location":"biblioteki-podstawowe/#setlength","text":"procedure SetLength(var S: string; Len: byte); Procedura ustawia d\u0142ugo\u015b\u0107 ci\u0105gu S na LEN .","title":"SetLength"},{"location":"biblioteki-podstawowe/#setintvec","text":"procedure SetIntVec(intno: Byte; vector: pointer); Procedura ustawia adres wektora przerwa\u0144 wg. kodu INTNO . Obecnie dopuszczalnymi kodami s\u0105: iDLI przerwanie DLI, iVBL przerwanie VBL.","title":"SetIntVec"},{"location":"biblioteki-podstawowe/#sin","text":"function Sin(x: real): real; Sinus k\u0105ta. x w radianach.","title":"Sin"},{"location":"biblioteki-podstawowe/#succ","text":"function Succ(X: TOrdinal): TOrdinal; Nast\u0119pnik elementu X .","title":"Succ"},{"location":"biblioteki-podstawowe/#space","text":"function Space(Len: Byte): ^char; Funkcja generuje nowy ci\u0105g znakowy o d\u0142ugo\u015bci Len wype\u0142niony znakami spacji.","title":"Space"},{"location":"biblioteki-podstawowe/#sizeof","text":"function SizeOf(X: AnyType): byte; Funkcja zwraca rozmiar podanej zmiennej (lub typu) w bajtach.","title":"SizeOf"},{"location":"biblioteki-podstawowe/#str","text":"procedure Str(var X: TNumericType; var S: string); Procedura zamienia liczb\u0119 X na \u0142a\u0144cuch znak\u00f3w S .","title":"Str"},{"location":"biblioteki-podstawowe/#stringofchar","text":"procedure StringOfChar(ch: Char; len: byte): ^char; Funkcja generuje nowy ci\u0105g znakowy o d\u0142ugo\u015bci len wype\u0142niony znakami ch .","title":"StringOfChar"},{"location":"biblioteki-podstawowe/#sqr","text":"function Sqr(x: real): real; function Sqr(x: integer): integer; Funkcja obliczaj\u0105ca kwadrat podanej liczby (ang. Square ).","title":"Sqr"},{"location":"biblioteki-podstawowe/#sqrt","text":"function Sqrt(x: real): real; function Sqrt(x: single): single; function Sqrt(x: integer): single; Funkcja obliczaj\u0105ca pierwiastek kwadratowy podanej liczby (ang. Square root ).","title":"Sqrt"},{"location":"biblioteki-podstawowe/#trunc","text":"function Trunc(x: real): integer; Funkcja zwraca cz\u0119\u015b\u0107 ca\u0142kowit\u0105 liczby rzeczywistej w postaci liczby ca\u0142kowitej.","title":"Trunc"},{"location":"biblioteki-podstawowe/#upcase","text":"function UpCase(a: char): char; Funkcja zmieniaj\u0105ca znaki 'a'..'z' na odpowiednie du\u017ce znaki 'A'..'Z' .","title":"UpCase"},{"location":"biblioteki-podstawowe/#val","text":"procedure Val(const S: string; var V; var Code: Byte); Procedura przekszta\u0142ca ci\u0105g znak\u00f3w S na liczb\u0119 V . Code przyjmie warto\u015b\u0107 0 je\u015bli nie by\u0142o b\u0142\u0119dnych znak\u00f3w, w przeciwnym wypadku przyjmie numer znaku kt\u00f3ry spowodowa\u0142 b\u0142\u0105d konwersji.","title":"Val"},{"location":"biblioteki-podstawowe/#writesector","text":"procedure WriteSector(devnum: byte; sector: word; var buf); Procedura zapisuje sektora sector dyskietki w stacji devnum na podstawie bufora buf .","title":"WriteSector"},{"location":"biblioteki-podstawowe/#crt","text":"","title":"CRT"},{"location":"biblioteki-podstawowe/#constants_1","text":"CN_START_SELECT_OPTION = 0; CN_SELECT_OPTION = 1; CN_START_OPTION = 2; CN_OPTION = 3; CN_START_SELECT = 4; CN_SELECT = 5; CN_START = 6; CN_NONE = 7;","title":"Constants"},{"location":"biblioteki-podstawowe/#variables_1","text":"","title":"Variables"},{"location":"biblioteki-podstawowe/#consol","text":"Consol: byte absolute $d01f Zmienna zwraca kod naci\u015bni\u0119tego klawisza/klawiszy konsoli.","title":"Consol"},{"location":"biblioteki-podstawowe/#textattr","text":"TextAttr: byte = 0 Zmienna przechowuje warto\u015b\u0107 jaka jest dodawana do ka\u017cdego wy\u015bwietlanego znaku, np. TextAttr = $80 spowoduje \u017ce znaki b\u0119d\u0105 wy\u015bwietlane w inwersie.","title":"TextAttr"},{"location":"biblioteki-podstawowe/#wherex","text":"WhereX: byte absolute $54; Zmienna przechowuje aktualn\u0105 poziom\u0105 pozycj\u0119 kursora.","title":"WhereX"},{"location":"biblioteki-podstawowe/#wherey","text":"WhereY: byte absolute $55; Zmienna przechowuje aktualn\u0105 pionow\u0105 pozycj\u0119 kursora.","title":"WhereY"},{"location":"biblioteki-podstawowe/#procedures-and-functions_1","text":"ClrEol ClrScr CursorOff CursorOn Delay DelLine GotoXY InsLine Keypressed NoSound ReadKey Sound TextBackground TextColor","title":"Procedures and functions"},{"location":"biblioteki-podstawowe/#clreol","text":"procedure ClrEol; Procedura czy\u015bci wiersz od aktualnej pozycji kursora do prawej strony kraw\u0119dzi ekranu. Pozycja kursora nie ulega zmianie.","title":"ClrEol"},{"location":"biblioteki-podstawowe/#clrscr","text":"procedure ClrScr; Procedura czy\u015bci ekran edytora, wykonuje kod znaku CH_CLR .","title":"ClrScr"},{"location":"biblioteki-podstawowe/#cursoroff","text":"procedure CursorOff; Procedura wy\u0142\u0105cza kursor.","title":"CursorOff"},{"location":"biblioteki-podstawowe/#cursoron","text":"procedure CursorOn; Procedura w\u0142\u0105cza kursor.","title":"CursorOn"},{"location":"biblioteki-podstawowe/#delay","text":"procedure Delay(MS: Word); Procedura czeka zadan\u0105 ilo\u015b\u0107 milisekund MS . W przybli\u017ceniu Delay(1000) generuje op\u00f3\u017anienie jednej sekundy.","title":"Delay"},{"location":"biblioteki-podstawowe/#delline","text":"procedure DelLine; Procedura kasuje wiersz na aktualnej pozycji kursora, wykonuje kod znaku CH_DELLINE .","title":"DelLine"},{"location":"biblioteki-podstawowe/#gotoxy","text":"procedure GotoXY(x, y: byte); Procedura ustawia now\u0105 pozycj\u0119 kursora.","title":"GotoXY"},{"location":"biblioteki-podstawowe/#insline","text":"procedure InsLine; Procedura wstawia pusty wiersz na aktualnej pozycji kursora, wykonuje kod znaku CH_INSLINE .","title":"InsLine"},{"location":"biblioteki-podstawowe/#keypressed","text":"function Keypressed: Boolean; Funkcja zwraca TRUE gdy zosta\u0142 naci\u015bni\u0119ty jaki\u015b klawisz klawiatury, w przeciwnym razie zwraca FALSE .","title":"Keypressed"},{"location":"biblioteki-podstawowe/#nosound","text":"procedure NoSound; Procedura wycisza kana\u0142y obu POKEY-i $D200 $D210) .","title":"NoSound"},{"location":"biblioteki-podstawowe/#readkey","text":"function ReadKey: char; Funkcja zwraca kod naci\u015bni\u0119tego klawisza klawiatury.","title":"ReadKey"},{"location":"biblioteki-podstawowe/#sound","text":"procedure Sound(Chan,Freq,Dist,Vol: byte); Procedura odtwarza d\u017awi\u0119k na kanale POKEY-a CHAN (0..3, 4..7) , o cz\u0119stotliwo\u015bci FREQ (0..255) , filtrach DIST (0..7) , g\u0142o\u015bno\u015bci VOL (0..15) .","title":"Sound"},{"location":"biblioteki-podstawowe/#textbackground","text":"procedure TextBackground(a: byte); Procedura ustawia nowy kolor t\u0142a znak\u00f3w (dzia\u0142a najlepiej z w\u0142\u0105czonym VBXE ).","title":"TextBackground"},{"location":"biblioteki-podstawowe/#textcolor","text":"procedure TextColor(a: byte); Procedura ustawia nowy kolor znak\u00f3w (dzia\u0142a najlepiej z w\u0142\u0105czonym VBXE ).","title":"TextColor"},{"location":"biblioteki-podstawowe/#graph","text":"","title":"GRAPH"},{"location":"biblioteki-podstawowe/#constants_2","text":"{ graphic drivers } D1bit = 11; D2bit = 12; D4bit = 13; D6bit = 14; // 64 colors Half-brite mode - Amiga D8bit = 15; D12bit = 16; // 4096 color modes HAM mode - Amiga m640x480 = 8 + 16; { error codes } grOK = 0; grNoInitGraph = -1; grNotDetected = -2; grFileNotFound = -3; grInvalidDriver = -4; grNoLoadMem = -5; grNoScanMem = -6; grNoFloodMem = -7; grFontNotFound = -8; grNoFontMem = -9; grInvalidMode = -10; grError = -11; grIOerror = -12; grInvalidFont = -13; grInvalidFontNum = -14; grInvalidVersion = -18;","title":"Constants"},{"location":"biblioteki-podstawowe/#variables_2","text":"","title":"Variables"},{"location":"biblioteki-podstawowe/#graphresult","text":"GraphResult : byte","title":"GraphResult"},{"location":"biblioteki-podstawowe/#procedures-and-functions_2","text":"Bar Bar3D Circle ClipLine Ellipse FillEllipse FillRect FloodFill GetColor GetMaxX GetMaxY GetPixel GetX GetY InitGraph Line LineTo MoveRel MoveTo PutPixel Rectangle SetBkColor SetClipRect SetColor SetColorMapEntry SetColorMapDimensions","title":"Procedures and functions"},{"location":"biblioteki-podstawowe/#bar","text":"procedure Bar(x1, y1, x2, y2: Smallint); Prostok\u0105t, np. dla wykres\u00f3w s\u0142upkowych.","title":"Bar"},{"location":"biblioteki-podstawowe/#bar3d","text":"procedure Bar3D(x1, y1, x2, y2: smallint; depth: word; top: boolean); S\u0142upek dla wykres\u00f3w tr\u00f3jwymiarowych.","title":"Bar3D"},{"location":"biblioteki-podstawowe/#circle","text":"procedure Circle(x0,y0,radius: word); Okr\u0105g.","title":"Circle"},{"location":"biblioteki-podstawowe/#clipline","text":"procedure ClipLine(x1, y1, x2, y2: smallint);","title":"ClipLine"},{"location":"biblioteki-podstawowe/#ellipse","text":"procedure Ellipse(x0, y0, a, b: word); Elipsa.","title":"Ellipse"},{"location":"biblioteki-podstawowe/#fillellipse","text":"procedure FillEllipse(x0, y0, a, b: word); Elipsa wype\u0142niona wewn\u0105trz.","title":"FillEllipse"},{"location":"biblioteki-podstawowe/#fillrect","text":"procedure FillRect(Rect: TRect); Prostok\u0105t wype\u0142niony wewn\u0105trz.","title":"FillRect"},{"location":"biblioteki-podstawowe/#floodfill","text":"procedure FloodFill(x, y: smallint; color: byte); Wype\u0142nienie zamkni\u0119tego obszaru ekranu.","title":"FloodFill"},{"location":"biblioteki-podstawowe/#getcolor","text":"function GetColor: byte; assembler; Podaj bie\u017c\u0105cy kolor rysowania.","title":"GetColor"},{"location":"biblioteki-podstawowe/#getmaxx","text":"function GetMaxX: word; Podaj najwy\u017csz\u0105 warto\u015b\u0107 wsp\u00f3\u0142rz\u0119dnej X na ekranie.","title":"GetMaxX"},{"location":"biblioteki-podstawowe/#getmaxy","text":"function GetMaxY: word; Podaj najwy\u017csz\u0105 warto\u015b\u0107 wsp\u00f3\u0142rz\u0119dnej Y na ekranie.","title":"GetMaxY"},{"location":"biblioteki-podstawowe/#getpixel","text":"function GetPixel(x,y: smallint): byte; Podaj kolor danego punktu na ekranie.","title":"GetPixel"},{"location":"biblioteki-podstawowe/#getx","text":"function GetX: smallint; Podaj bie\u017c\u0105c\u0105 wsp\u00f3\u0142rz\u0119dn\u0105 X kursora graficznego.","title":"GetX"},{"location":"biblioteki-podstawowe/#gety","text":"function GetY: smallint; Podaj bie\u017c\u0105c\u0105 wsp\u00f3\u0142rz\u0119dn\u0105 Y kursora graficznego.","title":"GetY"},{"location":"biblioteki-podstawowe/#initgraph","text":"procedure InitGraph(mode: byte); procedure InitGraph(driver, mode: byte; pth: TString); Zainicjuj tryb graficzny.","title":"InitGraph"},{"location":"biblioteki-podstawowe/#line","text":"procedure Line(x0, y0, x1, y1: smallint); Linia prosta.","title":"Line"},{"location":"biblioteki-podstawowe/#lineto","text":"procedure LineTo(x, y: smallint); Linia od bie\u017c\u0105cej pozycji kursora do wskazanego punktu.","title":"LineTo"},{"location":"biblioteki-podstawowe/#moverel","text":"procedure MoveRel(Dx, Dy: smallint); Przesu\u0144 kursor graficzny.","title":"MoveRel"},{"location":"biblioteki-podstawowe/#moveto","text":"procedure MoveTo(x, y: smallint); Przesu\u0144 kursor graficzny do wskazanego punktu.","title":"MoveTo"},{"location":"biblioteki-podstawowe/#putpixel","text":"procedure PutPixel(x,y: smallint); procedure PutPixel(x,y: smallint; color: byte); Zapal punkt na ekranie.","title":"PutPixel"},{"location":"biblioteki-podstawowe/#rectangle","text":"procedure Rectangle(x1, y1, x2, y2: smallint); procedure Rectangle(Rect: TRect); Prostok\u0105t.","title":"Rectangle"},{"location":"biblioteki-podstawowe/#setbkcolor","text":"procedure SetBkColor(color: byte); Ustaw kolor t\u0142a.","title":"SetBkColor"},{"location":"biblioteki-podstawowe/#setcliprect","text":"procedure SetClipRect(x0,y0,x1,y1: smallint); procedure SetClipRect(Rect: TRect);","title":"SetClipRect"},{"location":"biblioteki-podstawowe/#setcolor","text":"procedure SetColor(color: byte); Ustaw kolor pisaka.","title":"SetColor"},{"location":"biblioteki-podstawowe/#setcolormapentry","text":"procedure SetColorMapEntry; procedure SetColorMapEntry(a,b,c: byte);","title":"SetColorMapEntry"},{"location":"biblioteki-podstawowe/#setcolormapdimensions","text":"procedure SetColorMapDimensions(w,h: byte);","title":"SetColorMapDimensions"},{"location":"biblioteki-podstawowe/#sysutils","text":"","title":"SYSUTILS"},{"location":"biblioteki-podstawowe/#constants_3","text":"faReadOnly = $01; faHidden = $02; faSysFile = $04; faVolumeID = $08; faDirectory = $10; faArchive = $20; faAnyFile = $3f;","title":"Constants"},{"location":"biblioteki-podstawowe/#types_1","text":"","title":"Types"},{"location":"biblioteki-podstawowe/#tsearchrec","text":"TSearchRec = record Attr: Byte; Name: TString; FindHandle: Pointer; end;","title":"TSearchRec"},{"location":"biblioteki-podstawowe/#procedures-and-functions_3","text":"AnsiUpperCase Beep Click DeleteFile ExtractFileExt FileExists FindFirst FindNext FindClose GetTickCount IntToHex IntToStr RenameFile StrToFloat StrToInt","title":"Procedures and functions"},{"location":"biblioteki-podstawowe/#ansiuppercase","text":"function AnsiUpperCase(const a: string): string; Funkcja konwertuje znaki z \u0142a\u0144cucha a na wielkie.","title":"AnsiUpperCase"},{"location":"biblioteki-podstawowe/#beep","text":"procedure Beep; Sygna\u0142 brz\u0119czka (buzzer).","title":"Beep"},{"location":"biblioteki-podstawowe/#click","text":"procedure Click; Sygna\u0142 klawiatury.","title":"Click"},{"location":"biblioteki-podstawowe/#deletefile_1","text":"function DeleteFile(var FileName: TString): Boolean; Funkcja kasuje plik okre\u015blony w parametrze FileName , zwraca TRUE gdy operacja si\u0119 powiod\u0142a.","title":"DeleteFile"},{"location":"biblioteki-podstawowe/#extractfileext","text":"function ExtractFileExt(const FileName: string): TString; Na podstawie nazwy pliku lub pe\u0142nej \u015bcie\u017cki do pliku okre\u015blonej w parametrze FileName , funkcja zwraca rozszerzenie (poprzedzone kropk\u0105 - np. .txt ).","title":"ExtractFileExt"},{"location":"biblioteki-podstawowe/#fileexists","text":"function FileExists(const FileName: string): Boolean; Funkcja sprawdza czy plik okre\u015blony w parametrze FileName , istnieje True czy te\u017c nie False .","title":"FileExists"},{"location":"biblioteki-podstawowe/#findfirst","text":"function FindFirst(const FileMask: TString; Attributes: Byte; var SearchResult: TSearchRec): byte; Funkcja wyszukuje pliki pasuj\u0105ce do wzorca FileMask i posiadaj\u0105ce atrybuty okre\u015blone w Attributes . Je\u015bli zosta\u0142y znalezione pliki pasuj\u0105ce do szablonu to pierwszy z nich jest zwracany w zmiennej SerchResult .","title":"FindFirst"},{"location":"biblioteki-podstawowe/#findnext","text":"function FindNext(var f: TSearchRec): byte; Funkcja przechodzi do nast\u0119pnego rekordu znalezionego wcze\u015bniej przy pomocy FindFirst . W parametrze musi zosta\u0107 przekazane wskazanie na rekord, kt\u00f3ry wcze\u015bniej zosta\u0142 u\u017cyty w funkcji FindFirst .","title":"FindNext"},{"location":"biblioteki-podstawowe/#findclose","text":"procedure FindClose(var f: TSearchRec); Procedura zwalnia zasoby (pami\u0119\u0107) zaalokowan\u0105 przez funkcj\u0119 FindFirst . Procedura ta powinna by\u0107 wywo\u0142ywana za ka\u017cdym razem po zako\u0144czeniu procesu wyszukiwania.","title":"FindClose"},{"location":"biblioteki-podstawowe/#gettickcount","text":"function GetTickCount: cardinal; GetTickCount zwraca 24-bitowy licznik czasu (PEEK(RTCLOK+2) + PEEK(RTCLOK+1)*256 + PEEK(RTCLOK)*65536) . Jest to przydatne do pomiaru czasu.","title":"GetTickCount"},{"location":"biblioteki-podstawowe/#inttohex","text":"function IntToHex(Value: cardinal; Digits: byte): TString; Funkcja konwertuje warto\u015b\u0107 liczbow\u0105 na jej odpowiednik \u0142a\u0144cuchowy w systemie szesnastkowym.","title":"IntToHex"},{"location":"biblioteki-podstawowe/#inttostr","text":"function IntToStr(a: integer): ^char; Funkcja s\u0142u\u017cy do konwersji liczby ca\u0142kowitej podanej w parametrze do postaci \u0142a\u0144cuchowej.","title":"IntToStr"},{"location":"biblioteki-podstawowe/#renamefile_1","text":"function RenameFile(var OldName,NewName: TString): Boolean; Funkcja pr\u00f3buje zmieni\u0107 nazw\u0119 pliku okre\u015blonego w parametrze OldName na NewName . Je\u017celi operacja si\u0119 powiedzie, funkcja zwr\u00f3ci warto\u015b\u0107 True w przeciwnym wypadku False . Mo\u017ce si\u0119 zdarzy\u0107, \u017ce funkcja nie b\u0119dzie mog\u0142a zmieni\u0107 nazwy (np. gdy aplikacja nie ma prawa do tego) - w\u00f3wczas funkcja zwr\u00f3ci False .","title":"RenameFile"},{"location":"biblioteki-podstawowe/#strtofloat","text":"function StrToFloat(var s: TString): real; Funkcja konwertuje \u0142a\u0144cuch do postaci zmiennoprzenkowej typu Real .","title":"StrToFloat"},{"location":"biblioteki-podstawowe/#strtoint","text":"function StrToInt(const S: char): byte; function StrToInt (const S: TString): integer; Funkcja s\u0142u\u017cy do konwersji tekstu zapisanego w zmiennej S na liczb\u0119 ca\u0142kowit\u0105 - o ile to mo\u017cliwe.","title":"StrToInt"},{"location":"biblioteki-podstawowe/#vbxe","text":"Mapa pami\u0119ci dla VBXE zdefiniowana jest w module SYSTEM . VBXE_XDLADR = $0000; // XDLIST VBXE_MAPADR = $1000; // COLOR MAP ADDRESS VBXE_BCBADR = $0100; // BLITTER LIST ADDRESS VBXE_OVRADR = $5000; // OVERLAY ADDRESS VBXE_WINDOW = $B000; // 4K WINDOW $B000..$BFFF","title":"VBXE"},{"location":"biblioteki-podstawowe/#constants_4","text":"LoRes = 1; // 160x240x256c MedRes = 2; // 320x240x256c HiRes = 3; // 640x240x16c","title":"Constants"},{"location":"biblioteki-podstawowe/#types_2","text":"","title":"Types"},{"location":"biblioteki-podstawowe/#tuint24","text":"record byte0: byte; byte1: byte; byte2: byte; end; Typ 24-bitowy wykorzystywany do definicji adres\u00f3w pami\u0119ci VBXE .","title":"TUInt24"},{"location":"biblioteki-podstawowe/#txdl","text":"record xdlc_: word; rptl_: byte; xdlc: word; rptl: byte; ov_adr: TUInt24; ov_step: word; mp_adr: TUInt24; mp_step: word; mp_hscrol: byte; mp_vscrol: byte; mp_width: byte; mp_height: byte; ov_width: byte; ov_prior: byte; end; Typ TXDL wykorzystywany przez procedury GetXDL i SetXDL . Pozwala na modyfikacj\u0119 programu dla VBXE wykorzystywanego przez Mad-Pascal .","title":"TXDL"},{"location":"biblioteki-podstawowe/#tbcb","text":"record src_adr: TUInt24; src_step_y: smallint; src_step_x: shortint; dst_adr: TUInt24; dst_step_y: smallint; dst_step_x: shortint; blt_width: word; blt_height: byte; blt_and_mask: byte; blt_xor_mask: byte; blt_collision_mask: byte; blt_zoom: byte; pattern_feature: byte; blt_control: byte; end; Typ TBCB (21 bajt\u00f3w), Blitter Code Block . Definicja typu bloku programu dla Blittera VBXE .","title":"TBCB"},{"location":"biblioteki-podstawowe/#tvbxememorystream","text":"Object Position: cardinal; Size: cardinal; // 0..Size-1 procedure Create; procedure Clear; procedure SetBank; procedure ReadBuffer(var Buffer; Count: word); procedure WriteBuffer(var Buffer; Count: word); function ReadByte: Byte; function ReadWord: Word; function ReadDWord: Cardinal; procedure WriteByte(b: Byte); procedure WriteWord(w: Word); procedure WriteDWord(d: Cardinal); end; Obiekt TVBXEMemoryStream pozwala na liniowy dost\u0119p do pami\u0119ci VBXE .","title":"TVBXEMemoryStream"},{"location":"biblioteki-podstawowe/#procedures-and-functions_4","text":"BlitterBusy ColorMapOff ColorMapOn DstBCB ExtractFileExt GetXDL IniBCB OverlayOff RunBCB SetHorizontalRes VBXEMemoryBank SetXDL SrcBCB VBXEControl VBXEOff","title":"Procedures and functions"},{"location":"biblioteki-podstawowe/#blitterbusy","text":"function BlitterBusy: Boolean; assembler; Funkcja zwraca TRUE je\u015bli blitter VBXE zaj\u0119ty jest wykonywaniem programu blittera.","title":"BlitterBusy"},{"location":"biblioteki-podstawowe/#colormapoff","text":"procedure ColorMapOff; assembler; Wy\u0142\u0105czenie mapy kolor\u00f3w w programie XDLIST dla VBXE .","title":"ColorMapOff"},{"location":"biblioteki-podstawowe/#colormapon","text":"procedure ColorMapOn; assembler; W\u0142\u0105czenie mapy kolor\u00f3w w programie XDLIST dla VBXE .","title":"ColorMapOn"},{"location":"biblioteki-podstawowe/#dstbcb","text":"procedure DstBCB(var a: TBCB; dst: cardinal); Procedura zmieniaj\u0105ca adres docelowy dst_adr w programie blittera A .","title":"DstBCB"},{"location":"biblioteki-podstawowe/#getxdl","text":"procedure GetXDL(var a: txdl); register; assembler; Procedura przepisuje do zmiennej A program XDLIST spod adresu VBXE_XDLADR w pami\u0119ci VBXE .","title":"GetXDL"},{"location":"biblioteki-podstawowe/#inibcb","text":"procedure IniBCB(var a: TBCB; src,dst: cardinal; w0, w1: smallint; w: word; h: byte; ctrl: byte); Procedura pozwala zaincjowa\u0107 pami\u0119\u0107 dla programu blittera pod adresem A . Dodatkowe parametry okre\u015blaj\u0105 adres spod kt\u00f3rego b\u0119d\u0105 kopiowane dane SRC , adres docelowy kopiowanych danych DST , szeroko\u015b\u0107 okna danych \u017ar\u00f3d\u0142owych W0 , docelowych W1 , rozmiar okna wynikowego, jego szeroko\u015b\u0107 W , wysoko\u015b\u0107 H , oraz okre\u015bli\u0107 parametry ko\u0144cowe bloku programu blittera CTRL (ustawiony bit 3 CTRL nakazuje blitterowi odczyt kolejnego programu i jego wykonanie).","title":"IniBCB"},{"location":"biblioteki-podstawowe/#overlayoff","text":"procedure OverlayOff; assembler; Wy\u0142\u0105czenie trybu overlay w programie XDLIST .","title":"OverlayOff"},{"location":"biblioteki-podstawowe/#runbcb","text":"procedure RunBCB(var a: TBCB); assembler; Wystartowanie blittera VBXE na podstawie adresu programu A .","title":"RunBCB"},{"location":"biblioteki-podstawowe/#sethorizontalres","text":"procedure SetHorizontalRes(a: byte); assembler; procedure SetHRes(a: byte); assembler; Ustanowienie trybu overlay w programie XDLIST .","title":"SetHorizontalRes"},{"location":"biblioteki-podstawowe/#vbxememorybank","text":"procedure VBXEMemoryBank(b: byte); assembler; W\u0142\u0105czenie 4K banku VBXE w okno pami\u0119ci XE/XL $B000..$BCFF .","title":"VBXEMemoryBank"},{"location":"biblioteki-podstawowe/#setxdl","text":"procedure SetXDL(var a: txdl); register; assembler; Procedura przepisuje program A pod adres VBXE_XDLADR w pami\u0119ci VBXE .","title":"SetXDL"},{"location":"biblioteki-podstawowe/#srcbcb","text":"procedure SrcBCB(var a: TBCB; src: cardinal); Procedura zmieniaj\u0105ca adres \u017ar\u00f3d\u0142owy src_adr w programie blittera A .","title":"SrcBCB"},{"location":"biblioteki-podstawowe/#vbxecontrol","text":"procedure VBXEControl(a: byte); assembler; Procedura ustawia warto\u015bc FX_VIDEO_CONTROL .","title":"VBXEControl"},{"location":"biblioteki-podstawowe/#vbxeoff","text":"procedure VBXEOff Wy\u0142\u0105czenie, reset VBXE .","title":"VBXEOff"},{"location":"biblioteki-podstawowe/#math","text":"","title":"MATH"},{"location":"biblioteki-podstawowe/#procedures-and-functions_5","text":"ArcCos ArcSin ArcTan2 Ceil CycleToRad DegNormalize DegToGrad DegToRad DivMod EnsureRange Floor FMod GradToDeg GradToRad InRange IsNan Log2 Log10 LogN Max Min Power RadToCycle RadToDeg RadToGrad RandG RandomRange RandomRangeF Tan","title":"Procedures and functions"},{"location":"biblioteki-podstawowe/#arccos","text":"function ArcCos(x: real): real; ArcCos jest funkcj\u0105 odwrotn\u0105 do funkcji Cos . Warto\u015b\u0107 parametru X musi nale\u017ce\u0107 do przedzia\u0142u obustronnie domkni\u0119tego <-1; 1> . Warto\u015bci\u0105 zwracan\u0105 przez funkcj\u0119 jest k\u0105t z przedzia\u0142u <0; ?> wyra\u017cony w mierze \u0142ukowej (radianach).","title":"ArcCos"},{"location":"biblioteki-podstawowe/#arcsin","text":"function ArcSin(x: real): real; Funkcja s\u0142u\u017cy do obliczenia funkcji matematycznej arcus sinus z liczby X . Jest to funkcja odwrotna do funkcji sinus, tzn. sin(arcsin(x)) = x .","title":"ArcSin"},{"location":"biblioteki-podstawowe/#arctan2","text":"function ArcTan2(y, x: real) : real; Funkcja oblicza arcus tangens (odwrotno\u015b\u0107 tangensa) z liczby Y/X i zwraca warto\u015b\u0107 w radianach.","title":"ArcTan2"},{"location":"biblioteki-podstawowe/#ceil","text":"function Ceil(a: real): smallint; Funkcja zwraca najmniejsz\u0105 liczb\u0119 ca\u0142kowit\u0105 wi\u0119ksz\u0105 lub r\u00f3wn\u0105 od tej podanej w parametrze.","title":"Ceil"},{"location":"biblioteki-podstawowe/#cycletorad","text":"function CycleToRad(cycle : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w cyklach (obrotach) na k\u0105t wyra\u017cony w radianach.","title":"CycleToRad"},{"location":"biblioteki-podstawowe/#degnormalize","text":"function DegNormalize(deg : real) : real;","title":"DegNormalize"},{"location":"biblioteki-podstawowe/#degtograd","text":"function DegToGrad(deg : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w stopniach na k\u0105t wyra\u017cony w gradach.","title":"DegToGrad"},{"location":"biblioteki-podstawowe/#degtorad","text":"function DegToRad(deg : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w stopniach na k\u0105t wyra\u017cony w mierze \u0142ukowej, czyli radianach.","title":"DegToRad"},{"location":"biblioteki-podstawowe/#divmod","text":"procedure DivMod(Dividend: integer; Divisor: Word; var r, Remainder: Word); procedure DivMod(Dividend: integer; Divisor: Word; var r, Remainder: smallint);","title":"DivMod"},{"location":"biblioteki-podstawowe/#ensurerange","text":"function EnsureRange(const AValue, AMin, AMax: byte): Integer; function EnsureRange(const AValue, AMin, AMax: Integer): Integer;","title":"EnsureRange"},{"location":"biblioteki-podstawowe/#floor","text":"function Floor(a: real): smallint; Funkcja zwraca najbli\u017csz\u0105 liczb\u0119 ca\u0142kowit\u0105 mniejsz\u0105 lub r\u00f3wn\u0105 od tej podanej w parametrze.","title":"Floor"},{"location":"biblioteki-podstawowe/#fmod","text":"function FMod(a, b: real): real; Funkcja zwraca reszt\u0119 z dzielenia dw\u00f3ch liczb rzeczywistych.","title":"FMod"},{"location":"biblioteki-podstawowe/#gradtodeg","text":"function GradToDeg(grad : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w gradach na k\u0105t wyra\u017cony w stopniach.","title":"GradToDeg"},{"location":"biblioteki-podstawowe/#gradtorad","text":"function GradToRad(grad : real) : real; Funkcja GradToRad przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w gradach na k\u0105t wyra\u017cony w radianach.","title":"GradToRad"},{"location":"biblioteki-podstawowe/#inrange","text":"function InRange(const AValue, AMin, AMax: byte): Boolean; function InRange(const AValue, AMin, AMax: Integer): Boolean;","title":"InRange"},{"location":"biblioteki-podstawowe/#isnan","text":"function IsNan(const d : Single): Boolean; Funkcja sprawdza czy warto\u015b\u0107 parametru d jest poprawn\u0105 liczb\u0105.","title":"IsNan"},{"location":"biblioteki-podstawowe/#log2","text":"function log2(x : single): single; Funkcja zwraca warto\u015b\u0107 logarytmu przy podstawie 2 dla parametru rzeczywistego X>0.","title":"Log2"},{"location":"biblioteki-podstawowe/#log10","text":"function log10(x : single): single; Funkcja zwraca warto\u015b\u0107 logarytmu dziesi\u0119tnego (logarytmu przy podstawie 10) dla parametru rzeczywistego X>0.","title":"Log10"},{"location":"biblioteki-podstawowe/#logn","text":"function logN(n,x : single): single; Funkcja zwraca warto\u015b\u0107 logarytmu przy podstawie N>0 dla parametru rzeczywistego X>0.","title":"LogN"},{"location":"biblioteki-podstawowe/#max","text":"function Max(a, b: real): real; function Max(a, b: integer): integer; Przeci\u0105\u017cona funkcja por\u00f3wnuje warto\u015bci dw\u00f3ch parametr\u00f3w: a i b , oraz zwraca ten, kt\u00f3ry jest wi\u0119kszy.","title":"Max"},{"location":"biblioteki-podstawowe/#min","text":"function Min(a, b: real): real; function Min(a, b: integer): integer; Przeci\u0105\u017cona funkcja por\u00f3wnuje warto\u015bci dw\u00f3ch parametr\u00f3w a i b , oraz zwraca warto\u015b\u0107 tego kt\u00f3ry jest mniejszy.","title":"Min"},{"location":"biblioteki-podstawowe/#power","text":"function Power(base : real; const exponent : shortint): real; power(base : integer; const exponent : shortint): integer; Funkcja podnosi liczb\u0119 A do dowolnej pot\u0119gi N, pot\u0119ga mo\u017ce by\u0107 u\u0142amkiem.","title":"Power"},{"location":"biblioteki-podstawowe/#radtocycle","text":"function RadToCycle(rad : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w radianach na k\u0105t wyra\u017cony w cyklach (obrotach).","title":"RadToCycle"},{"location":"biblioteki-podstawowe/#radtodeg","text":"function RadToDeg(rad : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w radianach na k\u0105t wyra\u017cony w stopniach (deg).","title":"RadToDeg"},{"location":"biblioteki-podstawowe/#radtograd","text":"function RadToGrad(rad : real) : real; Funkcja przelicza warto\u015b\u0107 k\u0105ta wyra\u017conego w radianach na k\u0105t wyra\u017cony w gradach.","title":"RadToGrad"},{"location":"biblioteki-podstawowe/#randg","text":"function RandG(mean, StdDev : single) : single; RandG reprezentuje generator liczb pseudolosowych o rozk\u0142adzie Gaussa wok\u00f3\u0142 \u015bredniej mean . Parametr StdDev jest odchyleniem standardowym generowanych liczb od warto\u015bci \u015bredniej mean .","title":"RandG"},{"location":"biblioteki-podstawowe/#randomrange","text":"function RandomRange(const aFrom, aTo: smallint): smallint; Funkcja zwraca losow\u0105 liczb\u0119 z przedzia\u0142u AFrom - ATo , \u0142\u0105cznie z warto\u015bci\u0105 ATo .","title":"RandomRange"},{"location":"biblioteki-podstawowe/#randomrangef","text":"function RandomRangeF(const min, max: single): single;","title":"RandomRangeF"},{"location":"biblioteki-podstawowe/#tan","text":"function Tan(x: Real): Real; Funkcja zwraca warto\u015b\u0107 tangensa k\u0105ta podanego w parametrze x .","title":"Tan"},{"location":"instrukcje/","text":"Warunkowe case of else Obecnie Mad Pascal akceptuje dla zmiennej CASE typy tylko o d\u0142ugo\u015bci 1 bajta: SHORTINT BYTE CHAR BOOLEAN . case a of // dla zmiennej A typu CHAR 'A'..'Z': begin end; '0'..'9': begin end; '+','*': begin end; end; if then else Instrukcje warunkowe IF mog\u0105 by\u0107 zagnie\u017cd\u017cane. Wykorzystywane jest to przy budowie bardziej z\u0142o\u017conych warunk\u00f3w. Iteracyjne for to downto do FOR zmienna := { warto\u015b\u0107 pocz\u0105tkowa } TO { warto\u015b\u0107 ko\u0144cowa } DO { instrukcje do wykonania } FOR zmienna := { warto\u015b\u0107 ko\u0144cowa } DOWNTO { warto\u015b\u0107 pocz\u0105tkowa } DO { instrukcje do wykonania } Instrukcja FOR s\u0142u\u017cy do organizacji oblicze\u0144, kt\u00f3re b\u0119d\u0105 wykonywane z g\u00f3ry okre\u015blon\u0105 liczb\u0105 razy. Zmienna steruj\u0105ca musi by\u0107 identyfikatorem typu porz\u0105dkowego, a oba wyra\u017cenia powinny by\u0107 zgodne w sensie przypisania z typem zmiennej steruj\u0105cej. W czasie realizacji p\u0119tli TO zmiennej steruj\u0105cej przypisywana jest nast\u0119pna warto\u015b\u0107 w danym typie, w p\u0119tli DOWNTO poprzednia. Zabroniona jest r\u0119czna zmiana warto\u015bci zmiennej steruj\u0105cej. W przypadku takiej pr\u00f3by Mad-Pascal zasygnalizuje b\u0142\u0105d Illegal assignment to for-loop variable . Kompilator dba o to aby nie wyst\u0105pi\u0142a p\u0119tla bez ko\u0144ca, dlatego w przeciwie\u0144stwie do p\u0119tli repeat i while mo\u017cna bez obaw stosowa\u0107 tak\u0105 p\u0119tl\u0119: for i:=0 to 255 do writeln(i); // dla zmiennej I typu BYTE Po zako\u0144czeniu dzia\u0142ania p\u0119tli FOR jej licznik b\u0119dzie mia\u0142 warto\u015b\u0107 +1 wi\u0119ksz\u0105 ni\u017c wskazuje zakres jaki podali\u015bmy, czyli dla: for i:=0 to 10 do; Warto\u015b\u0107 zmiennej I jak\u0105 odczytamy to I = 11 , w przypadku FPC b\u0119dzie to I = 10 . for in do FOR zmienna IN array DO {instrukcje do wykonania} FOR char IN 'string literal' DO {instrukcje do wykonania} Konstrukcja FOR IN DO pozwala na szybsze odczytywanie element\u00f3w tablic lub sta\u0142ych tekstowych. var days : array [0..6] of string = ('poniedzialek', 'wtorek', 'sroda' ,'czwartek', 'piatek', 'sobota', 'niedziela'); a: string; begin for a in days do writeln(a); while do while { warunek } do { instrukcja do wykonania } Konstrukcja ta s\u0142u\u017cy do organizacji oblicze\u0144, kt\u00f3re b\u0119d\u0105 wykonywane tak d\u0142ugo jak wyra\u017cenie znajduj\u0105ce si\u0119 po s\u0142owie WHILE jest prawd\u0105. W przypadku p\u0119tli WHILE warunek jest sprawdzany bezpo\u015brednio przed jej wykonaniem, co w rezultacie mo\u017ce spowodowa\u0107, \u017ce taka p\u0119tla nigdy niezostanie wykonana. while BlitterBusy do; // oczekiwanie na zako\u0144czenie dzia\u0142ania blittera VBXE Ograniczenia dla instrukcji WHILE : while i<=255 do inc(i); // p\u0119tla bez ko\u0144ca gdy zmienna I typu BYTE repeat until repeat { instrukcje do wykonania } until { warunek zako\u0144czenia } Instrukcja ta wykonuje cyklicznie inne instrukcje zawarte pomi\u0119dzy s\u0142owami REPEAT i UNTIL do momentu gdy wyra\u017cenie znajduj\u0105ce si\u0119 za s\u0142owem UNTIL nie przyjmie warto\u015bci TRUE . Efekt zastosowania p\u0119tli REPEAT jest bardzo podobny do dzia\u0142ania p\u0119tli WHILE . Jedyna r\u00f3\u017cnica polega na tym, \u017ce w p\u0119tli REPEAT warunek zako\u0144czenia sprawdzany jest dopiero po wykonaniu instrukcji. Oznacza to, \u017ce p\u0119tla REPEAT zawsze b\u0119dzie wykonana co najmniej raz. Dopiero po pierwszej iteracji program sprawdzi, czy mo\u017cna zako\u0144czy\u0107 dzia\u0142anie p\u0119tli. i:=0; repeat inc(i); until i=0; // p\u0119tla wykona si\u0119 256 razy","title":"Instrukcje"},{"location":"instrukcje/#_1","text":"","title":""},{"location":"instrukcje/#warunkowe","text":"","title":"Warunkowe"},{"location":"instrukcje/#case-of-else","text":"Obecnie Mad Pascal akceptuje dla zmiennej CASE typy tylko o d\u0142ugo\u015bci 1 bajta: SHORTINT BYTE CHAR BOOLEAN . case a of // dla zmiennej A typu CHAR 'A'..'Z': begin end; '0'..'9': begin end; '+','*': begin end; end;","title":"case of else"},{"location":"instrukcje/#if-then-else","text":"Instrukcje warunkowe IF mog\u0105 by\u0107 zagnie\u017cd\u017cane. Wykorzystywane jest to przy budowie bardziej z\u0142o\u017conych warunk\u00f3w.","title":"if then else"},{"location":"instrukcje/#iteracyjne","text":"","title":"Iteracyjne"},{"location":"instrukcje/#for-to-downto-do","text":"FOR zmienna := { warto\u015b\u0107 pocz\u0105tkowa } TO { warto\u015b\u0107 ko\u0144cowa } DO { instrukcje do wykonania } FOR zmienna := { warto\u015b\u0107 ko\u0144cowa } DOWNTO { warto\u015b\u0107 pocz\u0105tkowa } DO { instrukcje do wykonania } Instrukcja FOR s\u0142u\u017cy do organizacji oblicze\u0144, kt\u00f3re b\u0119d\u0105 wykonywane z g\u00f3ry okre\u015blon\u0105 liczb\u0105 razy. Zmienna steruj\u0105ca musi by\u0107 identyfikatorem typu porz\u0105dkowego, a oba wyra\u017cenia powinny by\u0107 zgodne w sensie przypisania z typem zmiennej steruj\u0105cej. W czasie realizacji p\u0119tli TO zmiennej steruj\u0105cej przypisywana jest nast\u0119pna warto\u015b\u0107 w danym typie, w p\u0119tli DOWNTO poprzednia. Zabroniona jest r\u0119czna zmiana warto\u015bci zmiennej steruj\u0105cej. W przypadku takiej pr\u00f3by Mad-Pascal zasygnalizuje b\u0142\u0105d Illegal assignment to for-loop variable . Kompilator dba o to aby nie wyst\u0105pi\u0142a p\u0119tla bez ko\u0144ca, dlatego w przeciwie\u0144stwie do p\u0119tli repeat i while mo\u017cna bez obaw stosowa\u0107 tak\u0105 p\u0119tl\u0119: for i:=0 to 255 do writeln(i); // dla zmiennej I typu BYTE Po zako\u0144czeniu dzia\u0142ania p\u0119tli FOR jej licznik b\u0119dzie mia\u0142 warto\u015b\u0107 +1 wi\u0119ksz\u0105 ni\u017c wskazuje zakres jaki podali\u015bmy, czyli dla: for i:=0 to 10 do; Warto\u015b\u0107 zmiennej I jak\u0105 odczytamy to I = 11 , w przypadku FPC b\u0119dzie to I = 10 .","title":"for to downto do"},{"location":"instrukcje/#for-in-do","text":"FOR zmienna IN array DO {instrukcje do wykonania} FOR char IN 'string literal' DO {instrukcje do wykonania} Konstrukcja FOR IN DO pozwala na szybsze odczytywanie element\u00f3w tablic lub sta\u0142ych tekstowych. var days : array [0..6] of string = ('poniedzialek', 'wtorek', 'sroda' ,'czwartek', 'piatek', 'sobota', 'niedziela'); a: string; begin for a in days do writeln(a);","title":"for in do"},{"location":"instrukcje/#while-do","text":"while { warunek } do { instrukcja do wykonania } Konstrukcja ta s\u0142u\u017cy do organizacji oblicze\u0144, kt\u00f3re b\u0119d\u0105 wykonywane tak d\u0142ugo jak wyra\u017cenie znajduj\u0105ce si\u0119 po s\u0142owie WHILE jest prawd\u0105. W przypadku p\u0119tli WHILE warunek jest sprawdzany bezpo\u015brednio przed jej wykonaniem, co w rezultacie mo\u017ce spowodowa\u0107, \u017ce taka p\u0119tla nigdy niezostanie wykonana. while BlitterBusy do; // oczekiwanie na zako\u0144czenie dzia\u0142ania blittera VBXE Ograniczenia dla instrukcji WHILE : while i<=255 do inc(i); // p\u0119tla bez ko\u0144ca gdy zmienna I typu BYTE","title":"while do"},{"location":"instrukcje/#repeat-until","text":"repeat { instrukcje do wykonania } until { warunek zako\u0144czenia } Instrukcja ta wykonuje cyklicznie inne instrukcje zawarte pomi\u0119dzy s\u0142owami REPEAT i UNTIL do momentu gdy wyra\u017cenie znajduj\u0105ce si\u0119 za s\u0142owem UNTIL nie przyjmie warto\u015bci TRUE . Efekt zastosowania p\u0119tli REPEAT jest bardzo podobny do dzia\u0142ania p\u0119tli WHILE . Jedyna r\u00f3\u017cnica polega na tym, \u017ce w p\u0119tli REPEAT warunek zako\u0144czenia sprawdzany jest dopiero po wykonaniu instrukcji. Oznacza to, \u017ce p\u0119tla REPEAT zawsze b\u0119dzie wykonana co najmniej raz. Dopiero po pierwszej iteracji program sprawdzi, czy mo\u017cna zako\u0144czy\u0107 dzia\u0142anie p\u0119tli. i:=0; repeat inc(i); until i=0; // p\u0119tla wykona si\u0119 256 razy","title":"repeat until"},{"location":"makra/","text":"Makra Mad-Pascal pozwala na u\u017cywanie makr, podobnie jak FPC , z tym tylko wyj\u0105tkiem \u017ce makra zawsze s\u0105 w\u0142\u0105czone. {$macro on} {$macro off} {$macro+} {$macro-} Dyrektywa {$macro on} jest wymagana przez FPC , w Mad-Pascal jest zachowana tylko w celu zgodno\u015bci. Definiowanie makra {$define label := expression} {$define label(par0, par1 ... par7) := expression} Aby definicja zosta\u0142a rozpoznana jako makro po nazwie etykiety i ewentualnej li\u015bcie (par0..par7) parametr\u00f3w musi wyst\u0105pi\u0107 symbol przypisania := . {$define new_proc := procedure test; begin writeln('ok'); end; } new_proc begin test; end. {$define sum_xi := x:=x+i; } begin sum_xi; end; {$define WIDTH := 80} {$define LEN := ( WIDTH + 10 )} var a: byte; begin a := len * 20; end. Makra z parametrami obs\u0142ugiwane s\u0105 przez Mad-Pascal ale nie przez FPC . {$define SIGN_MASK := $8000} {$define SIGNED_INF_VALUE(x) := ((x and SIGN_MASK) or $7C00)} var a: byte = 11; begin writeln( SIGNED_INF_VALUE(a shl 15) ); end.","title":"Makra"},{"location":"makra/#_1","text":"","title":""},{"location":"makra/#makra","text":"Mad-Pascal pozwala na u\u017cywanie makr, podobnie jak FPC , z tym tylko wyj\u0105tkiem \u017ce makra zawsze s\u0105 w\u0142\u0105czone. {$macro on} {$macro off} {$macro+} {$macro-} Dyrektywa {$macro on} jest wymagana przez FPC , w Mad-Pascal jest zachowana tylko w celu zgodno\u015bci.","title":"Makra"},{"location":"makra/#definiowanie-makra","text":"{$define label := expression} {$define label(par0, par1 ... par7) := expression} Aby definicja zosta\u0142a rozpoznana jako makro po nazwie etykiety i ewentualnej li\u015bcie (par0..par7) parametr\u00f3w musi wyst\u0105pi\u0107 symbol przypisania := . {$define new_proc := procedure test; begin writeln('ok'); end; } new_proc begin test; end. {$define sum_xi := x:=x+i; } begin sum_xi; end; {$define WIDTH := 80} {$define LEN := ( WIDTH + 10 )} var a: byte; begin a := len * 20; end. Makra z parametrami obs\u0142ugiwane s\u0105 przez Mad-Pascal ale nie przez FPC . {$define SIGN_MASK := $8000} {$define SIGNED_INF_VALUE(x) := ((x and SIGN_MASK) or $7C00)} var a: byte = 11; begin writeln( SIGNED_INF_VALUE(a shl 15) ); end.","title":"Definiowanie makra"},{"location":"mapa/","text":"Mapa pami\u0119ci Atari XE/XL Kompilator korzysta ze strony zerowej w przedziale $0080 .. $00D7 W przypadku korzystania z pami\u0119ci dodatkowej tablica z kodami bank\u00f3w dla PORTB umieszczona zostaj\u0119 w przestrzeni adresowej $0101 .. $0140 Dodatkowy 256 bajtowy bufor pami\u0119ci wykorzystywany m.in. podczas operacji na ci\u0105gach znakowych, dekompresji ulokowany jest w obszarze $0400 .. $04FF (ATARI XE/XL) STACKORIGIN STATICDATA RUNTIME LIBRARY UNIT INITIALIZATIONS MAIN PROGRAM .LOCAL MAIN (all procedures / functions) .LOCAL @DEFINES .LOCAL @RESOURCE DATAORIGIN PROGRAMSTACK","title":"Mapa pami\u0119ci"},{"location":"mapa/#_1","text":"","title":""},{"location":"mapa/#mapa-pamieci","text":"Atari XE/XL Kompilator korzysta ze strony zerowej w przedziale $0080 .. $00D7 W przypadku korzystania z pami\u0119ci dodatkowej tablica z kodami bank\u00f3w dla PORTB umieszczona zostaj\u0119 w przestrzeni adresowej $0101 .. $0140 Dodatkowy 256 bajtowy bufor pami\u0119ci wykorzystywany m.in. podczas operacji na ci\u0105gach znakowych, dekompresji ulokowany jest w obszarze $0400 .. $04FF (ATARI XE/XL) STACKORIGIN STATICDATA RUNTIME LIBRARY UNIT INITIALIZATIONS MAIN PROGRAM .LOCAL MAIN (all procedures / functions) .LOCAL @DEFINES .LOCAL @RESOURCE DATAORIGIN PROGRAMSTACK","title":"Mapa pami\u0119ci"},{"location":"moduly/","text":"PROGRAM Nag\u0142\u00f3wek program nie jest wymagany, jest dostarczany tylko w celu zapewnienia kompatybilno\u015bci wstecznej z Turbo Pascal . program name [(parameters, ...)] [: address]; Mo\u017cliwe jest okre\u015blenie adresu kompilacji po znaku dwukropka : , jest to odpowiednik prze\u0142\u0105cznika z linii komend -code address . program test; uses // List of unit dependencies goes here... // Implementation of procedures, and functions goes here... end. UNIT Modu\u0142y UNIT wyst\u0119puj\u0105 tylko w postaci \u017ar\u00f3d\u0142owych plik\u00f3w .pas , nie mo\u017cna ich skompilowa\u0107 oddzielnie. Modu\u0142y UNIT sk\u0142adaj\u0105 si\u0119 z sekcji: INTERFACE wymagana IMPLEMENTATION wymagana INITIALIZATION opcjonalna . { Example UNIT } unit Unit1; interface uses // List of unit dependencies goes here... // Interface section goes here implementation uses // List of unit dependencies goes here... // Implementation of procedures, and functions goes here... initialization // Unit initialization code goes here... end. Przyk\u0142ad: unit test; interface type TUInt24 = record byte0: byte; byte1: byte; byte2: byte; end; const LoRes = 1; MedRes = 2; HiRes = 3; procedure Print(a: string); implementation uses test2; procedure Print(a: string); begin writeln(a); end; end. LIBRARY Nag\u0142\u00f3wek library jest wymagany. library name [: address]; Mo\u017cliwe jest okre\u015blenie adresu kompilacji po znaku dwukropka : , jest to odpowiednik prze\u0142\u0105cznika z linii komend -code address . Budowa biblioteki jest podobna do modu\u0142u unit , programu program . { Example LIBRARY } library lib1; uses // List of unit dependencies goes here... // Implementation of procedures, and functions goes here... // exported subroutine(s), variable(s) exports idents1, idents2, idents3 ... ; // optional library initialization code goes here... begin end. Domy\u015blnie funkcje i procedury zadeklarowane i zaimplementowane w bibliotece nie s\u0105 dost\u0119pne dla programisty, kt\u00f3ry chce korzysta\u0107 z tej biblioteki. Aby udost\u0119pni\u0107 funkcje lub procedury z biblioteki, nale\u017cy je wyeksportowa\u0107 w klauzuli exports . Funkcje, procedury i inne identyfikatory s\u0105 eksportowane z dok\u0142adnymi nazwami okre\u015blonymi w klauzuli exports . Aby m\u00f3c korzysta\u0107 z bibliotek w modu\u0142ach UNIT lub programie PROGRAM , nale\u017cy je najpierw skompilowa\u0107 i zasemblowa\u0107, prze\u0142\u0105cznik Mad Assembler-a -hm musi by\u0107 aktywny. mads.exe library.pas -hm -xi:<Mad_Pascal_path>\\base Plik\u00f3w .pas z kodem \u017ar\u00f3d\u0142owym bibliotek nie mo\u017cemy umieszcza\u0107 w klauzuli uses . Aby skorzysta\u0107 z identyfikator\u00f3w wyeksportowanych w LIBRARY korzystamy z modyfikatora EXTERNAL . EXPORTS Klauzula exports eksportuje identyfikatory z modu\u0142u library . Modu\u0142 library mo\u017ce mie\u0107 maksymalnie jedn\u0105 klauzul\u0119 exports . Lista identyfikator\u00f3w wyszczeg\u00f3lniona w klauzuli rozdzielona jest znakiem przecinka, znak \u015brednika oznacza koniec listy. EXTERNAL Modyfikator external pozwala wskaza\u0107 procedury/funkcje, zmienne jako zewn\u0119trzne, dost\u0119pne z innego modu\u0142u, biblioteki lub do\u0142\u0105czonego kodu relokowalnego. function dodaj(a,b: integer): integer; external 'TEST_LIB'; procedure prc(a,b,c: integer); external; USES Klauzula uses importuje identyfikatory z modu\u0142\u00f3w unit . Ka\u017cda jednostka Mad-Pascal \u2013 program , unit , lub library \u2013 mo\u017ce mie\u0107 maksymalnie jedn\u0105 klauzul\u0119 uses na sekcj\u0119, kt\u00f3ra musi pojawi\u0107 si\u0119 zaraz po nag\u0142\u00f3wkach sekcji. Nag\u0142\u00f3wki sekcji to interface , implementation w modu\u0142ach unit . W program i library nie ma \u017cadnych wyra\u017anych nag\u0142\u00f3wk\u00f3w sekcji, dlatego klauzula uses pojawia si\u0119 bezpo\u015brednio po nag\u0142\u00f3wku program , library . uses crt, sysutils, atari; Modu\u0142 SYSTEM nie mo\u017ce znajdowa\u0107 si\u0119 na tej li\u015bcie, poniewa\u017c jest on domy\u015blnie zawsze \u0142adowany przez kompilator. Kolejno\u015b\u0107, w jakiej pojawiaj\u0105 si\u0119 modu\u0142y, jest istotna, poniewa\u017c okre\u015bla, w jakiej kolejno\u015bci s\u0105 one inicjowane. Modu\u0142y s\u0105 inicjowane w tej samej kolejno\u015bci, w jakiej pojawiaj\u0105 si\u0119 w klauzuli uses . Identyfikatory s\u0105 wyszukiwane w odwrotnej kolejno\u015bci, tzn. gdy kompilator szuka identyfikatora, szuka go najpierw w ostatnim module w klauzuli uses , nast\u0119pnie w przedostatniej itd. Jest to wa\u017cne w przypadku, gdy dwa lub wi\u0119cej modu\u0142\u00f3w w klauzuli uses deklaruje ten sam identyfikator. uses graph, vbxe; W obu modu\u0142ach GRAPH i VBXE wyst\u0119puje procedura SetColor oraz Line , dla w/w przyk\u0142adu odwo\u0142ania do tych procedur b\u0119d\u0105 realizowane przez modu\u0142 VBXE , uses vbxe, graph; odwo\u0142ania do tych procedur b\u0119d\u0105 realizowane przez modu\u0142 GRAPH . Mo\u017cemy te\u017c bezpo\u015brednio odwo\u0142a\u0107 si\u0119 do identyfikatora z konkretnego modu\u0142u, np.: vbxe.Line graph.Line vbxe.SetColor graph.SetColor Kompilator b\u0119dzie szuka\u0142 wersji \u017ar\u00f3d\u0142owych wszystkich modu\u0142\u00f3w wyszczeg\u00f3lnionych w klauzuli uses na podstawie \u015bcie\u017cki z kt\u00f3rej zosta\u0142 uruchomiony kompilator mp.exe\\lib\\ . Przy pomocy s\u0142owa kluczowego IN mo\u017cemy zast\u0105pi\u0107 mechanizm automatycznego wyszukiwania modu\u0142u. uses unita in '..\\unita.pas'; Modu\u0142 unita jest wyszukiwany w katalogu nadrz\u0119dnym bie\u017c\u0105cego katalogu roboczego kompilatora. Mo\u017cna doda\u0107 dyrektyw\u0119 {$UNITPATH ..} , aby upewni\u0107 si\u0119, \u017ce modu\u0142 zostanie znaleziony bez wzgl\u0119du na to, gdzie znajduje si\u0119 bie\u017c\u0105cy katalog roboczy kompilatora. Gdy kompilator szuka plik\u00f3w modu\u0142\u00f3w, dodaje rozszerzenie .pas do nazwy modu\u0142u. $LIBRARYPATH {$LIBRARYPATH path1; path2; ...} Dyrektywa $LIBRARYPATH pozwala wskaza\u0107 dodatkowe \u015bcie\u017cki poszukiwa\u0144 modu\u0142\u00f3w UNIT zadeklarowanych przez uses . $UNITPATH {$UNITPATH path1; path2; ...} Dyrektywa $UNITPATH pozwala wskaza\u0107 dodatkowe \u015bcie\u017cki poszukiwa\u0144 modu\u0142\u00f3w UNIT zadeklarowanych przez uses .","title":"Program, modu\u0142y, biblioteki"},{"location":"moduly/#_1","text":"","title":""},{"location":"moduly/#program","text":"Nag\u0142\u00f3wek program nie jest wymagany, jest dostarczany tylko w celu zapewnienia kompatybilno\u015bci wstecznej z Turbo Pascal . program name [(parameters, ...)] [: address]; Mo\u017cliwe jest okre\u015blenie adresu kompilacji po znaku dwukropka : , jest to odpowiednik prze\u0142\u0105cznika z linii komend -code address . program test; uses // List of unit dependencies goes here... // Implementation of procedures, and functions goes here... end.","title":"PROGRAM"},{"location":"moduly/#unit","text":"Modu\u0142y UNIT wyst\u0119puj\u0105 tylko w postaci \u017ar\u00f3d\u0142owych plik\u00f3w .pas , nie mo\u017cna ich skompilowa\u0107 oddzielnie. Modu\u0142y UNIT sk\u0142adaj\u0105 si\u0119 z sekcji: INTERFACE wymagana IMPLEMENTATION wymagana INITIALIZATION opcjonalna . { Example UNIT } unit Unit1; interface uses // List of unit dependencies goes here... // Interface section goes here implementation uses // List of unit dependencies goes here... // Implementation of procedures, and functions goes here... initialization // Unit initialization code goes here... end. Przyk\u0142ad: unit test; interface type TUInt24 = record byte0: byte; byte1: byte; byte2: byte; end; const LoRes = 1; MedRes = 2; HiRes = 3; procedure Print(a: string); implementation uses test2; procedure Print(a: string); begin writeln(a); end; end.","title":"UNIT"},{"location":"moduly/#library","text":"Nag\u0142\u00f3wek library jest wymagany. library name [: address]; Mo\u017cliwe jest okre\u015blenie adresu kompilacji po znaku dwukropka : , jest to odpowiednik prze\u0142\u0105cznika z linii komend -code address . Budowa biblioteki jest podobna do modu\u0142u unit , programu program . { Example LIBRARY } library lib1; uses // List of unit dependencies goes here... // Implementation of procedures, and functions goes here... // exported subroutine(s), variable(s) exports idents1, idents2, idents3 ... ; // optional library initialization code goes here... begin end. Domy\u015blnie funkcje i procedury zadeklarowane i zaimplementowane w bibliotece nie s\u0105 dost\u0119pne dla programisty, kt\u00f3ry chce korzysta\u0107 z tej biblioteki. Aby udost\u0119pni\u0107 funkcje lub procedury z biblioteki, nale\u017cy je wyeksportowa\u0107 w klauzuli exports . Funkcje, procedury i inne identyfikatory s\u0105 eksportowane z dok\u0142adnymi nazwami okre\u015blonymi w klauzuli exports . Aby m\u00f3c korzysta\u0107 z bibliotek w modu\u0142ach UNIT lub programie PROGRAM , nale\u017cy je najpierw skompilowa\u0107 i zasemblowa\u0107, prze\u0142\u0105cznik Mad Assembler-a -hm musi by\u0107 aktywny. mads.exe library.pas -hm -xi:<Mad_Pascal_path>\\base Plik\u00f3w .pas z kodem \u017ar\u00f3d\u0142owym bibliotek nie mo\u017cemy umieszcza\u0107 w klauzuli uses . Aby skorzysta\u0107 z identyfikator\u00f3w wyeksportowanych w LIBRARY korzystamy z modyfikatora EXTERNAL .","title":"LIBRARY"},{"location":"moduly/#exports","text":"Klauzula exports eksportuje identyfikatory z modu\u0142u library . Modu\u0142 library mo\u017ce mie\u0107 maksymalnie jedn\u0105 klauzul\u0119 exports . Lista identyfikator\u00f3w wyszczeg\u00f3lniona w klauzuli rozdzielona jest znakiem przecinka, znak \u015brednika oznacza koniec listy.","title":"EXPORTS"},{"location":"moduly/#external","text":"Modyfikator external pozwala wskaza\u0107 procedury/funkcje, zmienne jako zewn\u0119trzne, dost\u0119pne z innego modu\u0142u, biblioteki lub do\u0142\u0105czonego kodu relokowalnego. function dodaj(a,b: integer): integer; external 'TEST_LIB'; procedure prc(a,b,c: integer); external;","title":"EXTERNAL"},{"location":"moduly/#uses","text":"Klauzula uses importuje identyfikatory z modu\u0142\u00f3w unit . Ka\u017cda jednostka Mad-Pascal \u2013 program , unit , lub library \u2013 mo\u017ce mie\u0107 maksymalnie jedn\u0105 klauzul\u0119 uses na sekcj\u0119, kt\u00f3ra musi pojawi\u0107 si\u0119 zaraz po nag\u0142\u00f3wkach sekcji. Nag\u0142\u00f3wki sekcji to interface , implementation w modu\u0142ach unit . W program i library nie ma \u017cadnych wyra\u017anych nag\u0142\u00f3wk\u00f3w sekcji, dlatego klauzula uses pojawia si\u0119 bezpo\u015brednio po nag\u0142\u00f3wku program , library . uses crt, sysutils, atari; Modu\u0142 SYSTEM nie mo\u017ce znajdowa\u0107 si\u0119 na tej li\u015bcie, poniewa\u017c jest on domy\u015blnie zawsze \u0142adowany przez kompilator. Kolejno\u015b\u0107, w jakiej pojawiaj\u0105 si\u0119 modu\u0142y, jest istotna, poniewa\u017c okre\u015bla, w jakiej kolejno\u015bci s\u0105 one inicjowane. Modu\u0142y s\u0105 inicjowane w tej samej kolejno\u015bci, w jakiej pojawiaj\u0105 si\u0119 w klauzuli uses . Identyfikatory s\u0105 wyszukiwane w odwrotnej kolejno\u015bci, tzn. gdy kompilator szuka identyfikatora, szuka go najpierw w ostatnim module w klauzuli uses , nast\u0119pnie w przedostatniej itd. Jest to wa\u017cne w przypadku, gdy dwa lub wi\u0119cej modu\u0142\u00f3w w klauzuli uses deklaruje ten sam identyfikator. uses graph, vbxe; W obu modu\u0142ach GRAPH i VBXE wyst\u0119puje procedura SetColor oraz Line , dla w/w przyk\u0142adu odwo\u0142ania do tych procedur b\u0119d\u0105 realizowane przez modu\u0142 VBXE , uses vbxe, graph; odwo\u0142ania do tych procedur b\u0119d\u0105 realizowane przez modu\u0142 GRAPH . Mo\u017cemy te\u017c bezpo\u015brednio odwo\u0142a\u0107 si\u0119 do identyfikatora z konkretnego modu\u0142u, np.: vbxe.Line graph.Line vbxe.SetColor graph.SetColor Kompilator b\u0119dzie szuka\u0142 wersji \u017ar\u00f3d\u0142owych wszystkich modu\u0142\u00f3w wyszczeg\u00f3lnionych w klauzuli uses na podstawie \u015bcie\u017cki z kt\u00f3rej zosta\u0142 uruchomiony kompilator mp.exe\\lib\\ . Przy pomocy s\u0142owa kluczowego IN mo\u017cemy zast\u0105pi\u0107 mechanizm automatycznego wyszukiwania modu\u0142u. uses unita in '..\\unita.pas'; Modu\u0142 unita jest wyszukiwany w katalogu nadrz\u0119dnym bie\u017c\u0105cego katalogu roboczego kompilatora. Mo\u017cna doda\u0107 dyrektyw\u0119 {$UNITPATH ..} , aby upewni\u0107 si\u0119, \u017ce modu\u0142 zostanie znaleziony bez wzgl\u0119du na to, gdzie znajduje si\u0119 bie\u017c\u0105cy katalog roboczy kompilatora. Gdy kompilator szuka plik\u00f3w modu\u0142\u00f3w, dodaje rozszerzenie .pas do nazwy modu\u0142u.","title":"USES"},{"location":"moduly/#librarypath","text":"{$LIBRARYPATH path1; path2; ...} Dyrektywa $LIBRARYPATH pozwala wskaza\u0107 dodatkowe \u015bcie\u017cki poszukiwa\u0144 modu\u0142\u00f3w UNIT zadeklarowanych przez uses .","title":"$LIBRARYPATH"},{"location":"moduly/#unitpath","text":"{$UNITPATH path1; path2; ...} Dyrektywa $UNITPATH pozwala wskaza\u0107 dodatkowe \u015bcie\u017cki poszukiwa\u0144 modu\u0142\u00f3w UNIT zadeklarowanych przez uses .","title":"$UNITPATH"},{"location":"pliki/","text":"Operacje na plikach FILE var f: file; TEXT var f: text; // zamiennie TEXT g: textfile; // lub TEXTFILE ASSIGN Przyk\u0142ad otwarcia kana\u0142u dla urz\u0105dzenia S: (ekran) w celu wyprowadzania znak\u00f3w w trybie GRAPHICS 1 , GRAPHICS 2 var scr: text; s: string = 'color COLOR ' + #155 + 'COLOR '* + 'color '*; begin assign(scr, 'S:'); // koniecznie przed InitGraph rewrite(scr); // koniecznie przed InitGraph InitGraph(2); // Graphics 2 GotoXY(1,6); write(scr, s); close(scr); end. RESET var t: text; reset(t); // dla odczytu pliku tekstowego, brak dodatkowego parametru z rozmiarem rekordu var f: file; reset(t, 1); // dla odczytu pliku binarnego (rekord = 1) W przypadku braku podania d\u0142ugo\u015bci rekordu dla pliku binarnego FILE zostanie przyj\u0119ta warto\u015b\u0107 domy\u015blna =128 REWRITE var t: text; rewrite(t); // dla zapisu pliku tekstowego, brak dodatkowego parametru z rozmiarem rekordu var f: file; rewrite(f, 1); // dla zapisu pliku binarnego (rekord = 1) W przypadku braku podania d\u0142ugo\u015bci rekordu dla pliku binarnego FILE zostanie przyj\u0119ta warto\u015b\u0107 domy\u015blna =128 APPEND var t: text; begin assign(t, 'D:TEXT.TXT'); append(t); writeln(t, 'ATARI'); writeln(t, 'C64'); write(t, 'Amstrad'); close(t); BLOCKREAD var f: file; pnt: pointer; begin pnt:=pointer(dpeek(88)); assign(f, 'D:FILENAME'); reset(f, 1); blockread(f, pnt^, 8); close(f); end. var f: file; buf: array [0..0] of byte; begin buf:=pointer(dpeek(88)); assign(f, 'D:FILENAME'); reset(f, 1); blockread(f, buf, 8); close(f); end. BLOCKWRITE var f: file; buf: array [0..0] of byte ABSOLUTE $bc40; begin assign(f, 'D:FILENAME'); rewrite(f, 1); blockwrite(f, buf, 40*24); close(f); end. CLOSE begin assign(f, 'D:FILENAME'); reset(f, 1); close(f); end.","title":"Operacje na plikach"},{"location":"pliki/#operacje-na-plikach","text":"","title":"Operacje na plikach"},{"location":"pliki/#file","text":"var f: file;","title":"FILE"},{"location":"pliki/#text","text":"var f: text; // zamiennie TEXT g: textfile; // lub TEXTFILE","title":"TEXT"},{"location":"pliki/#assign","text":"Przyk\u0142ad otwarcia kana\u0142u dla urz\u0105dzenia S: (ekran) w celu wyprowadzania znak\u00f3w w trybie GRAPHICS 1 , GRAPHICS 2 var scr: text; s: string = 'color COLOR ' + #155 + 'COLOR '* + 'color '*; begin assign(scr, 'S:'); // koniecznie przed InitGraph rewrite(scr); // koniecznie przed InitGraph InitGraph(2); // Graphics 2 GotoXY(1,6); write(scr, s); close(scr); end.","title":"ASSIGN"},{"location":"pliki/#reset","text":"var t: text; reset(t); // dla odczytu pliku tekstowego, brak dodatkowego parametru z rozmiarem rekordu var f: file; reset(t, 1); // dla odczytu pliku binarnego (rekord = 1) W przypadku braku podania d\u0142ugo\u015bci rekordu dla pliku binarnego FILE zostanie przyj\u0119ta warto\u015b\u0107 domy\u015blna =128","title":"RESET"},{"location":"pliki/#rewrite","text":"var t: text; rewrite(t); // dla zapisu pliku tekstowego, brak dodatkowego parametru z rozmiarem rekordu var f: file; rewrite(f, 1); // dla zapisu pliku binarnego (rekord = 1) W przypadku braku podania d\u0142ugo\u015bci rekordu dla pliku binarnego FILE zostanie przyj\u0119ta warto\u015b\u0107 domy\u015blna =128","title":"REWRITE"},{"location":"pliki/#append","text":"var t: text; begin assign(t, 'D:TEXT.TXT'); append(t); writeln(t, 'ATARI'); writeln(t, 'C64'); write(t, 'Amstrad'); close(t);","title":"APPEND"},{"location":"pliki/#blockread","text":"var f: file; pnt: pointer; begin pnt:=pointer(dpeek(88)); assign(f, 'D:FILENAME'); reset(f, 1); blockread(f, pnt^, 8); close(f); end. var f: file; buf: array [0..0] of byte; begin buf:=pointer(dpeek(88)); assign(f, 'D:FILENAME'); reset(f, 1); blockread(f, buf, 8); close(f); end.","title":"BLOCKREAD"},{"location":"pliki/#blockwrite","text":"var f: file; buf: array [0..0] of byte ABSOLUTE $bc40; begin assign(f, 'D:FILENAME'); rewrite(f, 1); blockwrite(f, buf, 40*24); close(f); end.","title":"BLOCKWRITE"},{"location":"pliki/#close","text":"begin assign(f, 'D:FILENAME'); reset(f, 1); close(f); end.","title":"CLOSE"},{"location":"porady/","text":"FOR Warto\u015b\u0107 licznika po zako\u0144czeniu dzia\u0142ania instrukcji iteracyjnej FOR w FPC b\u0119dzie r\u00f3wna warto\u015bci jaka zosta\u0142a okre\u015blona dla maksymalnej warto\u015bci licznika. W przypadku Mad-Pascal warto\u015b\u0107 b\u0119dzie wi\u0119ksza o +1 . Przyk\u0142ad: for i:=0 to 10 do; FPC po zako\u0144czeniu petli i = 10 , Mad-Pascal i = 11 SHL FPC podaje inne wyniki dla SHL kt\u00f3re przekracza rozmiar danego typu, np.: i: byte; c: cardinal; i:=1; c:=i shl 33; Dla w/w przyk\u0142adu FPC zwr\u00f3ci warto\u015b\u0107 c = 2 , Mad-Pascal zwr\u00f3ci c = 0 . Natomiast dla: c:=1 shl 33; FPC zwr\u00f3ci c = 0 , tak samo jak * Mad-Pascal . STRINGI W PAMI\u0118CI writeln('ala','ma','kota'); writeln('ala','ma','psa'); Kompilator tylko raz od\u0142o\u017cy w pami\u0119ci ci\u0105gi znakowe ala , ma . Dzi\u0119ki rozbiciu d\u0142u\u017cszego stringa na mniejsze elementy mo\u017cemy oszcz\u0119dzi\u0107 pami\u0119\u0107. Je\u015bli zamienimy ci\u0105g znak\u00f3w na ich kody, w\u00f3wczas kompilator nie b\u0119dzie ich przechowywa\u0142 w obszarze sta\u0142ych. writeln('Atari'); writeln(#.#.#.#.#.#.#.#.); ZNAKI W PAMI\u0118CI writeln(#69,#82,#82,#32, a); Kody znak\u00f3w oddzielone przecinkiem nie zostan\u0105 potraktowane jako ci\u0105gi znakowe kt\u00f3re kompilator zapisuje do sta\u0142ych. OPTYMALIZACJA WYRA\u017bE\u0143 Nale\u017cy unika\u0107 \u0142\u0105czenia wyra\u017ce\u0144 z funkcjami, w takich przypadkach nie zadzia\u0142a optymalizacja kodu wynikowego, albo b\u0119dzie ona tylko cz\u0119\u015bciowa, np: function add(a,b: byte): byte; begin Result := a + b; end; function mul(a,b: byte): byte; begin Result := a * b; end; var x: byte; x := add(7,9) + mul(8,5); Najlepiej zastosowa\u0107 dodatkowe zmienne, w kt\u00f3rych zostanie zapisana warto\u015b\u0107 funkcji, np: var hlp1, hlp2: byte; hlp1 := add(7,9); hlp2 := mul(8,5); x := hlp1 + hlp2; WARUNKI var i: byte; var k: byte; var bol: Boolean; i:=0; k:=6; bol := i > 15 - (k * 3); Dla w/w warunku wyra\u017cenie po prawej stronie zostanie przekszta\u0142cone do typu ze znakiem, nast\u0119pnie lewa strona wyra\u017cenia zostanie sprowadzona do odpowiedniego typu ze znakiem. Wynikiem por\u00f3wnania b\u0119dzie TRUE ( 0 > -3 ). Je\u015bli zale\u017cy nam aby warto\u015bciowanie wyra\u017cenia by\u0142o przeprowadzone na typie BYTE musimy wymusi\u0107 to rzutowaniem, np: i:=0; k:=6; bol := i > byte(15 - (k * 3)); Teraz wynikiem b\u0119dzie FALSE ( 0 > 253 ). KR\u00d3TSZE WARUNKI BOOLEAN if spanbelow = true then ; mo\u017cna zast\u0105pi\u0107 if spanbelow then ; INFINITE LOOP Gdy assemblacja pliku *.a65 powoduje 'Infinite loop', plik OBX zostaje zapisany ale jest uszkodzony. Aby pozby\u0107 si\u0119 takiej sytuacja nale\u017cy ustawic sta\u0142y adres dla DATAORIGIN (-data:ADDRESS) USES Kolejno\u015b\u0107 modu\u0142\u00f3w na li\u015bcie USES mo\u017ce mie\u0107 znaczenie. DISPLAY LIST jako CONST, bo wtedy jest najbardziej na pocz\u0105tku pami\u0119ci programu (~$2000)","title":"Porady"},{"location":"porady/#_1","text":"","title":""},{"location":"porady/#for","text":"Warto\u015b\u0107 licznika po zako\u0144czeniu dzia\u0142ania instrukcji iteracyjnej FOR w FPC b\u0119dzie r\u00f3wna warto\u015bci jaka zosta\u0142a okre\u015blona dla maksymalnej warto\u015bci licznika. W przypadku Mad-Pascal warto\u015b\u0107 b\u0119dzie wi\u0119ksza o +1 . Przyk\u0142ad: for i:=0 to 10 do; FPC po zako\u0144czeniu petli i = 10 , Mad-Pascal i = 11","title":"FOR"},{"location":"porady/#shl","text":"FPC podaje inne wyniki dla SHL kt\u00f3re przekracza rozmiar danego typu, np.: i: byte; c: cardinal; i:=1; c:=i shl 33; Dla w/w przyk\u0142adu FPC zwr\u00f3ci warto\u015b\u0107 c = 2 , Mad-Pascal zwr\u00f3ci c = 0 . Natomiast dla: c:=1 shl 33; FPC zwr\u00f3ci c = 0 , tak samo jak * Mad-Pascal .","title":"SHL"},{"location":"porady/#stringi-w-pamieci","text":"writeln('ala','ma','kota'); writeln('ala','ma','psa'); Kompilator tylko raz od\u0142o\u017cy w pami\u0119ci ci\u0105gi znakowe ala , ma . Dzi\u0119ki rozbiciu d\u0142u\u017cszego stringa na mniejsze elementy mo\u017cemy oszcz\u0119dzi\u0107 pami\u0119\u0107. Je\u015bli zamienimy ci\u0105g znak\u00f3w na ich kody, w\u00f3wczas kompilator nie b\u0119dzie ich przechowywa\u0142 w obszarze sta\u0142ych. writeln('Atari'); writeln(#.#.#.#.#.#.#.#.);","title":"STRINGI W PAMI\u0118CI"},{"location":"porady/#znaki-w-pamieci","text":"writeln(#69,#82,#82,#32, a); Kody znak\u00f3w oddzielone przecinkiem nie zostan\u0105 potraktowane jako ci\u0105gi znakowe kt\u00f3re kompilator zapisuje do sta\u0142ych.","title":"ZNAKI W PAMI\u0118CI"},{"location":"porady/#optymalizacja-wyrazen","text":"Nale\u017cy unika\u0107 \u0142\u0105czenia wyra\u017ce\u0144 z funkcjami, w takich przypadkach nie zadzia\u0142a optymalizacja kodu wynikowego, albo b\u0119dzie ona tylko cz\u0119\u015bciowa, np: function add(a,b: byte): byte; begin Result := a + b; end; function mul(a,b: byte): byte; begin Result := a * b; end; var x: byte; x := add(7,9) + mul(8,5); Najlepiej zastosowa\u0107 dodatkowe zmienne, w kt\u00f3rych zostanie zapisana warto\u015b\u0107 funkcji, np: var hlp1, hlp2: byte; hlp1 := add(7,9); hlp2 := mul(8,5); x := hlp1 + hlp2;","title":"OPTYMALIZACJA WYRA\u017bE\u0143"},{"location":"porady/#warunki","text":"var i: byte; var k: byte; var bol: Boolean; i:=0; k:=6; bol := i > 15 - (k * 3); Dla w/w warunku wyra\u017cenie po prawej stronie zostanie przekszta\u0142cone do typu ze znakiem, nast\u0119pnie lewa strona wyra\u017cenia zostanie sprowadzona do odpowiedniego typu ze znakiem. Wynikiem por\u00f3wnania b\u0119dzie TRUE ( 0 > -3 ). Je\u015bli zale\u017cy nam aby warto\u015bciowanie wyra\u017cenia by\u0142o przeprowadzone na typie BYTE musimy wymusi\u0107 to rzutowaniem, np: i:=0; k:=6; bol := i > byte(15 - (k * 3)); Teraz wynikiem b\u0119dzie FALSE ( 0 > 253 ).","title":"WARUNKI"},{"location":"porady/#krotsze-warunki-boolean","text":"if spanbelow = true then ; mo\u017cna zast\u0105pi\u0107 if spanbelow then ;","title":"KR\u00d3TSZE WARUNKI BOOLEAN"},{"location":"porady/#infinite-loop","text":"Gdy assemblacja pliku *.a65 powoduje 'Infinite loop', plik OBX zostaje zapisany ale jest uszkodzony. Aby pozby\u0107 si\u0119 takiej sytuacja nale\u017cy ustawic sta\u0142y adres dla DATAORIGIN (-data:ADDRESS)","title":"INFINITE LOOP"},{"location":"porady/#uses","text":"Kolejno\u015b\u0107 modu\u0142\u00f3w na li\u015bcie USES mo\u017ce mie\u0107 znaczenie.","title":"USES"},{"location":"porady/#display-list","text":"jako CONST, bo wtedy jest najbardziej na pocz\u0105tku pami\u0119ci programu (~$2000)","title":"DISPLAY LIST"},{"location":"procedury-funkcje/","text":"Procedury Mad-Pascal pozwala na przekazanie do procedury maksymalnie 8 parametr\u00f3w. Dost\u0119pne s\u0105 trzy sposoby przekazywania parametr\u00f3w: przez warto\u015b\u0107, sta\u0142\u0105 CONST i referencj\u0119 VAR . Parametry procedur odczytywane s\u0105 i warto\u015bciowane od prawej do lewej strony tests\\tests-medium\\function_valuation_of_arguments.pas Mo\u017cliwe jest zagnie\u017cd\u017canie procedur. Mo\u017cliwa jest rekurencja procedur, pod warunkiem \u017ce parametry procedury b\u0119d\u0105 przekazywane przez warto\u015b\u0107, b\u0119d\u0105 typu prostego - porz\u0105dkowego. Typ rekordowy, wska\u017anikowy nie b\u0119dzie w\u0142a\u015bciwie alokowany w pami\u0119ci. Je\u015bli jest to mo\u017cliwe kompilator przekazuje parametry do procedury poprzez zmienne z pomini\u0119ciem stosu programowego. Funkcje Mad-Pascal pozwala na przekazanie do funkcji maksymalnie 8 parametr\u00f3w. Dost\u0119pne s\u0105 trzy sposoby przekazywania parametr\u00f3w: przez warto\u015b\u0107, sta\u0142\u0105 CONST i referencj\u0119 VAR . Wynik funkcji zwracamy przypisuj\u0105c go do nazwy funkcji lub korzystaj\u0105c z automatycznie deklarowanej zmiennej RESULT , np.: function add(a,b: word): cardinal; begin Result := a+b; end; function mul(a,b: word): cardinal; begin mul := a*b; end; U\u017cywanie modyfikatora INTERRUPT nie jest zalecane. Parametry funkcji odczytywane s\u0105 i warto\u015bciowane od prawej do lewej strony tests\\tests-medium\\function_valuation_of_arguments.pas Mo\u017cliwe jest zagnie\u017cd\u017canie funkcji. Mo\u017cliwa jest rekurencja funkcji, pod warunkiem, \u017ce parametry funkcji b\u0119d\u0105 przekazywane przez warto\u015b\u0107, b\u0119d\u0105 typu prostego - porz\u0105dkowego. Typ rekordowy, wska\u017anikowy nie b\u0119dzie w\u0142a\u015bciwie alokowany w pami\u0119ci. Je\u015bli jest to mo\u017cliwe kompilator przekazuje parametry do funkcji poprzez zmienne z pomini\u0119ciem stosu programowego. Przekazywanie parametr\u00f3w Mo\u017cna przekazywa\u0107 do 8 parametr\u00f3w do funkcji lub procedury. Oddziela si\u0119 je \u015brednikami. Ka\u017cdy z parametr\u00f3w ma w\u0142asny typ. Zmienne podawane zazwyczaj w parametrach s\u0105 kopiowane w inny obszar pami\u0119ci i w\u0142a\u015bnie do tego obszaru ma dost\u0119p programista. Kompilator Mad Pascala wykonuje kopi\u0119 parametr\u00f3w, nie nale\u017cy przekazywa\u0107 zbyt du\u017cej ilo\u015bci danych, by nie spowolni\u0107 dzia\u0142ania programu. Zaleca si\u0119 przekazywa\u0107 do czterech bajt\u00f3w. Przekazywanie przez warto\u015b\u0107 Przekazywanie parametr\u00f3w przez warto\u015b\u0107 jest sposobem najprostszym z mo\u017cliwych. Deklaracja procedury nie musi zawiera\u0107 \u017cadnych dodatkowych s\u0142\u00f3w kluczowych - wystarczy poni\u017csza konstrukcja nag\u0142\u00f3wka procedury b\u0105d\u017a funkcji: procedure Foo(S : String); Przekazanie parametru przez warto\u015b\u0107 wi\u0105\u017ce si\u0119 utworzeniem jego kopii lokalnej do wykorzystania jedynie przez procedur\u0119 lub funkcj\u0119. Oryginalna warto\u015b\u0107 zmiennej przekazanej do procedury nie zostaje w \u017caden spos\u00f3b naruszona. Przekazywanie przez sta\u0142\u0105 Umieszczenie w deklaracji parametr\u00f3w s\u0142owa kluczowego CONST spowoduje przekazywanie parametr\u00f3w jako sta\u0142ych. procedure Show(const Message : String); begin Writeln(Message); end; Procedura nie mo\u017ce w \u017caden spos\u00f3b wp\u0142ywa\u0107 na zawarto\u015b\u0107 parametru. Pr\u00f3ba nadania przez procedur\u0119 jakiej\u015b warto\u015bci spowoduje komunikat o b\u0142\u0119dzie: Can't assign values to const variable , nie mo\u017cna wi\u0119c zapisa\u0107 tego w ten spos\u00f3b: procedure Show(const Message : String); begin Message := 'Nowa warto\u015b\u0107'; Writeln(Message); end; Obecnie kompilator MP odk\u0142ada takie parametry w pami\u0119ci podobnie jak w przypadku przekazywania przez warto\u015b\u0107, docelowo powinien tylko przez wska\u017anik. Przekazywanie przez referencj\u0119 Przekazywanie parametr\u00f3w przez referencj\u0119 polega na umieszczeniu przed parametrami s\u0142owa kluczowego VAR . Dzi\u0119ki temu kod znajduj\u0105cy si\u0119 wewn\u0105trz procedury mo\u017ce zmieni\u0107 warto\u015b\u0107 parametru. Spos\u00f3b przekazywania danych przez referencj\u0119 jest optymalny, gdy\u017c nie jest tworzona kopia zmiennej. W zwi\u0105zku z tym jest mo\u017cliwe przekazywanie danych z procedury na zewn\u0105trz. uses crt; procedure SetValue(var a,b,c,d: byte); begin { pr\u00f3ba nadania nowej warto\u015bci dla parametru } a := a + 2; b := a + 3; c := b + 4; d := c + 5; end; var a,b,c,d: byte; begin a:=3; SetValue(a,b,c,d); writeln(a); // 5 writeln(b); // 8 writeln(c); // 12 writeln(d); // 17 repeat until keypressed; end. Parametry bez typu MP pozwala deklarowa\u0107 parametry procedur i funkcji, kt\u00f3re nie posiadaj\u0105 typu. W takim wypadku, nazwy parametr\u00f3w musz\u0105 by\u0107 poprzedzone s\u0142owem kluczowym VAR . Dost\u0119p do warto\u015bci takich parametr\u00f3w musi odbywa\u0107 si\u0119 poprzez rzutowanie. var w: cardinal; procedure doit(var d); begin Writeln('As integer: ',PInteger(@D)^); Writeln('As Byte : ',PByte(@D)^); end; begin w:=31411; doit(w); end. >> 31411 >> 179 Przekazywanie parametru przez wska\u017anik, zale\u017cnie od typu takiego wska\u017anika: var pn: pointer; tb: array [0..0] of byte; procedure doit(var a); overload; begin writeln('VAR',',',cardinal(@a)); end; procedure doit(var a: pointer); overload; begin writeln('VAR POINTER',',',cardinal(a)); end; begin pn:=@tb; doit(tb); // VAR doit(pn); // VAR POINTER end. Odczyt pliku pod adres wskazany przez wska\u017anik: procedure BlockRead(var f: file; var Buf; count: word; var Result: word); var pn: pointer; f: file; begin InitGraph(15+16); pn:=pointer(dpeek(88)); assign(f, 'FILENAME'); reset(f, 1); blockread(f, pn^, 192*40); close(f); end. Odczyt pliku pod adres wskazany przez tablic\u0119: var bf: array [0..0] of byte; f: file; begin InitGraph(15+16); bf:=pointer(dpeek(88)); assign(f, 'FILENAME'); reset(f, 1); blockread(f, bf, 192*40); close(f); end. Tablice otwarte Obecnie kompilator MP nie wspiera tablic otwartych ani nie pozwala na przekazywanie tablic otwartych jako parametru. function Foo(const A : array of const) : String; ShowMessage(Foo(['test', 10, ' ', 'mama', 1000])); function Foo(const A : array of const) : String; var i : Integer; begin for I := 0 to High(A) do begin case A[i].VType of vtInteger: Result := Result + IntToStr(A[i].VInteger); vtChar: Result := Result + A[i].VChar; vtString: Result := Result + A[i].VString^; vtAnsiString: Result := Result + String(A[i].VAnsiString); vtVariant: Result := Result + String(A[i].VVariant^); { itd. } end; end; end; Procedury zagnie\u017cd\u017cone Nic nie stoi na przeszkodzie, aby dan\u0105 procedur\u0119 lub funkcj\u0119 umie\u015bci\u0107 w innej procedurze lub funkcji. procedure A; procedure B; begin end; begin end; Z powy\u017cszego zapisu wynika, \u017ce procedura lub funkcja zagnie\u017cd\u017cona (w tym wypadku procedura B ) musi zosta\u0107 umieszczona przed blokiem BEGIN . W takim przypadku nadal obowi\u0105zuj\u0105 zasady o zmiennych lokalnych. Oznacza to, \u017ce zmienna umieszczona w procedurze B nie b\u0119dzie dost\u0119pna dla procedury A . Przy zastosowaniu procedur zagnie\u017cd\u017conych obowi\u0105zuj\u0105 r\u00f3wnie\u017c inne zasady. Procedura zewn\u0119trzna do A nie ma dost\u0119pu do procedury B , procedura B ma dost\u0119p do parametr\u00f3w wywo\u0142ania procedury A . program nested; function E(x: byte): byte; function F(y: byte): byte; begin F := x + y end; begin Result := F(3) + F(2) end; begin writeln(E(1)); while true do; end. W powy\u017cszym przyk\u0142adzie, zmienne X , Y s\u0105 dost\u0119pne w funkcji F , natomiast dla funkcji E dost\u0119pna jest tylko zmienna X . Procedury i funkcje zagnie\u017cd\u017cone mog\u0105 okaza\u0107 si\u0119 przydatne, gdy do realizacji jednej funkcji przydatna lub wymagana jest inna procedura lub funkcja, kt\u00f3ra, z punktu widzenia innych procedur lub funkcji danego modu\u0142u, jest zb\u0119dna. Jednocze\u015bnie warto przypomnie\u0107, \u017ce zagnie\u017cd\u017cenie pozwala na wywo\u0142ywanie bez przekazywania parametr\u00f3w z funkcji nadrz\u0119dnej. Modyfikatory assembler Procedury/Funkcje oznaczona przez ASSEMBLER mog\u0105 sk\u0142ada\u0107 si\u0119 tylko z bloku ASM . Kompilator nie dokonuje analizy sk\u0142adni takich blok\u00f3w, traktuje je jak komentarz, ewentualne b\u0142\u0119dy zostan\u0105 wychwycone dopiero podczas asemblacji. UWAGA: Wymagane jest aby zachowa\u0107 stan rejestru X CPU6502 , kt\u00f3ry u\u017cywany jest do obs\u0142ugi stosu programowego Mad-Pascal . Kompilator dopuszcza dwie sk\u0142adnie bloku ASM , z klamrami { } jak dla komentarza i standardow\u0105 bez klamer. ASM lda #10 sta 712 END; ASM { lda #10 sta 712 }; procedure name; assembler; asm lda #10 sta 712 end; procedure name; assembler; asm { lda #10 sta 712 }; end; overload Procedury/Funkcje przeci\u0105\u017cone rozpoznawane s\u0105 na podstawie listy parametr\u00f3w. procedure suma(var i: integer; a,b: integer); overload; begin i := a+b; end; procedure suma(var i: integer; a,b,c: integer); overload; begin i := a+b+c; end; function fsuma(a,b: word): cardinal; assembler; overload; asm { adw a b result }; end; function fsuma(a,b: real): real; overload; begin Result := a+b; end; Przy przekazywaniu parametr\u00f3w do procedury/funkcji nale\u017cy pami\u0119ta\u0107 \u017ce Mad Pascal rozszerza typ obliczanych wyra\u017ce\u0144, dlatego je\u015bli zale\u017cy nam na okre\u015blonym typie powinni\u015bmy dokona\u0107 rzutowania. procedure tst(a,b: shortint); overload; begin writeln('shortint'); end; procedure tst(a,b: smallint); overload; begin writeln('smallint'); end; procedure tst(a,b: integer); overload; begin writeln('integer'); end; dla a,b = shortint tst(a,b) -> wybierze shortint tst(a+1,b) -> wybierze integer tst(smallint(a+1),b) -> wybierze smallint forward Je\u017celi chcemy aby procedura/funkcja by\u0142a zadeklarowana za miejscem jej pierwszego wywo\u0142ania, nale\u017cy u\u017cy\u0107 modyfikator FORWARD . procedure nazwa [(lista-parametr\u00f3w-formalnych)]; forward; ... ... ... procedure nazwa; begin end; register U\u017cycie modyfikatora REGISTER spowoduje, \u017ce trzy pierwsze parametry formalne procedury/funkcji b\u0119d\u0105 umieszczone na stronie zerowej, w 32-bitowych rejestrach programowych, odpowiednio EDX , ECX , EAX . procedure nazwa (a,b,c: cardinal); register; // a = edx // b = ecx // c = eax W przypadku funkcji, zmienna RESULT przechowuj\u0105ca warto\u015b\u0107 funkcji alokowana jest na stronie zerowej pod adresem :STACKORIGIN-4 kt\u00f3ry odpowiada bezpo\u015brednio zmiennej :TMP function nazwa (a,b,c: cardinal): cardinal; register; // a = edx // b = ecx // c = eax // Result = :STACKORIGIN-4 (:TMP) Je\u015bli w ciele procedury/funkcji wyst\u0119puj\u0105 operacje mno\u017cenia/dzielenia, albo operacje na tablicach dwu-wymiarowych w\u00f3wczas rejestry EDX , ECX , EAX mog\u0105 ulec zniszczeniu co spowoduje \"niespodziewane\" rezultaty. interrupt Procedury/Funkcje oznaczone przez INTERRUPT kompilator b\u0119dzie ko\u0144czy\u0142 rozkazem RTI (standardowo RTS ). Niezale\u017cnie czy w programie wyst\u0105pi wywo\u0142anie takiej procedury/funkcji kompilator zawsze wygeneruje dla niej kod. Na wej\u015bciu procedury/funkcji oznaczonej przez INTERRUPT programista musi zadba\u0107 o zachowanie rejestr\u00f3w CPU A X Y , na wyj\u015bciu o przywr\u00f3cenie stanu takich rejestr\u00f3w, kompilator ogranicza si\u0119 tylko do wstawienia ko\u0144cowego rozkazu RTI . Kompilator zg\u0142osi b\u0142\u0105d je\u015bli w takiej procedurze/funkcji wyst\u0105pi\u0105 rozkazy assemblera odwo\u0142uj\u0105ce si\u0119 do zmiennych :BP , :BP2 lub :STACKORIGIN . procedure dli; interrupt; assembler; asm pha lda #$c8 sta wsync sta $d01a pla end; // rozkaz RTI zostanie wstawiony automatycznie keep U\u017cycie modyfikator KEEP spowoduje \u017ce tak oznaczona procedura/funkcja zostanie zawsze skompilowana niezale\u017cnie czy wyst\u0105pi\u0142o, czy nie wyst\u0105pi\u0142o odwo\u0142anie w programie do takiej procedury/funkcji . pascal U\u017cycie modyfikatora PASCAL spowoduje, \u017ce procedura/funkcja b\u0119dzie traktowana jako rekurencyjna. Standardowo kompilator automatycznie wykrywa rekurencj\u0119, ale mog\u0105 zdarzy\u0107 si\u0119 sytuacje dla kt\u00f3rych b\u0119dzie to niemo\u017cliwe. Przyk\u0142ad samples/math/evaluate.pas stdcall U\u017cycie modyfikatora STDCALL spowoduje wymuszenie przekazywania parametr\u00f3w do procedury/funkcji poprzez stos programowy. Domy\u015blnie kompilator stara si\u0119 przekazywa\u0107 parametry przez zmienne, bez udzia\u0142u stosu programowego. inline Procedura, funkcja zostaje zamieniona na makro Mad Assemblera , pozbywamy si\u0119 wywo\u0142a\u0144 z udzia\u0142em rozkazu JSR . Nie ma mo\u017cliwo\u015bci u\u017cywania rekurencji dla takich procedur/funkcji . external Modyfikator EXTERNAL informuje kompilator \u017ce procedura/funkcja zostanie dolinkowana {$LINK filename} na etapie assemblacji. Przyk\u0142ad kilku procedur, kt\u00f3re zostan\u0105 dolinkowane do programu w Pascalu (procedura z 1 argumentem typu BYTE jest wyj\u0105tkiem, taki argument przekazywany jest przez rejestr akumulatora) .public proc1, proc2, proc3 .reloc .proc proc1 (.byte a) .reg rts .endp .proc proc2 (.word tmp) .var rts tmp dta a(0) .endp .proc proc3 (.byte x,y,z) .var rts x brk y brk z brk .endp Przyk\u0142ad wykorzystania w Pascalu procedure proc1 (a: byte); external; procedure proc2 (a: word); external; procedure proc3 (a,b,c: byte); external; {$link filename.obx}","title":"Procedur, funkcje, modyfikatory"},{"location":"procedury-funkcje/#_1","text":"","title":""},{"location":"procedury-funkcje/#procedury","text":"Mad-Pascal pozwala na przekazanie do procedury maksymalnie 8 parametr\u00f3w. Dost\u0119pne s\u0105 trzy sposoby przekazywania parametr\u00f3w: przez warto\u015b\u0107, sta\u0142\u0105 CONST i referencj\u0119 VAR . Parametry procedur odczytywane s\u0105 i warto\u015bciowane od prawej do lewej strony tests\\tests-medium\\function_valuation_of_arguments.pas Mo\u017cliwe jest zagnie\u017cd\u017canie procedur. Mo\u017cliwa jest rekurencja procedur, pod warunkiem \u017ce parametry procedury b\u0119d\u0105 przekazywane przez warto\u015b\u0107, b\u0119d\u0105 typu prostego - porz\u0105dkowego. Typ rekordowy, wska\u017anikowy nie b\u0119dzie w\u0142a\u015bciwie alokowany w pami\u0119ci. Je\u015bli jest to mo\u017cliwe kompilator przekazuje parametry do procedury poprzez zmienne z pomini\u0119ciem stosu programowego.","title":"Procedury"},{"location":"procedury-funkcje/#funkcje","text":"Mad-Pascal pozwala na przekazanie do funkcji maksymalnie 8 parametr\u00f3w. Dost\u0119pne s\u0105 trzy sposoby przekazywania parametr\u00f3w: przez warto\u015b\u0107, sta\u0142\u0105 CONST i referencj\u0119 VAR . Wynik funkcji zwracamy przypisuj\u0105c go do nazwy funkcji lub korzystaj\u0105c z automatycznie deklarowanej zmiennej RESULT , np.: function add(a,b: word): cardinal; begin Result := a+b; end; function mul(a,b: word): cardinal; begin mul := a*b; end; U\u017cywanie modyfikatora INTERRUPT nie jest zalecane. Parametry funkcji odczytywane s\u0105 i warto\u015bciowane od prawej do lewej strony tests\\tests-medium\\function_valuation_of_arguments.pas Mo\u017cliwe jest zagnie\u017cd\u017canie funkcji. Mo\u017cliwa jest rekurencja funkcji, pod warunkiem, \u017ce parametry funkcji b\u0119d\u0105 przekazywane przez warto\u015b\u0107, b\u0119d\u0105 typu prostego - porz\u0105dkowego. Typ rekordowy, wska\u017anikowy nie b\u0119dzie w\u0142a\u015bciwie alokowany w pami\u0119ci. Je\u015bli jest to mo\u017cliwe kompilator przekazuje parametry do funkcji poprzez zmienne z pomini\u0119ciem stosu programowego.","title":"Funkcje"},{"location":"procedury-funkcje/#przekazywanie-parametrow","text":"Mo\u017cna przekazywa\u0107 do 8 parametr\u00f3w do funkcji lub procedury. Oddziela si\u0119 je \u015brednikami. Ka\u017cdy z parametr\u00f3w ma w\u0142asny typ. Zmienne podawane zazwyczaj w parametrach s\u0105 kopiowane w inny obszar pami\u0119ci i w\u0142a\u015bnie do tego obszaru ma dost\u0119p programista. Kompilator Mad Pascala wykonuje kopi\u0119 parametr\u00f3w, nie nale\u017cy przekazywa\u0107 zbyt du\u017cej ilo\u015bci danych, by nie spowolni\u0107 dzia\u0142ania programu. Zaleca si\u0119 przekazywa\u0107 do czterech bajt\u00f3w.","title":"Przekazywanie parametr\u00f3w"},{"location":"procedury-funkcje/#przekazywanie-przez-wartosc","text":"Przekazywanie parametr\u00f3w przez warto\u015b\u0107 jest sposobem najprostszym z mo\u017cliwych. Deklaracja procedury nie musi zawiera\u0107 \u017cadnych dodatkowych s\u0142\u00f3w kluczowych - wystarczy poni\u017csza konstrukcja nag\u0142\u00f3wka procedury b\u0105d\u017a funkcji: procedure Foo(S : String); Przekazanie parametru przez warto\u015b\u0107 wi\u0105\u017ce si\u0119 utworzeniem jego kopii lokalnej do wykorzystania jedynie przez procedur\u0119 lub funkcj\u0119. Oryginalna warto\u015b\u0107 zmiennej przekazanej do procedury nie zostaje w \u017caden spos\u00f3b naruszona.","title":"Przekazywanie przez warto\u015b\u0107"},{"location":"procedury-funkcje/#przekazywanie-przez-staa","text":"Umieszczenie w deklaracji parametr\u00f3w s\u0142owa kluczowego CONST spowoduje przekazywanie parametr\u00f3w jako sta\u0142ych. procedure Show(const Message : String); begin Writeln(Message); end; Procedura nie mo\u017ce w \u017caden spos\u00f3b wp\u0142ywa\u0107 na zawarto\u015b\u0107 parametru. Pr\u00f3ba nadania przez procedur\u0119 jakiej\u015b warto\u015bci spowoduje komunikat o b\u0142\u0119dzie: Can't assign values to const variable , nie mo\u017cna wi\u0119c zapisa\u0107 tego w ten spos\u00f3b: procedure Show(const Message : String); begin Message := 'Nowa warto\u015b\u0107'; Writeln(Message); end; Obecnie kompilator MP odk\u0142ada takie parametry w pami\u0119ci podobnie jak w przypadku przekazywania przez warto\u015b\u0107, docelowo powinien tylko przez wska\u017anik.","title":"Przekazywanie przez sta\u0142\u0105"},{"location":"procedury-funkcje/#przekazywanie-przez-referencje","text":"Przekazywanie parametr\u00f3w przez referencj\u0119 polega na umieszczeniu przed parametrami s\u0142owa kluczowego VAR . Dzi\u0119ki temu kod znajduj\u0105cy si\u0119 wewn\u0105trz procedury mo\u017ce zmieni\u0107 warto\u015b\u0107 parametru. Spos\u00f3b przekazywania danych przez referencj\u0119 jest optymalny, gdy\u017c nie jest tworzona kopia zmiennej. W zwi\u0105zku z tym jest mo\u017cliwe przekazywanie danych z procedury na zewn\u0105trz. uses crt; procedure SetValue(var a,b,c,d: byte); begin { pr\u00f3ba nadania nowej warto\u015bci dla parametru } a := a + 2; b := a + 3; c := b + 4; d := c + 5; end; var a,b,c,d: byte; begin a:=3; SetValue(a,b,c,d); writeln(a); // 5 writeln(b); // 8 writeln(c); // 12 writeln(d); // 17 repeat until keypressed; end.","title":"Przekazywanie przez referencj\u0119"},{"location":"procedury-funkcje/#parametry-bez-typu","text":"MP pozwala deklarowa\u0107 parametry procedur i funkcji, kt\u00f3re nie posiadaj\u0105 typu. W takim wypadku, nazwy parametr\u00f3w musz\u0105 by\u0107 poprzedzone s\u0142owem kluczowym VAR . Dost\u0119p do warto\u015bci takich parametr\u00f3w musi odbywa\u0107 si\u0119 poprzez rzutowanie. var w: cardinal; procedure doit(var d); begin Writeln('As integer: ',PInteger(@D)^); Writeln('As Byte : ',PByte(@D)^); end; begin w:=31411; doit(w); end. >> 31411 >> 179 Przekazywanie parametru przez wska\u017anik, zale\u017cnie od typu takiego wska\u017anika: var pn: pointer; tb: array [0..0] of byte; procedure doit(var a); overload; begin writeln('VAR',',',cardinal(@a)); end; procedure doit(var a: pointer); overload; begin writeln('VAR POINTER',',',cardinal(a)); end; begin pn:=@tb; doit(tb); // VAR doit(pn); // VAR POINTER end. Odczyt pliku pod adres wskazany przez wska\u017anik: procedure BlockRead(var f: file; var Buf; count: word; var Result: word); var pn: pointer; f: file; begin InitGraph(15+16); pn:=pointer(dpeek(88)); assign(f, 'FILENAME'); reset(f, 1); blockread(f, pn^, 192*40); close(f); end. Odczyt pliku pod adres wskazany przez tablic\u0119: var bf: array [0..0] of byte; f: file; begin InitGraph(15+16); bf:=pointer(dpeek(88)); assign(f, 'FILENAME'); reset(f, 1); blockread(f, bf, 192*40); close(f); end.","title":"Parametry bez typu"},{"location":"procedury-funkcje/#tablice-otwarte","text":"Obecnie kompilator MP nie wspiera tablic otwartych ani nie pozwala na przekazywanie tablic otwartych jako parametru. function Foo(const A : array of const) : String; ShowMessage(Foo(['test', 10, ' ', 'mama', 1000])); function Foo(const A : array of const) : String; var i : Integer; begin for I := 0 to High(A) do begin case A[i].VType of vtInteger: Result := Result + IntToStr(A[i].VInteger); vtChar: Result := Result + A[i].VChar; vtString: Result := Result + A[i].VString^; vtAnsiString: Result := Result + String(A[i].VAnsiString); vtVariant: Result := Result + String(A[i].VVariant^); { itd. } end; end; end;","title":"Tablice otwarte"},{"location":"procedury-funkcje/#procedury-zagniezdzone","text":"Nic nie stoi na przeszkodzie, aby dan\u0105 procedur\u0119 lub funkcj\u0119 umie\u015bci\u0107 w innej procedurze lub funkcji. procedure A; procedure B; begin end; begin end; Z powy\u017cszego zapisu wynika, \u017ce procedura lub funkcja zagnie\u017cd\u017cona (w tym wypadku procedura B ) musi zosta\u0107 umieszczona przed blokiem BEGIN . W takim przypadku nadal obowi\u0105zuj\u0105 zasady o zmiennych lokalnych. Oznacza to, \u017ce zmienna umieszczona w procedurze B nie b\u0119dzie dost\u0119pna dla procedury A . Przy zastosowaniu procedur zagnie\u017cd\u017conych obowi\u0105zuj\u0105 r\u00f3wnie\u017c inne zasady. Procedura zewn\u0119trzna do A nie ma dost\u0119pu do procedury B , procedura B ma dost\u0119p do parametr\u00f3w wywo\u0142ania procedury A . program nested; function E(x: byte): byte; function F(y: byte): byte; begin F := x + y end; begin Result := F(3) + F(2) end; begin writeln(E(1)); while true do; end. W powy\u017cszym przyk\u0142adzie, zmienne X , Y s\u0105 dost\u0119pne w funkcji F , natomiast dla funkcji E dost\u0119pna jest tylko zmienna X . Procedury i funkcje zagnie\u017cd\u017cone mog\u0105 okaza\u0107 si\u0119 przydatne, gdy do realizacji jednej funkcji przydatna lub wymagana jest inna procedura lub funkcja, kt\u00f3ra, z punktu widzenia innych procedur lub funkcji danego modu\u0142u, jest zb\u0119dna. Jednocze\u015bnie warto przypomnie\u0107, \u017ce zagnie\u017cd\u017cenie pozwala na wywo\u0142ywanie bez przekazywania parametr\u00f3w z funkcji nadrz\u0119dnej.","title":"Procedury zagnie\u017cd\u017cone"},{"location":"procedury-funkcje/#modyfikatory","text":"","title":"Modyfikatory"},{"location":"procedury-funkcje/#assembler","text":"Procedury/Funkcje oznaczona przez ASSEMBLER mog\u0105 sk\u0142ada\u0107 si\u0119 tylko z bloku ASM . Kompilator nie dokonuje analizy sk\u0142adni takich blok\u00f3w, traktuje je jak komentarz, ewentualne b\u0142\u0119dy zostan\u0105 wychwycone dopiero podczas asemblacji. UWAGA: Wymagane jest aby zachowa\u0107 stan rejestru X CPU6502 , kt\u00f3ry u\u017cywany jest do obs\u0142ugi stosu programowego Mad-Pascal . Kompilator dopuszcza dwie sk\u0142adnie bloku ASM , z klamrami { } jak dla komentarza i standardow\u0105 bez klamer. ASM lda #10 sta 712 END; ASM { lda #10 sta 712 }; procedure name; assembler; asm lda #10 sta 712 end; procedure name; assembler; asm { lda #10 sta 712 }; end;","title":"assembler"},{"location":"procedury-funkcje/#overload","text":"Procedury/Funkcje przeci\u0105\u017cone rozpoznawane s\u0105 na podstawie listy parametr\u00f3w. procedure suma(var i: integer; a,b: integer); overload; begin i := a+b; end; procedure suma(var i: integer; a,b,c: integer); overload; begin i := a+b+c; end; function fsuma(a,b: word): cardinal; assembler; overload; asm { adw a b result }; end; function fsuma(a,b: real): real; overload; begin Result := a+b; end; Przy przekazywaniu parametr\u00f3w do procedury/funkcji nale\u017cy pami\u0119ta\u0107 \u017ce Mad Pascal rozszerza typ obliczanych wyra\u017ce\u0144, dlatego je\u015bli zale\u017cy nam na okre\u015blonym typie powinni\u015bmy dokona\u0107 rzutowania. procedure tst(a,b: shortint); overload; begin writeln('shortint'); end; procedure tst(a,b: smallint); overload; begin writeln('smallint'); end; procedure tst(a,b: integer); overload; begin writeln('integer'); end; dla a,b = shortint tst(a,b) -> wybierze shortint tst(a+1,b) -> wybierze integer tst(smallint(a+1),b) -> wybierze smallint","title":"overload"},{"location":"procedury-funkcje/#forward","text":"Je\u017celi chcemy aby procedura/funkcja by\u0142a zadeklarowana za miejscem jej pierwszego wywo\u0142ania, nale\u017cy u\u017cy\u0107 modyfikator FORWARD . procedure nazwa [(lista-parametr\u00f3w-formalnych)]; forward; ... ... ... procedure nazwa; begin end;","title":"forward"},{"location":"procedury-funkcje/#register","text":"U\u017cycie modyfikatora REGISTER spowoduje, \u017ce trzy pierwsze parametry formalne procedury/funkcji b\u0119d\u0105 umieszczone na stronie zerowej, w 32-bitowych rejestrach programowych, odpowiednio EDX , ECX , EAX . procedure nazwa (a,b,c: cardinal); register; // a = edx // b = ecx // c = eax W przypadku funkcji, zmienna RESULT przechowuj\u0105ca warto\u015b\u0107 funkcji alokowana jest na stronie zerowej pod adresem :STACKORIGIN-4 kt\u00f3ry odpowiada bezpo\u015brednio zmiennej :TMP function nazwa (a,b,c: cardinal): cardinal; register; // a = edx // b = ecx // c = eax // Result = :STACKORIGIN-4 (:TMP) Je\u015bli w ciele procedury/funkcji wyst\u0119puj\u0105 operacje mno\u017cenia/dzielenia, albo operacje na tablicach dwu-wymiarowych w\u00f3wczas rejestry EDX , ECX , EAX mog\u0105 ulec zniszczeniu co spowoduje \"niespodziewane\" rezultaty.","title":"register"},{"location":"procedury-funkcje/#interrupt","text":"Procedury/Funkcje oznaczone przez INTERRUPT kompilator b\u0119dzie ko\u0144czy\u0142 rozkazem RTI (standardowo RTS ). Niezale\u017cnie czy w programie wyst\u0105pi wywo\u0142anie takiej procedury/funkcji kompilator zawsze wygeneruje dla niej kod. Na wej\u015bciu procedury/funkcji oznaczonej przez INTERRUPT programista musi zadba\u0107 o zachowanie rejestr\u00f3w CPU A X Y , na wyj\u015bciu o przywr\u00f3cenie stanu takich rejestr\u00f3w, kompilator ogranicza si\u0119 tylko do wstawienia ko\u0144cowego rozkazu RTI . Kompilator zg\u0142osi b\u0142\u0105d je\u015bli w takiej procedurze/funkcji wyst\u0105pi\u0105 rozkazy assemblera odwo\u0142uj\u0105ce si\u0119 do zmiennych :BP , :BP2 lub :STACKORIGIN . procedure dli; interrupt; assembler; asm pha lda #$c8 sta wsync sta $d01a pla end; // rozkaz RTI zostanie wstawiony automatycznie","title":"interrupt"},{"location":"procedury-funkcje/#keep","text":"U\u017cycie modyfikator KEEP spowoduje \u017ce tak oznaczona procedura/funkcja zostanie zawsze skompilowana niezale\u017cnie czy wyst\u0105pi\u0142o, czy nie wyst\u0105pi\u0142o odwo\u0142anie w programie do takiej procedury/funkcji .","title":"keep"},{"location":"procedury-funkcje/#pascal","text":"U\u017cycie modyfikatora PASCAL spowoduje, \u017ce procedura/funkcja b\u0119dzie traktowana jako rekurencyjna. Standardowo kompilator automatycznie wykrywa rekurencj\u0119, ale mog\u0105 zdarzy\u0107 si\u0119 sytuacje dla kt\u00f3rych b\u0119dzie to niemo\u017cliwe. Przyk\u0142ad samples/math/evaluate.pas","title":"pascal"},{"location":"procedury-funkcje/#stdcall","text":"U\u017cycie modyfikatora STDCALL spowoduje wymuszenie przekazywania parametr\u00f3w do procedury/funkcji poprzez stos programowy. Domy\u015blnie kompilator stara si\u0119 przekazywa\u0107 parametry przez zmienne, bez udzia\u0142u stosu programowego.","title":"stdcall"},{"location":"procedury-funkcje/#inline","text":"Procedura, funkcja zostaje zamieniona na makro Mad Assemblera , pozbywamy si\u0119 wywo\u0142a\u0144 z udzia\u0142em rozkazu JSR . Nie ma mo\u017cliwo\u015bci u\u017cywania rekurencji dla takich procedur/funkcji .","title":"inline"},{"location":"procedury-funkcje/#external","text":"Modyfikator EXTERNAL informuje kompilator \u017ce procedura/funkcja zostanie dolinkowana {$LINK filename} na etapie assemblacji. Przyk\u0142ad kilku procedur, kt\u00f3re zostan\u0105 dolinkowane do programu w Pascalu (procedura z 1 argumentem typu BYTE jest wyj\u0105tkiem, taki argument przekazywany jest przez rejestr akumulatora) .public proc1, proc2, proc3 .reloc .proc proc1 (.byte a) .reg rts .endp .proc proc2 (.word tmp) .var rts tmp dta a(0) .endp .proc proc3 (.byte x,y,z) .var rts x brk y brk z brk .endp Przyk\u0142ad wykorzystania w Pascalu procedure proc1 (a: byte); external; procedure proc2 (a: word); external; procedure proc3 (a,b,c: byte); external; {$link filename.obx}","title":"external"},{"location":"projekty/","text":"Benchmark Suite autor: zbyti platforma: A8 \u017ar\u00f3d\u0142a Star Vagrant autor: MADRAFi platforma: A8 strona domowa \u017ar\u00f3d\u0142a Stary Dom autor: bocianu platforma: A8 strona domowa \u017ar\u00f3d\u0142a Pac Mad autor: bocianu platforma: A8 strona domowa \u017ar\u00f3d\u0142a Flob autor: bocianu platforma: A8 strona domowa \u017ar\u00f3d\u0142a","title":"Projekty"},{"location":"projekty/#_1","text":"","title":""},{"location":"projekty/#benchmark-suite","text":"autor: zbyti platforma: A8 \u017ar\u00f3d\u0142a","title":"Benchmark Suite"},{"location":"projekty/#star-vagrant","text":"autor: MADRAFi platforma: A8 strona domowa \u017ar\u00f3d\u0142a","title":"Star Vagrant"},{"location":"projekty/#stary-dom","text":"autor: bocianu platforma: A8 strona domowa \u017ar\u00f3d\u0142a","title":"Stary Dom"},{"location":"projekty/#pac-mad","text":"autor: bocianu platforma: A8 strona domowa \u017ar\u00f3d\u0142a","title":"Pac Mad"},{"location":"projekty/#flob","text":"autor: bocianu platforma: A8 strona domowa \u017ar\u00f3d\u0142a","title":"Flob"},{"location":"przerwania/","text":"VBL, DLI Do obs\u0142ugi przerwa\u0144 VBLD , VBLI , DLI dedykowane s\u0105 dwie procedury GetIntVec oraz SetIntVec . Do prawid\u0142owego dzia\u0142ania wymagana jest obecno\u015b\u0107 OS-a (wy\u0142\u0105czenie ROM tylko przez $DEFINE ROMOFF ) GetIntVec GetIntVec(iVBLI, pointer); // pobranie adresu programu obs\u0142ugi przerwa\u0144 VBLI ($0222) GetIntVec(iVBLD, pointer); // pobranie adresu programu obs\u0142ugi przerwa\u0144 VBLD ($0224) GetIntVec(iDLI, pointer); // pobranie adresu programu obs\u0142ugi przerwa\u0144 DLI ($0200) var oldVBL: pointer; begin GetIntVec(iVBL, oldVBL); end. SetIntVec SetIntVec(iVBLI, pointer); // ustanowienie adresu programu obs\u0142ugi przerwa\u0144 VBLI ($0222) SetIntVec(iVBLD, pointer); // ustanowienie adresu programu obs\u0142ugi przerwa\u0144 VBLD ($0224) SetIntVec(iDLI, pointer); // ustanowienie adresu programu obs\u0142ugi przerwa\u0144 DLI ($0200) procedure newVBL; interrupt; assembler; asm jmp xitvbv end; begin SetIntVec(iVBL, @newVBL); end. Przerwanie VBLD (VBL op\u00f3\u017anione) ko\u0144czymy skokiem pod adres XITVBV ($E462) co spowoduje przywr\u00f3cenie warto\u015bci rejestr\u00f3w A X Y CPU6502 . Je\u015bli wy\u0142\u0105czyli\u015bmy ROM przez {$define romoff} i korzystamy z procedur umieszczonych w pami\u0119ci $C000..$FFFF musimy zadba\u0107 o odpowiednie ustawienie PORTB . procedure newVBL; interrupt; assembler; asm dec portb jsr user_proc_c000_ffff inc portb jmp xitvbv end; Przerwanie VBLDI (VBL natychmiastowe) ko\u0144czymy skokiem pod adres SYSVBV ($E45F) co spowoduje kontynuacj\u0119 obs\u0142ugi przerwania VBL. procedure newVBL; interrupt; assembler; asm jmp sysvbv end; begin SetIntVec(iVBLI, @newVBL); end. Je\u015bli wy\u0142\u0105czyli\u015bmy ROM przez {$define romoff} i korzystamy z procedur umieszczonych w pami\u0119ci $C000..$FFFF musimy zadba\u0107 o odpowiednie ustawienie PORTB . procedure newVBL; interrupt; assembler; asm dec portb jsr user_proc_c000_ffff inc portb jmp sysvbv end; IRQ - TIMER1, TIMER2, TIMER4 Do obs\u0142ugi przerwa\u0144 IRQ - TIMER1 , TIMER2 , TIMER4 dedykowane s\u0105 dwie procedury GetIntVec oraz SetIntVec . Do prawid\u0142owego dzia\u0142ania wymagana jest obecno\u015b\u0107 OS-a (wy\u0142\u0105czenie ROM tylko przez $DEFINE ROMOFF ) GetIntVec GetIntVec(iTIM1, pointer); // pobranie adresu programu obs\u0142ugi przerwa\u0144 TIMER 1 ($0210) GetIntVec(iTIM2, pointer); // pobranie adresu programu obs\u0142ugi przerwa\u0144 TIMER 2 ($0212) GetIntVec(iTIM4, pointer); // pobranie adresu programu obs\u0142ugi przerwa\u0144 TIMER 4 ($0214) var oldIRQ: pointer; begin GetIntVec(iTIM4, oldIRQ); end. SetIntVec SetIntVec(iTIM1, pointer); // ustanowienie adresu programu obs\u0142ugi przerwa\u0144 TIMER 1 ($0210) SetIntVec(iTIM2, pointer); // ustanowienie adresu programu obs\u0142ugi przerwa\u0144 TIMER 2 ($0212) SetIntVec(iTIM4, pointer); // ustanowienie adresu programu obs\u0142ugi przerwa\u0144 TIMER 4 ($0214) procedure irq; assembler; interrupt; asm pla end; begin SetIntVec(iTIM4, @irq, 0, 28); repeat until keypressed; SetIntVec(iTIM4, oldIRQ); end. System wykonuj\u0105c skok do procedury obs\u0142ugi przerwania odk\u0142ada wcze\u015bniej zawarto\u015b\u0107 akumulatora na stos, nale\u017cy o tym pami\u0119ta\u0107 i ko\u0144czy\u0107 obs\u0142ug\u0119 przerwania przez PLA . Do uruchomienia nowego przerwania IRQ wymagane jest podanie dodatkowych parametr\u00f3w, takich jak wyb\u00f3r zegara bazowego clock_base = [0,1] oraz cz\u0119stotliwo\u015b\u0107 rate = [6.255] . Warto\u015bci rate mniejsze od 6 spowoduj\u0105 mocne spowolnienie systemu a\u017c do ewentualnego jego zawieszenia. SetIntVec(iTIM1, pointer, clock_base, rate); SetIntVec(iTIM2, pointer, clock_base, rate); SetIntVec(iTIM4, pointer, clock_base, rate);","title":"Obs\u0142uga przerwa\u0144"},{"location":"przerwania/#_1","text":"","title":""},{"location":"przerwania/#vbl-dli","text":"Do obs\u0142ugi przerwa\u0144 VBLD , VBLI , DLI dedykowane s\u0105 dwie procedury GetIntVec oraz SetIntVec . Do prawid\u0142owego dzia\u0142ania wymagana jest obecno\u015b\u0107 OS-a (wy\u0142\u0105czenie ROM tylko przez $DEFINE ROMOFF )","title":"VBL, DLI"},{"location":"przerwania/#getintvec","text":"GetIntVec(iVBLI, pointer); // pobranie adresu programu obs\u0142ugi przerwa\u0144 VBLI ($0222) GetIntVec(iVBLD, pointer); // pobranie adresu programu obs\u0142ugi przerwa\u0144 VBLD ($0224) GetIntVec(iDLI, pointer); // pobranie adresu programu obs\u0142ugi przerwa\u0144 DLI ($0200) var oldVBL: pointer; begin GetIntVec(iVBL, oldVBL); end.","title":"GetIntVec"},{"location":"przerwania/#setintvec","text":"SetIntVec(iVBLI, pointer); // ustanowienie adresu programu obs\u0142ugi przerwa\u0144 VBLI ($0222) SetIntVec(iVBLD, pointer); // ustanowienie adresu programu obs\u0142ugi przerwa\u0144 VBLD ($0224) SetIntVec(iDLI, pointer); // ustanowienie adresu programu obs\u0142ugi przerwa\u0144 DLI ($0200) procedure newVBL; interrupt; assembler; asm jmp xitvbv end; begin SetIntVec(iVBL, @newVBL); end. Przerwanie VBLD (VBL op\u00f3\u017anione) ko\u0144czymy skokiem pod adres XITVBV ($E462) co spowoduje przywr\u00f3cenie warto\u015bci rejestr\u00f3w A X Y CPU6502 . Je\u015bli wy\u0142\u0105czyli\u015bmy ROM przez {$define romoff} i korzystamy z procedur umieszczonych w pami\u0119ci $C000..$FFFF musimy zadba\u0107 o odpowiednie ustawienie PORTB . procedure newVBL; interrupt; assembler; asm dec portb jsr user_proc_c000_ffff inc portb jmp xitvbv end; Przerwanie VBLDI (VBL natychmiastowe) ko\u0144czymy skokiem pod adres SYSVBV ($E45F) co spowoduje kontynuacj\u0119 obs\u0142ugi przerwania VBL. procedure newVBL; interrupt; assembler; asm jmp sysvbv end; begin SetIntVec(iVBLI, @newVBL); end. Je\u015bli wy\u0142\u0105czyli\u015bmy ROM przez {$define romoff} i korzystamy z procedur umieszczonych w pami\u0119ci $C000..$FFFF musimy zadba\u0107 o odpowiednie ustawienie PORTB . procedure newVBL; interrupt; assembler; asm dec portb jsr user_proc_c000_ffff inc portb jmp sysvbv end;","title":"SetIntVec"},{"location":"przerwania/#irq-timer1-timer2-timer4","text":"Do obs\u0142ugi przerwa\u0144 IRQ - TIMER1 , TIMER2 , TIMER4 dedykowane s\u0105 dwie procedury GetIntVec oraz SetIntVec . Do prawid\u0142owego dzia\u0142ania wymagana jest obecno\u015b\u0107 OS-a (wy\u0142\u0105czenie ROM tylko przez $DEFINE ROMOFF )","title":"IRQ - TIMER1, TIMER2, TIMER4"},{"location":"przerwania/#getintvec_1","text":"GetIntVec(iTIM1, pointer); // pobranie adresu programu obs\u0142ugi przerwa\u0144 TIMER 1 ($0210) GetIntVec(iTIM2, pointer); // pobranie adresu programu obs\u0142ugi przerwa\u0144 TIMER 2 ($0212) GetIntVec(iTIM4, pointer); // pobranie adresu programu obs\u0142ugi przerwa\u0144 TIMER 4 ($0214) var oldIRQ: pointer; begin GetIntVec(iTIM4, oldIRQ); end.","title":"GetIntVec"},{"location":"przerwania/#setintvec_1","text":"SetIntVec(iTIM1, pointer); // ustanowienie adresu programu obs\u0142ugi przerwa\u0144 TIMER 1 ($0210) SetIntVec(iTIM2, pointer); // ustanowienie adresu programu obs\u0142ugi przerwa\u0144 TIMER 2 ($0212) SetIntVec(iTIM4, pointer); // ustanowienie adresu programu obs\u0142ugi przerwa\u0144 TIMER 4 ($0214) procedure irq; assembler; interrupt; asm pla end; begin SetIntVec(iTIM4, @irq, 0, 28); repeat until keypressed; SetIntVec(iTIM4, oldIRQ); end. System wykonuj\u0105c skok do procedury obs\u0142ugi przerwania odk\u0142ada wcze\u015bniej zawarto\u015b\u0107 akumulatora na stos, nale\u017cy o tym pami\u0119ta\u0107 i ko\u0144czy\u0107 obs\u0142ug\u0119 przerwania przez PLA . Do uruchomienia nowego przerwania IRQ wymagane jest podanie dodatkowych parametr\u00f3w, takich jak wyb\u00f3r zegara bazowego clock_base = [0,1] oraz cz\u0119stotliwo\u015b\u0107 rate = [6.255] . Warto\u015bci rate mniejsze od 6 spowoduj\u0105 mocne spowolnienie systemu a\u017c do ewentualnego jego zawieszenia. SetIntVec(iTIM1, pointer, clock_base, rate); SetIntVec(iTIM2, pointer, clock_base, rate); SetIntVec(iTIM4, pointer, clock_base, rate);","title":"SetIntVec"},{"location":"przyklady/","text":"Skrypty Linux mp-build-a8 #!/bin/bash mp=\"$HOME/Programs/MadPascal/mp\" mads=\"$HOME/Programs/mads/mads\" base=\"$HOME/Programs/MadPascal/base\" if [ -z \"$1\" ]; then echo -e \"\\nPlease call '$0 <argument>' to run this command!\\n\" exit 1 fi name=${1::-4} $mp $name.pas -o if [ -f $name.a65 ]; then [ ! -d \"output\" ] && mkdir output mv $name.a65 output/ $mads output/$name.a65 -x -i:$base -o:output/$name.xex else exit 1 fi if [ ! -z \"$2\" ]; then atari800 output/$name.xex fi mp-build-a8 main.pas r mp-build-c64 #!/bin/bash mp=\"$HOME/Programs/MadPascal/mp\" mads=\"$HOME/Programs/mads/mads\" base=\"$HOME/Programs/MadPascal/base\" if [ -z \"$1\" ]; then echo -e \"\\nPlease call '$0 <argument>' to run this command!\\n\" exit 1 fi name=${1::-4} $mp $name.pas -t c64 -z 10 -o if [ -f $name.a65 ]; then [ ! -d \"output\" ] && mkdir output mv $name.a65 output/ $mads output/$name.a65 -x -i:$base -o:output/$name.prg else exit 1 fi if [ ! -z \"$2\" ]; then x64 output/$name.prg fi mp-build-c64 main.pas r Atari 8-bit Hello World program HelloWorld; uses crt; begin writeln('Hello World'); readkey; end. C64 Test // https://bitbucket.org/paul_nicholls/pas6502/src/master/projects/pas6502_test.dpr program Test; const cScreen0 = 1024; cColor = $d800; var border : Byte absolute $D020; background : Byte absolute $D021; screen0 : array[0..1000-1] of Byte absolute cScreen0; color0 : array[0..1000-1] of Byte absolute cColor; i : Integer; begin i := 0; while i < 1000 do begin // fill screen with all screen codes (wrapping around). screen0[i] := i; // fill color RAM with all colors color0[i] := i; Inc(i); end; end.","title":"Przyk\u0142ady"},{"location":"przyklady/#_1","text":"","title":""},{"location":"przyklady/#skrypty","text":"","title":"Skrypty"},{"location":"przyklady/#linux","text":"","title":"Linux"},{"location":"przyklady/#mp-build-a8","text":"#!/bin/bash mp=\"$HOME/Programs/MadPascal/mp\" mads=\"$HOME/Programs/mads/mads\" base=\"$HOME/Programs/MadPascal/base\" if [ -z \"$1\" ]; then echo -e \"\\nPlease call '$0 <argument>' to run this command!\\n\" exit 1 fi name=${1::-4} $mp $name.pas -o if [ -f $name.a65 ]; then [ ! -d \"output\" ] && mkdir output mv $name.a65 output/ $mads output/$name.a65 -x -i:$base -o:output/$name.xex else exit 1 fi if [ ! -z \"$2\" ]; then atari800 output/$name.xex fi mp-build-a8 main.pas r","title":"mp-build-a8"},{"location":"przyklady/#mp-build-c64","text":"#!/bin/bash mp=\"$HOME/Programs/MadPascal/mp\" mads=\"$HOME/Programs/mads/mads\" base=\"$HOME/Programs/MadPascal/base\" if [ -z \"$1\" ]; then echo -e \"\\nPlease call '$0 <argument>' to run this command!\\n\" exit 1 fi name=${1::-4} $mp $name.pas -t c64 -z 10 -o if [ -f $name.a65 ]; then [ ! -d \"output\" ] && mkdir output mv $name.a65 output/ $mads output/$name.a65 -x -i:$base -o:output/$name.prg else exit 1 fi if [ ! -z \"$2\" ]; then x64 output/$name.prg fi mp-build-c64 main.pas r","title":"mp-build-c64"},{"location":"przyklady/#atari-8-bit","text":"","title":"Atari 8-bit"},{"location":"przyklady/#hello-world","text":"program HelloWorld; uses crt; begin writeln('Hello World'); readkey; end.","title":"Hello World"},{"location":"przyklady/#c64","text":"","title":"C64"},{"location":"przyklady/#test","text":"// https://bitbucket.org/paul_nicholls/pas6502/src/master/projects/pas6502_test.dpr program Test; const cScreen0 = 1024; cColor = $d800; var border : Byte absolute $D020; background : Byte absolute $D021; screen0 : array[0..1000-1] of Byte absolute cScreen0; color0 : array[0..1000-1] of Byte absolute cColor; i : Integer; begin i := 0; while i < 1000 do begin // fill screen with all screen codes (wrapping around). screen0[i] := i; // fill color RAM with all colors color0[i] := i; Inc(i); end; end.","title":"Test"},{"location":"skladnia/","text":"Zarezerwowane s\u0142owa rozkazy absolute and array asm assembler begin case const constructor div do downto else end exports external file for forward function if implementation in interrupt interface length library main mod not object of or overload pascal procedure program record register repeat shl shr string text textfile then to type unit until uses var while xor sta\u0142e pi true false nil eol nan infinity neginfinity Komentarze W Mad-Pascal do oznaczenia komentarza jednoliniowego s\u0142u\u017c\u0105 znaki // , dla wieloliniowego klamry { } , lub (* *) . // to jest komentarz inc(a); // to jest komentarz (* komentarz *) (* komentarz *) { to jest komentarz } Wyra\u017cenia Liczby zapis decymalny -100 -2437325 1743 zapis hexadecymalny $100 $e430 $000001 zapis binarny %0001001010 %000000001 %001000 zapis kodami ATASCII 'a' 'fds' 'W' #65#32#65 #$9b Operatory arytmetyczne + Addition - Subtraction * Multiplication / Division DIV Integer division MOD Remainder bitowe NOT Bitwise negation (unary) AND Bitwise and OR Bitwise or XOR Bitwise xor SHL Bitwise shift to the left SHR Bitwise shift to the right logiczne NOT logical negation (unary) AND logical and OR logical or XOR logical xor relacji = Equal <> Not equal < Less than > Greater than <= Less than or equal >= Greater than or equal Dyrektywy kompilatora Zapis dyrektyw kompilatora ma posta\u0107: {$dyrektywa parametry} {$lista_dyrektyw_prze\u0142\u0105cznikowych} Dyrektywa stanowi komentarz, w kt\u00f3rym pierwszy znak $ odr\u00f3\u017cnia zwyk\u0142y komentarz, od dyrektywy kompilatora. WARUNKOWE {$IFDEF label} {$IFNDEF label} {$ELSE} {$ENDIF} {$DEFINE label} {$UNDEF label} {$define test} const {$ifdef test} a=1; {$else} a=2; {$endif} Z poziomu assemblera dost\u0119p do zdefiniowanych etykiet $DEFINE mo\u017cliwy jest przez MAIN.@DEFINES.label $BIN2CSV Do\u0142\u0105cza zawarto\u015b\u0107 zewn\u0119trznego pliku binarnego do kodu \u017ar\u00f3d\u0142owego, jako tekst CSV. Na przyk\u0142ad, je\u015bli plik binarny zawiera bajty $1E, $1F, $20 , dyrektywa wygeneruje ci\u0105g 30, 31, 32 . G\u0142\u00f3wnym zastosowaniem tej dyrektywy jest inicjalizacji tablic . //Initialize with a binary content AAA: array[3] of byte = ( {$BIN2CSV data.bin} ); AAA: array of byte = [ {$BIN2CSV data.bin} ]; $CODEALIGN PROC {$codealign proc = $100} Dyrektywa $CODEALIGN PROC pozwala wyr\u00f3wna\u0107 generowany kod wynikowy do VALUE bajt\u00f3w strony pami\u0119ci. Przed ka\u017cdym blokiem PROCEDURE , FUNCTION wstawiany jest kod .ALIGN VALUE . Aby wy\u0142\u0105czy\u0107 wyr\u00f3wnywanie nale\u017cy ustawi\u0107 {$CODEALIGN PROC = 0} LOOP {$codealign loop = $100} Dyrektywa $CODEALIGN LOOP pozwala wyr\u00f3wna\u0107 generowany kod wynikowy do VALUE bajt\u00f3w strony pami\u0119ci. Przed ka\u017cd\u0105 instrukcj\u0105 iteracyjn\u0105 FOR , WHILE , REPEAT wstawiany jest kod .ALIGN VALUE . Aby wy\u0142\u0105czy\u0107 wyr\u00f3wnywanie nale\u017cy ustawi\u0107 {$CODEALIGN LOOP = 0} LINK {$codealign link = $100} Dyrektywa $CODEALIGN LINK pozwala wyr\u00f3wna\u0107 generowany kod wynikowy do VALUE bajt\u00f3w strony pami\u0119ci. Przed ka\u017cd\u0105 dyrektyw\u0105 {$LINK filename} wstawiany jest kod .ALIGN VALUE . Aby wy\u0142\u0105czy\u0107 wyr\u00f3wnywanie nale\u017cy ustawi\u0107 {$CODEALIGN LINK = 0} $DEFINE BASICOFF {$DEFINE BASICOFF} Powoduje utworzenie dodatkowego bloku programu, realizuj\u0105cego wy\u0142\u0105czenie BASIC-a. ROMOFF {$DEFINE ROMOFF} Zyskujemy dost\u0119p do pami\u0119ci pod ROM-em , $C000..$CFFF , $D800..$FFFF . Zestaw znak\u00f3w z ROM $E000..$E3FF zostaje przepisany pod ten sam adres w RAM , zostaje zainstalowany handler przerwa\u0144 NMI , IRQ . System operacyjny dzia\u0142a normalnie, mo\u017cna z poziomu ASM wywo\u0142ywa\u0107 procedury w nim zawarte poprzez makro m@call . UWAGA: W przypadku umieszczenia programu ANTIC -a Display List pod ROM -em ka\u017cde naci\u015bni\u0119cie klawisza b\u0119dzie powodowa\u0107 wywo\u0142anie przerwania IRQ obs\u0142uguj\u0105cego klawiatur\u0119. Program ANTIC -a b\u0119dzie zak\u0142\u00f3cany poprzez prze\u0142\u0105czanie ROM - RAM , w przypadku gdy korzystamy z przerwania Display List -y ( DLI ) mo\u017ce doj\u015b\u0107 do uszkodzenia stosu i wy\u0142o\u017cenia si\u0119 systemu. Umieszczenie zestawu znak\u00f3w lub pami\u0119ci obrazu pod ROM b\u0119dzie skutkowa\u0107 'glitchami' w momencie naciskania klawiszy. NOROMFONT {$DEFINE NOROMFONT} Uzupe\u0142nienie dla {$DEFINE ROMOFF} , zapobiega przepisaniu zestawu znakowego z ROM do RAM $ERROR {$ERROR user_defined} Wygenerowanie komunikatu z b\u0142\u0119dem ERROR . $EVAL {$EVAL PAR1[,PAR2] ,\"EXPRESSION\"} Oblicza warto\u015b\u0107 wyra\u017cenia EXPRESSION dla zakresu: 0..PAR1-1 (je\u015bli podano tylko PAR1 ) 0..PAR1-1 * 0..PAR2-1 (je\u015bli podano PAR1 i PAR2 ) Parametry w wyra\u017ceniu oznaczamy jako :1 (dla PAR1 ) i :2 (dla PAR2 ). W wyra\u017ceniu mo\u017cna u\u017cywa\u0107 sta\u0142ych wyst\u0119puj\u0105cych w programie. Dozwolone operatory: +, -, *, /, DIV, MOD, AND, SHL, SHR, OR, XOR, AND Dost\u0119pne funkcje matematyczne: PI, RND, SQRT, SQR, ARCTAN2, COS, SIN, TAN, EXP, LN, ABS, INT, POWER, ARCTAN G\u0142\u00f3wnym zastosowaniem tej dyrektywy jest inicjalizacji tablic. mul_40: array of word = [ {$EVAL 192,\":1*40\"} ]; sqr : array of byte = [ {$eval WIDTH,200,\"255/(sqrt(power(:1-WIDTH/2.5,2)*4+power(:2-HEIGHT/2-20,2))+5)*32.0\" } ]; sinx: array of byte = [ {$eval 256, \"(sin(:1/256.0*PI*2.0)*48+63)\"} ]; cnt: array [0..39] of byte = ( {$eval 40,\":1 and 15\"} ); $F, $FASTMUL {$fastmul page} // fastmul at page*256 {$f $70} // fastmul at $7000 Alternatywne procedury szybkiego mno\u017cenia dla typu BYTE SHORTINT WORD SMALLINT SHORTREAL . Procedury zajmuj\u0105 2KB i s\u0105 umieszczane od adresu PAGE*256 . $I+, $I-, IOCHECK {$I+} {$I-} {i+} IOCHECK ON default {i-} IOCHECK OFF Dla {$i+} w przypadku wyst\u0105pienia b\u0142\u0119d\u00f3w transmisji I/O dla: RESET REWRITE BLOCKREAD BLOCKWRITE CLOSE , wykonywany program zostaje zatrzymany, generowany jest komunikat b\u0142\u0119du ERROR xxx . Wy\u0142\u0105czenie IOCHECK {$i-} przydaje si\u0119 gdy chcemy sprawdzi\u0107 istnienie pliku na dysku, np.: function FileExists(name: TString): Boolean; var f: file; begin {$I-} // io check off Assign (f, name); Reset (f); Result:=(IoResult<128) and (length(name)>0); Close (f); {$I+} // io check on end; W blokach PROCEDURE , FUNCTION dyrektywa IOCHECK jest zasi\u0119gu lokalnego, po zako\u0144czeniu kompilacji takiego bloku przywracana jest warto\u015b\u0107 IOCHECK , kt\u00f3ra zosta\u0142a okre\u015blona poza takim blokiem. $I, $INCLUDE %DATE% {$INCLUDE %DATE%} {$I %DATE%} Parametr %DATE% pozwala do\u0142\u0105czy\u0107 tekst z aktualn\u0105 dat\u0105 kompilacji. %TIME% {$INCLUDE %TIME%} {$I %TIME%} Parametr %TIME% pozwala do\u0142\u0105czy\u0107 tekst z aktualnym czasem kompilacji. FILENAME {$INCLUDE filename} {$I filename} Parametr FILENAME pozwala do\u0142\u0105czy\u0107 plik tekstowy. $INFO {$INFO user_defined} Wygenerowanie komunikatu z informacj\u0105 INFO . $LIBRARYPATH {$LIBRARYPATH path1; path2; ...} Dyrektywa $LIBRARYPATH pozwala wskaza\u0107 dodatkowe \u015bcie\u017cki poszukiwa\u0144 modu\u0142\u00f3w UNIT zadeklarowanych przez USES . $LINK {$LINK filename} Dyrektywa {$link filename} pozwala do\u0142\u0105czy\u0107 i zintegrowa\u0107 z programem Mad Pascal -a kod i procedury zasemblowane w Mad Assembler -rze. Wi\u0119cej na temat \u0142\u0105czenia assemblera z Mad Pascal -em w rozdziale Wstawki assemblera $MACRO {$MACRO ON} {$MACRO OFF} {$MACRO+} {$MACRO-} Dyrektywa {$macro } w\u0142\u0105cza/wy\u0142\u0105cza mo\u017cliwo\u015b\u0107 definiowania makr , jest wymagana przez FPC , w Mad-Pascal jest zachowana tylko w celu zgodno\u015bci. $OPTIMIZATION LOOPUNROLL {$OPTIMIZATION loopunroll} Dyrektywa $OPTIMIZATION z parametrem LOOPUNROLL pozwala rozp\u0119tla\u0107 p\u0119tle FOR (parametry takiej p\u0119tli musz\u0105 by\u0107 sta\u0142ymi): {$OPTIMIZATION loopunroll} for i:=0 to 11 do tab[i]:=i*2; {$OPTIMIZATION noloopunroll} NOLOOPUNROLL {$OPTIMIZATION noloopunroll} Parametr NOLOOPUNROLL wy\u0142\u0105cza rozp\u0119tlanie p\u0119tli FOR . $R, $RESOURCE {$R filename} {$RESOURCE filename} RCLABEL RCTYPE RCFILE [PAR0 PAR1 PAR2 PAR3 PAR4 PAR5 PAR6 PAR7] Dyrektywa do\u0142\u0105czenia pliku z zasobami. Plik zasob\u00f3w jest plikiem tekstowym, ka\u017cdy jego kolejny wiersz powinien sk\u0142ada\u0107 si\u0119 z trzech p\u00f3l rozdzielonych \"bia\u0142ym znakiem\": etykieta RCLABEL (jej deklaracja musi znale\u017a\u0107 si\u0119 tak\u017ce w programie) typ zasob\u00f3w RCTYPE lokalizacja pliku RCFILE Aktualnie w pliku BASE\\RES6502.ASM znajduj\u0105 si\u0119 makra do obs\u0142ugi 12 typ\u00f3w zasob\u00f3w RCTYPE : RCDATA rclabel RCDATA 'filename' rclabel RCDATA 'filename' OFFSET Dowolny typ danych, mo\u017cliwe jest podanie dodatkowego parametru okre\u015blaj\u0105cego liczb\u0119 bajt\u00f3w kt\u00f3re maj\u0105 zosta\u0107 pomini\u0119te, przydatne kiedy chcemy usun\u0105\u0107 nag\u0142\u00f3wek pliku XEX. EXTMEM rclabel EXTMEM 'filename' Dowolny typ danych \u0142adowany do pami\u0119ci dodatkowej PORTB, adres \u0142adowania ustalany jest na podstawie RCLABEL . RCASM rclabel RCASM 'filename' Plik w assemblerze, kt\u00f3ry zostanie do\u0142\u0105czony i zasemblowany pod wskazany adres RCLABEL . DOSFILE rclabel DOSFILE 'filename' Plik z nag\u0142\u00f3wkiem Atari DOS , adres \u0142adowania takiego pliku powinien by\u0107 identyczny jak RCLABEL . RELOC rclabel RELOC 'filename' Plik relokowalny w formacie Mad Assembler -a, plik zostanie poddany relokacji pod wskazany adres RCLABEL . PP rclabel PP 'filename' Plik spakowany Power Packer -em, kt\u00f3ry zostanie za\u0142adowany pod wskazany adres RCLABEL . SAPR rclabel SAPR 'filename' Plik SAPR-LZSS , kt\u00f3ry zostanie za\u0142adowany pod wskazany adres RCLABEL . RMT rclabel RMT 'filename' Plik modu\u0142u Raster Music Tracker -a, plik zostanie poddany relokacji pod wskazany adres RCLABEL . MPT rclabel MPT 'filename' Plik modu\u0142u Music ProTracker -a, plik zostanie poddany relokacji pod wskazany adres RCLABEL . CMC rclabel CMC 'filename' Plik modu\u0142u Chaos Music Composer-a , plik zostanie poddany relokacji pod wskazany adres RCLABEL . RMTPLAY rclabel RMTPLAY 'filename.feat' 0 Player dla modu\u0142u RMT , jako RCFILE podajemy plik *.FEAT oraz dodatkowo PAR0 tryb playera 0..3 . 0 => compile RMTplayer for 4 tracks mono 1 => compile RMTplayer for 8 tracks stereo 2 => compile RMTplayer for 4 tracks stereo L1 R2 R3 L4 3 => compile RMTplayer for 4 tracks stereo L1 L2 R3 R4 SAPRPLAY rclabel SAPRPLAY Player SAPR-LZSS , kt\u00f3ry wymaga $C00 bajt\u00f3w pami\u0119ci ($300 player, $900 bufory). MPTPLAY rclabel MPTPLAY Player dla modu\u0142u MPT . CMCPLAY rclabel CMCPLAY Player dla modu\u0142u CMC . XBMP rclabel XBMP 'filename' 0 Plik Windows Bitmap (8 BitsPerPixel) \u0142adowany do pami\u0119ci VBXE pod wskazany adres RCLABEL od indeksu koloru PAR0 w palecie kolor\u00f3w VBXE nr 1 Przyk\u0142ad: bmp1 RCDATA 'pic.mic' msx MPT 'porazka.mpt' play RMTPLAY 'modul.feat' 1 bmp XBMP 'pic.bmp' 80 $UNITPATH {$UNITPATH path1; path2; ...} Dyrektywa $UNITPATH pozwala wskaza\u0107 dodatkowe \u015bcie\u017cki poszukiwa\u0144 modu\u0142\u00f3w UNIT zadeklarowanych przez USES . $WARNING {$WARNING user_defined} Wygenerowanie komunikatu z ostrze\u017ceniem WARNING .","title":"Sk\u0142adnia"},{"location":"skladnia/#_1","text":"","title":""},{"location":"skladnia/#zarezerwowane-sowa","text":"","title":"Zarezerwowane s\u0142owa"},{"location":"skladnia/#rozkazy","text":"absolute and array asm assembler begin case const constructor div do downto else end exports external file for forward function if implementation in interrupt interface length library main mod not object of or overload pascal procedure program record register repeat shl shr string text textfile then to type unit until uses var while xor","title":"rozkazy"},{"location":"skladnia/#stae","text":"pi true false nil eol nan infinity neginfinity","title":"sta\u0142e"},{"location":"skladnia/#komentarze","text":"W Mad-Pascal do oznaczenia komentarza jednoliniowego s\u0142u\u017c\u0105 znaki // , dla wieloliniowego klamry { } , lub (* *) . // to jest komentarz inc(a); // to jest komentarz (* komentarz *) (* komentarz *) { to jest komentarz }","title":"Komentarze"},{"location":"skladnia/#wyrazenia","text":"","title":"Wyra\u017cenia"},{"location":"skladnia/#liczby","text":"","title":"Liczby"},{"location":"skladnia/#zapis-decymalny","text":"-100 -2437325 1743","title":"zapis decymalny"},{"location":"skladnia/#zapis-hexadecymalny","text":"$100 $e430 $000001","title":"zapis hexadecymalny"},{"location":"skladnia/#zapis-binarny","text":"%0001001010 %000000001 %001000","title":"zapis binarny"},{"location":"skladnia/#zapis-kodami-atascii","text":"'a' 'fds' 'W' #65#32#65 #$9b","title":"zapis kodami ATASCII"},{"location":"skladnia/#operatory","text":"","title":"Operatory"},{"location":"skladnia/#arytmetyczne","text":"+ Addition - Subtraction * Multiplication / Division DIV Integer division MOD Remainder","title":"arytmetyczne"},{"location":"skladnia/#bitowe","text":"NOT Bitwise negation (unary) AND Bitwise and OR Bitwise or XOR Bitwise xor SHL Bitwise shift to the left SHR Bitwise shift to the right","title":"bitowe"},{"location":"skladnia/#logiczne","text":"NOT logical negation (unary) AND logical and OR logical or XOR logical xor","title":"logiczne"},{"location":"skladnia/#relacji","text":"= Equal <> Not equal < Less than > Greater than <= Less than or equal >= Greater than or equal","title":"relacji"},{"location":"skladnia/#dyrektywy-kompilatora","text":"Zapis dyrektyw kompilatora ma posta\u0107: {$dyrektywa parametry} {$lista_dyrektyw_prze\u0142\u0105cznikowych} Dyrektywa stanowi komentarz, w kt\u00f3rym pierwszy znak $ odr\u00f3\u017cnia zwyk\u0142y komentarz, od dyrektywy kompilatora.","title":"Dyrektywy kompilatora"},{"location":"skladnia/#warunkowe","text":"{$IFDEF label} {$IFNDEF label} {$ELSE} {$ENDIF} {$DEFINE label} {$UNDEF label} {$define test} const {$ifdef test} a=1; {$else} a=2; {$endif} Z poziomu assemblera dost\u0119p do zdefiniowanych etykiet $DEFINE mo\u017cliwy jest przez MAIN.@DEFINES.label","title":"WARUNKOWE"},{"location":"skladnia/#bin2csv","text":"Do\u0142\u0105cza zawarto\u015b\u0107 zewn\u0119trznego pliku binarnego do kodu \u017ar\u00f3d\u0142owego, jako tekst CSV. Na przyk\u0142ad, je\u015bli plik binarny zawiera bajty $1E, $1F, $20 , dyrektywa wygeneruje ci\u0105g 30, 31, 32 . G\u0142\u00f3wnym zastosowaniem tej dyrektywy jest inicjalizacji tablic . //Initialize with a binary content AAA: array[3] of byte = ( {$BIN2CSV data.bin} ); AAA: array of byte = [ {$BIN2CSV data.bin} ];","title":"$BIN2CSV"},{"location":"skladnia/#codealign","text":"","title":"$CODEALIGN"},{"location":"skladnia/#proc","text":"{$codealign proc = $100} Dyrektywa $CODEALIGN PROC pozwala wyr\u00f3wna\u0107 generowany kod wynikowy do VALUE bajt\u00f3w strony pami\u0119ci. Przed ka\u017cdym blokiem PROCEDURE , FUNCTION wstawiany jest kod .ALIGN VALUE . Aby wy\u0142\u0105czy\u0107 wyr\u00f3wnywanie nale\u017cy ustawi\u0107 {$CODEALIGN PROC = 0}","title":"PROC"},{"location":"skladnia/#loop","text":"{$codealign loop = $100} Dyrektywa $CODEALIGN LOOP pozwala wyr\u00f3wna\u0107 generowany kod wynikowy do VALUE bajt\u00f3w strony pami\u0119ci. Przed ka\u017cd\u0105 instrukcj\u0105 iteracyjn\u0105 FOR , WHILE , REPEAT wstawiany jest kod .ALIGN VALUE . Aby wy\u0142\u0105czy\u0107 wyr\u00f3wnywanie nale\u017cy ustawi\u0107 {$CODEALIGN LOOP = 0}","title":"LOOP"},{"location":"skladnia/#link","text":"{$codealign link = $100} Dyrektywa $CODEALIGN LINK pozwala wyr\u00f3wna\u0107 generowany kod wynikowy do VALUE bajt\u00f3w strony pami\u0119ci. Przed ka\u017cd\u0105 dyrektyw\u0105 {$LINK filename} wstawiany jest kod .ALIGN VALUE . Aby wy\u0142\u0105czy\u0107 wyr\u00f3wnywanie nale\u017cy ustawi\u0107 {$CODEALIGN LINK = 0}","title":"LINK"},{"location":"skladnia/#define","text":"","title":"$DEFINE"},{"location":"skladnia/#basicoff","text":"{$DEFINE BASICOFF} Powoduje utworzenie dodatkowego bloku programu, realizuj\u0105cego wy\u0142\u0105czenie BASIC-a.","title":"BASICOFF"},{"location":"skladnia/#romoff","text":"{$DEFINE ROMOFF} Zyskujemy dost\u0119p do pami\u0119ci pod ROM-em , $C000..$CFFF , $D800..$FFFF . Zestaw znak\u00f3w z ROM $E000..$E3FF zostaje przepisany pod ten sam adres w RAM , zostaje zainstalowany handler przerwa\u0144 NMI , IRQ . System operacyjny dzia\u0142a normalnie, mo\u017cna z poziomu ASM wywo\u0142ywa\u0107 procedury w nim zawarte poprzez makro m@call . UWAGA: W przypadku umieszczenia programu ANTIC -a Display List pod ROM -em ka\u017cde naci\u015bni\u0119cie klawisza b\u0119dzie powodowa\u0107 wywo\u0142anie przerwania IRQ obs\u0142uguj\u0105cego klawiatur\u0119. Program ANTIC -a b\u0119dzie zak\u0142\u00f3cany poprzez prze\u0142\u0105czanie ROM - RAM , w przypadku gdy korzystamy z przerwania Display List -y ( DLI ) mo\u017ce doj\u015b\u0107 do uszkodzenia stosu i wy\u0142o\u017cenia si\u0119 systemu. Umieszczenie zestawu znak\u00f3w lub pami\u0119ci obrazu pod ROM b\u0119dzie skutkowa\u0107 'glitchami' w momencie naciskania klawiszy.","title":"ROMOFF"},{"location":"skladnia/#noromfont","text":"{$DEFINE NOROMFONT} Uzupe\u0142nienie dla {$DEFINE ROMOFF} , zapobiega przepisaniu zestawu znakowego z ROM do RAM","title":"NOROMFONT"},{"location":"skladnia/#error","text":"{$ERROR user_defined} Wygenerowanie komunikatu z b\u0142\u0119dem ERROR .","title":"$ERROR"},{"location":"skladnia/#eval","text":"{$EVAL PAR1[,PAR2] ,\"EXPRESSION\"} Oblicza warto\u015b\u0107 wyra\u017cenia EXPRESSION dla zakresu: 0..PAR1-1 (je\u015bli podano tylko PAR1 ) 0..PAR1-1 * 0..PAR2-1 (je\u015bli podano PAR1 i PAR2 ) Parametry w wyra\u017ceniu oznaczamy jako :1 (dla PAR1 ) i :2 (dla PAR2 ). W wyra\u017ceniu mo\u017cna u\u017cywa\u0107 sta\u0142ych wyst\u0119puj\u0105cych w programie. Dozwolone operatory: +, -, *, /, DIV, MOD, AND, SHL, SHR, OR, XOR, AND Dost\u0119pne funkcje matematyczne: PI, RND, SQRT, SQR, ARCTAN2, COS, SIN, TAN, EXP, LN, ABS, INT, POWER, ARCTAN G\u0142\u00f3wnym zastosowaniem tej dyrektywy jest inicjalizacji tablic. mul_40: array of word = [ {$EVAL 192,\":1*40\"} ]; sqr : array of byte = [ {$eval WIDTH,200,\"255/(sqrt(power(:1-WIDTH/2.5,2)*4+power(:2-HEIGHT/2-20,2))+5)*32.0\" } ]; sinx: array of byte = [ {$eval 256, \"(sin(:1/256.0*PI*2.0)*48+63)\"} ]; cnt: array [0..39] of byte = ( {$eval 40,\":1 and 15\"} );","title":"$EVAL"},{"location":"skladnia/#f-fastmul","text":"{$fastmul page} // fastmul at page*256 {$f $70} // fastmul at $7000 Alternatywne procedury szybkiego mno\u017cenia dla typu BYTE SHORTINT WORD SMALLINT SHORTREAL . Procedury zajmuj\u0105 2KB i s\u0105 umieszczane od adresu PAGE*256 .","title":"$F, $FASTMUL"},{"location":"skladnia/#i-i-iocheck","text":"{$I+} {$I-} {i+} IOCHECK ON default {i-} IOCHECK OFF Dla {$i+} w przypadku wyst\u0105pienia b\u0142\u0119d\u00f3w transmisji I/O dla: RESET REWRITE BLOCKREAD BLOCKWRITE CLOSE , wykonywany program zostaje zatrzymany, generowany jest komunikat b\u0142\u0119du ERROR xxx . Wy\u0142\u0105czenie IOCHECK {$i-} przydaje si\u0119 gdy chcemy sprawdzi\u0107 istnienie pliku na dysku, np.: function FileExists(name: TString): Boolean; var f: file; begin {$I-} // io check off Assign (f, name); Reset (f); Result:=(IoResult<128) and (length(name)>0); Close (f); {$I+} // io check on end; W blokach PROCEDURE , FUNCTION dyrektywa IOCHECK jest zasi\u0119gu lokalnego, po zako\u0144czeniu kompilacji takiego bloku przywracana jest warto\u015b\u0107 IOCHECK , kt\u00f3ra zosta\u0142a okre\u015blona poza takim blokiem.","title":"$I+, $I-, IOCHECK"},{"location":"skladnia/#i-include","text":"","title":"$I, $INCLUDE"},{"location":"skladnia/#date","text":"{$INCLUDE %DATE%} {$I %DATE%} Parametr %DATE% pozwala do\u0142\u0105czy\u0107 tekst z aktualn\u0105 dat\u0105 kompilacji.","title":"%DATE%"},{"location":"skladnia/#time","text":"{$INCLUDE %TIME%} {$I %TIME%} Parametr %TIME% pozwala do\u0142\u0105czy\u0107 tekst z aktualnym czasem kompilacji.","title":"%TIME%"},{"location":"skladnia/#filename","text":"{$INCLUDE filename} {$I filename} Parametr FILENAME pozwala do\u0142\u0105czy\u0107 plik tekstowy.","title":"FILENAME"},{"location":"skladnia/#info","text":"{$INFO user_defined} Wygenerowanie komunikatu z informacj\u0105 INFO .","title":"$INFO"},{"location":"skladnia/#librarypath","text":"{$LIBRARYPATH path1; path2; ...} Dyrektywa $LIBRARYPATH pozwala wskaza\u0107 dodatkowe \u015bcie\u017cki poszukiwa\u0144 modu\u0142\u00f3w UNIT zadeklarowanych przez USES .","title":"$LIBRARYPATH"},{"location":"skladnia/#link_1","text":"{$LINK filename} Dyrektywa {$link filename} pozwala do\u0142\u0105czy\u0107 i zintegrowa\u0107 z programem Mad Pascal -a kod i procedury zasemblowane w Mad Assembler -rze. Wi\u0119cej na temat \u0142\u0105czenia assemblera z Mad Pascal -em w rozdziale Wstawki assemblera","title":"$LINK"},{"location":"skladnia/#macro","text":"{$MACRO ON} {$MACRO OFF} {$MACRO+} {$MACRO-} Dyrektywa {$macro } w\u0142\u0105cza/wy\u0142\u0105cza mo\u017cliwo\u015b\u0107 definiowania makr , jest wymagana przez FPC , w Mad-Pascal jest zachowana tylko w celu zgodno\u015bci.","title":"$MACRO"},{"location":"skladnia/#optimization","text":"","title":"$OPTIMIZATION"},{"location":"skladnia/#loopunroll","text":"{$OPTIMIZATION loopunroll} Dyrektywa $OPTIMIZATION z parametrem LOOPUNROLL pozwala rozp\u0119tla\u0107 p\u0119tle FOR (parametry takiej p\u0119tli musz\u0105 by\u0107 sta\u0142ymi): {$OPTIMIZATION loopunroll} for i:=0 to 11 do tab[i]:=i*2; {$OPTIMIZATION noloopunroll}","title":"LOOPUNROLL"},{"location":"skladnia/#noloopunroll","text":"{$OPTIMIZATION noloopunroll} Parametr NOLOOPUNROLL wy\u0142\u0105cza rozp\u0119tlanie p\u0119tli FOR .","title":"NOLOOPUNROLL"},{"location":"skladnia/#r-resource","text":"{$R filename} {$RESOURCE filename} RCLABEL RCTYPE RCFILE [PAR0 PAR1 PAR2 PAR3 PAR4 PAR5 PAR6 PAR7] Dyrektywa do\u0142\u0105czenia pliku z zasobami. Plik zasob\u00f3w jest plikiem tekstowym, ka\u017cdy jego kolejny wiersz powinien sk\u0142ada\u0107 si\u0119 z trzech p\u00f3l rozdzielonych \"bia\u0142ym znakiem\": etykieta RCLABEL (jej deklaracja musi znale\u017a\u0107 si\u0119 tak\u017ce w programie) typ zasob\u00f3w RCTYPE lokalizacja pliku RCFILE Aktualnie w pliku BASE\\RES6502.ASM znajduj\u0105 si\u0119 makra do obs\u0142ugi 12 typ\u00f3w zasob\u00f3w RCTYPE :","title":"$R, $RESOURCE"},{"location":"skladnia/#rcdata","text":"rclabel RCDATA 'filename' rclabel RCDATA 'filename' OFFSET Dowolny typ danych, mo\u017cliwe jest podanie dodatkowego parametru okre\u015blaj\u0105cego liczb\u0119 bajt\u00f3w kt\u00f3re maj\u0105 zosta\u0107 pomini\u0119te, przydatne kiedy chcemy usun\u0105\u0107 nag\u0142\u00f3wek pliku XEX.","title":"RCDATA"},{"location":"skladnia/#extmem","text":"rclabel EXTMEM 'filename' Dowolny typ danych \u0142adowany do pami\u0119ci dodatkowej PORTB, adres \u0142adowania ustalany jest na podstawie RCLABEL .","title":"EXTMEM"},{"location":"skladnia/#rcasm","text":"rclabel RCASM 'filename' Plik w assemblerze, kt\u00f3ry zostanie do\u0142\u0105czony i zasemblowany pod wskazany adres RCLABEL .","title":"RCASM"},{"location":"skladnia/#dosfile","text":"rclabel DOSFILE 'filename' Plik z nag\u0142\u00f3wkiem Atari DOS , adres \u0142adowania takiego pliku powinien by\u0107 identyczny jak RCLABEL .","title":"DOSFILE"},{"location":"skladnia/#reloc","text":"rclabel RELOC 'filename' Plik relokowalny w formacie Mad Assembler -a, plik zostanie poddany relokacji pod wskazany adres RCLABEL .","title":"RELOC"},{"location":"skladnia/#pp","text":"rclabel PP 'filename' Plik spakowany Power Packer -em, kt\u00f3ry zostanie za\u0142adowany pod wskazany adres RCLABEL .","title":"PP"},{"location":"skladnia/#sapr","text":"rclabel SAPR 'filename' Plik SAPR-LZSS , kt\u00f3ry zostanie za\u0142adowany pod wskazany adres RCLABEL .","title":"SAPR"},{"location":"skladnia/#rmt","text":"rclabel RMT 'filename' Plik modu\u0142u Raster Music Tracker -a, plik zostanie poddany relokacji pod wskazany adres RCLABEL .","title":"RMT"},{"location":"skladnia/#mpt","text":"rclabel MPT 'filename' Plik modu\u0142u Music ProTracker -a, plik zostanie poddany relokacji pod wskazany adres RCLABEL .","title":"MPT"},{"location":"skladnia/#cmc","text":"rclabel CMC 'filename' Plik modu\u0142u Chaos Music Composer-a , plik zostanie poddany relokacji pod wskazany adres RCLABEL .","title":"CMC"},{"location":"skladnia/#rmtplay","text":"rclabel RMTPLAY 'filename.feat' 0 Player dla modu\u0142u RMT , jako RCFILE podajemy plik *.FEAT oraz dodatkowo PAR0 tryb playera 0..3 . 0 => compile RMTplayer for 4 tracks mono 1 => compile RMTplayer for 8 tracks stereo 2 => compile RMTplayer for 4 tracks stereo L1 R2 R3 L4 3 => compile RMTplayer for 4 tracks stereo L1 L2 R3 R4","title":"RMTPLAY"},{"location":"skladnia/#saprplay","text":"rclabel SAPRPLAY Player SAPR-LZSS , kt\u00f3ry wymaga $C00 bajt\u00f3w pami\u0119ci ($300 player, $900 bufory).","title":"SAPRPLAY"},{"location":"skladnia/#mptplay","text":"rclabel MPTPLAY Player dla modu\u0142u MPT .","title":"MPTPLAY"},{"location":"skladnia/#cmcplay","text":"rclabel CMCPLAY Player dla modu\u0142u CMC .","title":"CMCPLAY"},{"location":"skladnia/#xbmp","text":"rclabel XBMP 'filename' 0 Plik Windows Bitmap (8 BitsPerPixel) \u0142adowany do pami\u0119ci VBXE pod wskazany adres RCLABEL od indeksu koloru PAR0 w palecie kolor\u00f3w VBXE nr 1 Przyk\u0142ad: bmp1 RCDATA 'pic.mic' msx MPT 'porazka.mpt' play RMTPLAY 'modul.feat' 1 bmp XBMP 'pic.bmp' 80","title":"XBMP"},{"location":"skladnia/#unitpath","text":"{$UNITPATH path1; path2; ...} Dyrektywa $UNITPATH pozwala wskaza\u0107 dodatkowe \u015bcie\u017cki poszukiwa\u0144 modu\u0142\u00f3w UNIT zadeklarowanych przez USES .","title":"$UNITPATH"},{"location":"skladnia/#warning","text":"{$WARNING user_defined} Wygenerowanie komunikatu z ostrze\u017ceniem WARNING .","title":"$WARNING"},{"location":"sposob-uzycia/","text":"Prze\u0142\u0105czniki kompilatora Syntax: mp inputfile [prze\u0142\u0105czniki] -ipath:<folder> dodatkowa \u015bcie\u017cka poszukiwa\u0144 -define:<symbol> definiowanie symbolu -cpu:<cpu> 6502 (domy\u015blnie), 65C02, 65816 -target:<platform> docelowy system: a8 (domy\u015blnie), c64 -code:<address> adres uruchomienia programu -data:<address> adres pami\u0119ci dla zmiennych, tablic -stack:<address> adres pami\u0119ci dla stosu programowego (64 bajty) -zpage:<address> adres na stronie zerowej dla zmiennych (26 bajty) -o:<outputfile> domy\u015blnie <inputfile>.a65 -diag tryb diagnostyczny U\u017cycie prze\u0142\u0105cznika -diag powoduje wygenerowanie dodatkowego pliku z informacj\u0105 o wszystkich u\u017cytych zmiennych, procedurach, funkcjach. Domy\u015blnym rozszerzeniem pliku wynikowego jest *.A65 , plik taki assemblujemy z u\u017cyciem Mad-Assemblera , dodatkowo ustawiamy -i:base , base znajduje si\u0119 w katalogu g\u0142\u00f3wnym Mad-Pascal ), np.: mads source.a65 -x -i:base Prze\u0142\u0105cznik -x Exclude unreferenced procedures jest bardzo istotny, pozwoli wygenerowa\u0107 najkr\u00f3tszy kod wynikowy dla 6502, wszystkie procedury .PROC do kt\u00f3rych nie wyst\u0105pi\u0142o odwo\u0142anie zostan\u0105 pomini\u0119te w procesie assemblacji. Kody wyj\u015bcia 3 = bad parameters, compiling not started 2 = error occured 0 = no errors Komunikaty ostrze\u017cenia nie powoduj\u0105 zmiany warto\u015bci kodu wyj\u015bcia.","title":"Spos\u00f3b u\u017cycia"},{"location":"sposob-uzycia/#_1","text":"","title":""},{"location":"sposob-uzycia/#przeaczniki-kompilatora","text":"Syntax: mp inputfile [prze\u0142\u0105czniki] -ipath:<folder> dodatkowa \u015bcie\u017cka poszukiwa\u0144 -define:<symbol> definiowanie symbolu -cpu:<cpu> 6502 (domy\u015blnie), 65C02, 65816 -target:<platform> docelowy system: a8 (domy\u015blnie), c64 -code:<address> adres uruchomienia programu -data:<address> adres pami\u0119ci dla zmiennych, tablic -stack:<address> adres pami\u0119ci dla stosu programowego (64 bajty) -zpage:<address> adres na stronie zerowej dla zmiennych (26 bajty) -o:<outputfile> domy\u015blnie <inputfile>.a65 -diag tryb diagnostyczny U\u017cycie prze\u0142\u0105cznika -diag powoduje wygenerowanie dodatkowego pliku z informacj\u0105 o wszystkich u\u017cytych zmiennych, procedurach, funkcjach. Domy\u015blnym rozszerzeniem pliku wynikowego jest *.A65 , plik taki assemblujemy z u\u017cyciem Mad-Assemblera , dodatkowo ustawiamy -i:base , base znajduje si\u0119 w katalogu g\u0142\u00f3wnym Mad-Pascal ), np.: mads source.a65 -x -i:base Prze\u0142\u0105cznik -x Exclude unreferenced procedures jest bardzo istotny, pozwoli wygenerowa\u0107 najkr\u00f3tszy kod wynikowy dla 6502, wszystkie procedury .PROC do kt\u00f3rych nie wyst\u0105pi\u0142o odwo\u0142anie zostan\u0105 pomini\u0119te w procesie assemblacji.","title":"Prze\u0142\u0105czniki kompilatora"},{"location":"sposob-uzycia/#kody-wyjscia","text":"3 = bad parameters, compiling not started 2 = error occured 0 = no errors Komunikaty ostrze\u017cenia nie powoduj\u0105 zmiany warto\u015bci kodu wyj\u015bcia.","title":"Kody wyj\u015bcia"},{"location":"stale/","text":"CONST S\u0142owo CONST rozpoczyna sekcj\u0119 deklaracji sta\u0142ych. Do deklaracji sta\u0142ych CONST s\u0142u\u017cy znak = . Dopuszczalne jest u\u017cycie operator\u00f3w, niekt\u00f3rych funkcji i sta\u0142ych: + - * / not and or div mod ord chr sizeof pi const e = 2.7182818; { Real type constant } f : single = 3.14; { Single type constant } a = 2; { Ordinal BYTE type constant } c = '4'; { Character type constant } s = 'atari'; { String type constant } sc = chr(32); ls = SizeOf(cardinal); Kompilator na podstawie warto\u015bci dobiera typ dla deklarowanych sta\u0142ych. Dla warto\u015bci 0..255 b\u0119dzie to typ BYTE , 256..65535 typ WORD , -128..127 typ SHORTINT itd. Istnieje mo\u017cliwo\u015b\u0107 okre\u015blenia typu przez programist\u0119, const x: word = 5; { wymuszenie typu sta\u0142ej } b: byte = -11; Dodatkowo kompilator ma predefiniowane sta\u0142e: NIL EOL __BUFFER TRUE FALSE MAXINT MAXSMALLINT PI NAN INFINITY NEGINFINITY","title":"Sta\u0142e"},{"location":"stale/#_1","text":"","title":""},{"location":"stale/#const","text":"S\u0142owo CONST rozpoczyna sekcj\u0119 deklaracji sta\u0142ych. Do deklaracji sta\u0142ych CONST s\u0142u\u017cy znak = . Dopuszczalne jest u\u017cycie operator\u00f3w, niekt\u00f3rych funkcji i sta\u0142ych: + - * / not and or div mod ord chr sizeof pi const e = 2.7182818; { Real type constant } f : single = 3.14; { Single type constant } a = 2; { Ordinal BYTE type constant } c = '4'; { Character type constant } s = 'atari'; { String type constant } sc = chr(32); ls = SizeOf(cardinal); Kompilator na podstawie warto\u015bci dobiera typ dla deklarowanych sta\u0142ych. Dla warto\u015bci 0..255 b\u0119dzie to typ BYTE , 256..65535 typ WORD , -128..127 typ SHORTINT itd. Istnieje mo\u017cliwo\u015b\u0107 okre\u015blenia typu przez programist\u0119, const x: word = 5; { wymuszenie typu sta\u0142ej } b: byte = -11; Dodatkowo kompilator ma predefiniowane sta\u0142e: NIL EOL __BUFFER TRUE FALSE MAXINT MAXSMALLINT PI NAN INFINITY NEGINFINITY","title":"CONST"},{"location":"typy/","text":"Podstawowe Type Range Size in bytes BYTE 0 .. 255 1 SHORTINT -128 .. 127 1 WORD 0 .. 65535 2 SMALLINT -32768 .. 32767 2 CARDINAL 0 .. 4294967295 4 LONGWORD 0 .. 4294967295 4 DWORD 0 .. 4294967295 4 UINT32 0 .. 4294967295 4 INTEGER -2147483648 .. 2147483647 4 LONGINT -2147483648 .. 2147483647 4 Logiczne Type Ord(True) Size in bytes BOOLEAN 1 1 Wyliczeniowe Typ wyliczeniowy w Mad-Pascal zosta\u0142 zaimplementowany w podstawowej postaci, tzn.: Type Days = (monday,tuesday,wednesday,thursday,friday, saturday,sunday); Joy = (right_down = 5, right_up, right, left_down = 9, left_up, left, down = 13, up, none); Typ wyliczeniowy przechowywany jest tylko w pami\u0119ci kompilatora Mad-Pascal , do pliku wynikowego nie zostan\u0105 zapisane jakiekolwiek informacje dotycz\u0105ce p\u00f3l typu wyliczeniowego. Dopuszczalne jest u\u017cycie komendy ORD , SIZEOF oraz rzutowania dla typu wyliczeniowego. var d: Days; d:=friday; writeln(ord(d)); writeln(ord(sunday)); writeln(sizeof(days)); writeln(sizeof(monday)); d:=days(20); case d of sunday: writeln('sunday'); end; Aktualnie kompilator Mad-Pascal nie sprawdzi poprawno\u015bci typ\u00f3w wyliczeniowych dla operacji IF ELSE . Rzeczywiste Type Range Size in bytes SHORTREAL (Q8.8) -128..127 2 REAL (Q24.8) -8388608..8388607 4 SINGLE (IEEE-754) 1.5E-45 .. 3.4E38 4 FLOAT (IEEE-754) 1.5E-45 .. 3.4E38 4 FLOAT16 (IEEE-754) 65504 .. -65504 2 Konwersja typu FLOAT , SINGLE do liczby ca\u0142kowitej dost\u0119pna jest tylko w zakresie INTEGER . Typ INTEGER nie pozwoli zaprezentowa\u0107 maksymalnej warto\u015bci 3.4E38 typu FLOAT SINGLE . Znakowe Type Range Size in bytes CHAR ATASCII (0 .. 255) 1 STRING 1 .. 255 256 PCHAR 0 .. 65535 2 Ci\u0105g znak\u00f3w STRING reprezentowany jest jako tablica o mo\u017cliwym maksymalnym rozmiarze [0..255] (w FPC ten typ to SHORTSTRING ). Pierwszym bajtem takiej tablicy [0] jest d\u0142ugo\u015b\u0107 ci\u0105gu z zakresu 0..255 . Od bajtu [1..] zaczyna si\u0119 w\u0142a\u015bciwy ci\u0105g znak\u00f3w. W FPC STRING nie jest r\u00f3wnoznaczny z SHORTSTRING , inaczej ustalamy adresy dla FPC STRING , inaczej dla SHORTSTRING . var P: PChar; s: string; P:=pointer(s); P:=pointer(@s); var P: PChar; s: string[255]; // shortstring P:=pointer(@s); // s[0] P:=pointer(@s[1]); Ci\u0105g znak\u00f3w PCHAR reprezentowany jest przez wska\u017anik do typu CHAR . Znakiem ko\u0144ca ci\u0105gu PCHAR jest znak #0 . Dopuszczalne jest u\u017cycie dodatkowych znak\u00f3w po ko\u0144cowym apostrofie, takich jak * , ~ . Znak * oznacza ci\u0105g w inwersie, tylda ~ ci\u0105g w kodach ANTIC-a . Innym sposobem modyfikacji wyprowadzanych znak\u00f3w jest u\u017cycie systemowej zmiennej TextAttr , ka\u017cdy znak wyprowadzany na ekran jest poddawany operacji ORA TextAttr (domy\u015blnie TextAttr = 0 ). a: string = 'Atari'*; // ci\u0105g znak\u00f3w w inwersie b: string = 'Spectrum'~; // ci\u0105g znak\u00f3w w kodach ANTIC-a c: char = 'X'~*; // znak w inwersie, kodach ANTIC-a Wska\u017anikowe Type Range Size in bytes POINTER 0 .. 65535 2 Wska\u017aniki w Mad-Pascal mog\u0105 by\u0107 typowane i bez okre\u015blonego typu, np.: a: ^word; // wska\u017anik typowany na s\u0142owo b: pointer; // wska\u017anik bez typu Niezaincjowany wska\u017anik najcz\u0119\u015bciej b\u0119dzie mia\u0142 adres $0000 , nale\u017cy zadba\u0107 aby przed jego wykorzystaniem zaincjowa\u0107 go adresem odpowiedniej zmiennej, np.: a := @tmp; // wska\u017anikowi A zostaje przypisany adres zmiennej TMP Je\u015bli tego nie zrobimy to w przypadku uruchomienia takiego programu na PC spowodujemy b\u0142\u0105d ochrony pami\u0119ci Access Violation . Zwi\u0119kszanie wska\u017anika przez INC zwi\u0119kszy go o rozmiar typu na jaki wskazuje. Zmniejszenie wska\u017anika przez DEC zmniejszy go o rozmiar typu na jaki wskazuje. Je\u015bli typ jest nieokre\u015blony, w\u00f3wczas domy\u015bln\u0105 warto\u015bci\u0105 zwi\u0119kszania/zmniejszanie b\u0119dzie 1 . Dla wska\u017anik\u00f3w dopuszczalne s\u0105 operacje relacji = , <> , < , <= , > , >= , oraz operacje arytmetyczne + oraz - . Przy pomocy wska\u017anika mo\u017cemy dokona\u0107 rzutowania zmiennej na inny typ: var s: single; d: cardinal; begin s := 3.14; d:=PCardinal(@s)^; // d = $4048F5C3 end; Tablice statyczne Tablice w Mad-Pascal s\u0105 tylko statyczne, jednowymiarowe lub dwuwymiarowe z pocz\u0105tkowym indeksem r\u00f3wnym 0 , np.: var tb: array [0..100] of word; var tb2: array [0..15, 0..31] of Boolean; var tab: array [0..7] of array [0..31] of byte; var tab256: array [byte] of word; var [striped] tb: array [0..99] of cardinal; W przypadku pocz\u0105tkowego indeksu innego ni\u017c zero zostanie wygenerowany b\u0142\u0105d Error: Array lower bound is not zero . W pami\u0119ci tablica reprezentowana jest przez wska\u017anik POINTER , wska\u017anik jest adresem tablicy w pami\u0119ci WORD . Najszybsz\u0105 metod\u0105 odwo\u0142ania si\u0119 do tablicy nie przekraczaj\u0105cej 256 bajt\u00f3w z poziomu assemblera jest zastosowanie przedrostka ADR. , np.: asm lda adr.tb,y ; bezpo\u015brednie odwo\u0142anie do tablicy TB lda tb ; odwo\u0142anie do wska\u017anika tablicy TB end; Kompilator generuje kod dla tablic zale\u017cnie od ich deklaracji: gdy nie przekracza 256 bajt\u00f3w array [0..255] of byte; array [0..127] of word; array [0..63] of cardinal; Gdy liczba bajt\u00f3w zajmowanych przez tablic\u0119 nie przekracza 256 bajt\u00f3w generowany jest najszybszy kod odwo\u0142uj\u0105cy si\u0119 bezpo\u015brednio do adresu tablicy (przedrostek ADR. ) z pomini\u0119ciem wska\u017anika. Dla takiej tablicy nie ma mo\u017cliwo\u015bci zmiany adresu. ldy #118 lda adr.tb,y gdy liczba element\u00f3w tablicy wynosi 1 array [0..0] of type; Gdy liczba element\u00f3w tablicy wynosi 1 jest ona traktowana specjalnie. Generowany kod odwo\u0142uje si\u0119 do tablicy poprzez wzka\u017anik. Istnieje mo\u017cliwo\u015b\u0107 ustalenia nowego adresu takiej tablicy. lda TB add I tay lda TB+1 adc #$00 sta bp+1 lda (bp),y gdy przekracza 256 bajt\u00f3w array [0..255+1] of byte; array [0..127+1] of word; array [0..63+1] of cardinal; Gdy liczba bajt\u00f3w zajmowanych przez tablic\u0119 przekracza 256 bajt\u00f3w generowany kod odwo\u0142uje si\u0119 do tablicy poprzez wska\u017anik. Istnieje mo\u017cliwo\u015b\u0107 ustalenia nowego adresu takiej tablicy. lda TB add I tay lda TB+1 adc #$00 sta bp+1 lda (bp),y Tablice STRIPED Dla poni\u017cszego przyk\u0142ady kompilator musi pomno\u017cy\u0107 indeks przez dwa, aby uzyska\u0107 dost\u0119p do ka\u017cdego elementu. array [0..7] of word; Uk\u0142ad pami\u0119ci takiej tablicy b\u0119dzie nast\u0119puj\u0105cy: LHLHLHLHLHLHLHLH Je\u015bli oznaczymy tablic\u0119 jako STRIPED [striped] array [0..7] of word; wygeneruje to nast\u0119puj\u0105c\u0105 struktur\u0119 w pami\u0119ci: LLLLLLLLHHHHHHHH Modyfikator STRIPED mo\u017cna stosowa\u0107 tylko dla tablic z typem prostym ( WORD , CARDINAL , SMALLINT , INTEGER , SHORTREAL , REAL , FLOAT16 , POINTER ). Modyfikator STRIPED nie zadzia\u0142a dla tablic z indeksem wi\u0119kszym ni\u017c 255 . Inicjalizacja tablic Inicjalizacja tablicy CONST lub VAR przebiega w ten sam spos\u00f3b. Po s\u0142owie okre\u015blaj\u0105cym typ danych tablicy umieszczamy znak = i kolejne elementy tablicy mi\u0119dzy nawiasami okr\u0105g\u0142ymi ( val0, val1, ... ) : const PBox : array [0..1] of word = (12,10); var PBox : array [0..1] of word = (12,10); W przypadku tablicy dwuwymiarowej: PBox : array [0..1, 0..1] of word = ( (12,10) , (1,6) ); Tablic\u0119 typu CHAR mo\u017cemy zaincjowa\u0107 przez STRING : PBox : array [0..4] of char = 'Hello'; Mo\u017cliwa jest inicjalizacja tablicy bez podawania jej rozmiaru, korzystamy wtedy z nawias\u00f3w kwadratowych [ ] : PBox : array of char = ['H', 'e', 'l', 'l', 'o']; PBox : array of word = [1,2,3,4,5]; PBox : array of char = 'Hello'; // bez nawias\u00f3w [ ] $bin2csv Mo\u017cliwe jest zaincjowanie tablicy typu BYTE plikiem binarnym, u\u017cywamy wtedy dyrektywy kompilatora {$bin2csv filename} : tb: array of byte = [ {$bin2csv filename} ]; tb: array [0..11] of byte = ( 1,2,3, {$bin2csv filename} ); $eval Innym sposobem zaincjowania tablicy zadanego typu jest u\u017cycie dyrektywy {$eval par1[,par2],\"expression\"} : tb: array of cardinal = [ {$eval 100,\":1*32\"} ]; tb: array of pointer = [ {$eval 24,\"SCR_ADDRESS+:1*40\"} ]; tb: array [0..11] of byte = ( {$eval 3,4,\":1*:2\"} ); Rekordy W pami\u0119ci rekord reprezentowany jest przez wska\u017anik POINTER . type TPoint = record x,y: byte end; var px: TPoint; Domy\u015blnie rekordy w Mad-Pascal s\u0105 typu PACKED . Rozmiar ca\u0142kowity p\u00f3l rekordu ograniczony jest do 256 bajt\u00f3w. Je\u015bli zale\u017cy nam na zachowaniu kompatybilno\u015bci z FPC nale\u017cy dodatkowo poprzedzi\u0107 s\u0142owo RECORD s\u0142owem PACKED . Bez tego rozmiar pami\u0119ci jaki zajmuje rekord b\u0119dzie m\u00f3g\u0142 si\u0119 r\u00f3\u017cni\u0107, b\u0119dzie mniej zajmowa\u0142 pami\u0119ci na 6502 , potencjalnie wi\u0119cej o kilka bajt\u00f3w na PC . type TPoint = packed record x,y: byte end; var px: TPoint; Dost\u0119p do p\u00f3l rekordu z poziomu asm: mwa px bp2 ldy #px.x-DATAORIGIN lda (bp2),y Tablica z rekordami Mad-Pascal obs\u0142uguje tylko tablice wska\u017anik\u00f3w rekord\u00f3w. type TPoint = record x,y: byte end; var tab: array [0..3] of ^TPoint; Taka tablica musi zosta\u0107 zaincjowana odpowiednimi adresami rekord\u00f3w, domy\u015blnie na pocz\u0105tku wszystkie pola takiej tablicy s\u0105 wyzerowane. Pierwszy spos\u00f3b zaincjowania tablicy wska\u017anik\u00f3w rekord\u00f3w: var a1,a2,a3,a4: TPoint; begin tab[0] := @a1; tab[1] := @a2; tab[2] := @a3; tab[3] := @a4; end. Drugi spos\u00f3b: begin GetMem(tab[0], sizeof(TPoint)); GetMem(tab[1], sizeof(TPoint)); GetMem(tab[2], sizeof(TPoint)); GetMem(tab[3], sizeof(TPoint)); end. Dost\u0119p do p\u00f3l rekordu z takiej tablicy: writeln(tab[1].x); writeln(tab[1].y); Obiektowe Obiekty to rekordy z dodatkowymi metodami. W pami\u0119ci obiekt reprezentowany jest przez wska\u017anik POINTER . type TRMT = Object player: pointer; modul: pointer; procedure Init(a: byte); assembler; procedure Play; assembler; procedure Stop; assembler; end; W obiektach mo\u017cliwe jest u\u017cycie procedur CONSTRUCTOR oraz DESTRUCTOR . Wywo\u0142anie takich procedur odbywa si\u0119 tylko r\u0119cznie. Proceduralne W pami\u0119ci zmienne typu proceduralnego reprezentowane s\u0105 przez wska\u017anik POINTER . type tprc = procedure (a: byte; c: word); tfun = function (a:smallint; x: single): byte; var fn: function (a,b,c: byte): word; Dla typu proceduralnego procedury/funkcje z argumentami wymagaj\u0105 u\u017cycia modyfikatora STDCALL , co wymusi u\u017cycie stosu programowego. var fn: function (a,b: word): word; function test(a,b,c,d: word): word; stdcall; begin end; begin fn := @test; fn(1,2); end; Dla procedur z argumentami zamiast modyfikatora STDCALL dopuszczalny jest modyfikator REGISTER , pod warunkiem \u017ce b\u0119d\u0105 to maksymalnie trzy argumenty. var prc: procedure (a,b: word); procedure test(a,b,c: cardinal); register; begin // a -> EDX // b -> ECX // c -> EAX end; begin prc := @test; prc(3,6); end; W przypadku kiedy nie przekazujemy do procedury/funkcji argument\u00f3w u\u017cycie modyfikatora nie jest konieczne. Plikowe binarne Typ FILE reprezentuje uchwyt do pliku oraz definiuje rozmiar rekordu. type ftype = array [0..63] of cardinal; var f: file; // rekord domy\u015blny =128 bajt\u00f3w f: file of byte; // rekord 1 bajt f: file of ftype; // rekord 256 bajt\u00f3w (ftype = 64 * 4) W pami\u0119ci XE/XL uchwyt FILE reprezentowany jest przez wska\u017anik POINTER do tablicy o strukturze (rozmiar 12 bajt\u00f3w): .struct s@file pfname .word ; pointer to string with filename record .word ; record size chanel .byte ; channel *$10 eof .byte ; EOF status buffer .word ; load/write buffer nrecord .word ; number of records for load/write numread .word ; pointer to variable, length of loaded data .ends Do procedur, funkcji typ FILE mo\u017ce by\u0107 przekazywany tylko jako zmienna. Typy, procedury i funkcje zwi\u0105zane z plikami binarnymi: Assign - Close - Reset - Rewrite - BlockRead - BlockWrite - FileExists - IOResult Plikowe tekstowe Typ TEXT reprezentuje uchwyt do pliku tekstowego. var t: text; f: textfile; W pami\u0119ci XE/XL uchwyt TEXT reprezentowany jest przez wska\u017anik POINTER do tablicy o strukturze (rozmiar 12 bajt\u00f3w): .struct s@file pfname .word ; pointer to string with filename record .word ; record size chanel .byte ; channel *$10 eof .byte ; EOF status buffer .word ; load/write buffer nrecord .word ; number of records for load/write numread .word ; pointer to variable, length of loaded data .ends Do procedur, funkcji typ TEXT mo\u017ce by\u0107 przekazywany tylko jako zmienna. Typy, procedury i funkcje zwi\u0105zane z plikami tekstowymi: Assign - Close - Reset - Rewrite - Append - Readln - Writeln - FileExists - IOResult Nieoznaczone procedure Something (var Data); procedure Something (const Data); Brak podania typu parametru oznacza \u017ce do procedury/funkcji zostanie przekazany tylko adres parametru bez oznaczenia typu. Jest to odpowiednikiem nast\u0119puj\u0105cej deklaracji C/C++: void Something(void* Data); Wewn\u0105trz procedury/funkcji z nieoznaczonym parametrem, je\u015bli nieoznaczony parametr jest u\u017cywany w wyra\u017ceniu lub warto\u015b\u0107 musi by\u0107 do niego przypisana, zawsze nale\u017cy u\u017cy\u0107 rzutowania typu. var x: word; procedure test(var a); begin writeln(PWord(@a)^); // = 95 PWord(@a)^ := 11; end; begin x:=95; test(x); // = 11 end.","title":"Typy"},{"location":"typy/#_1","text":"","title":""},{"location":"typy/#podstawowe","text":"Type Range Size in bytes BYTE 0 .. 255 1 SHORTINT -128 .. 127 1 WORD 0 .. 65535 2 SMALLINT -32768 .. 32767 2 CARDINAL 0 .. 4294967295 4 LONGWORD 0 .. 4294967295 4 DWORD 0 .. 4294967295 4 UINT32 0 .. 4294967295 4 INTEGER -2147483648 .. 2147483647 4 LONGINT -2147483648 .. 2147483647 4","title":"Podstawowe"},{"location":"typy/#logiczne","text":"Type Ord(True) Size in bytes BOOLEAN 1 1","title":"Logiczne"},{"location":"typy/#wyliczeniowe","text":"Typ wyliczeniowy w Mad-Pascal zosta\u0142 zaimplementowany w podstawowej postaci, tzn.: Type Days = (monday,tuesday,wednesday,thursday,friday, saturday,sunday); Joy = (right_down = 5, right_up, right, left_down = 9, left_up, left, down = 13, up, none); Typ wyliczeniowy przechowywany jest tylko w pami\u0119ci kompilatora Mad-Pascal , do pliku wynikowego nie zostan\u0105 zapisane jakiekolwiek informacje dotycz\u0105ce p\u00f3l typu wyliczeniowego. Dopuszczalne jest u\u017cycie komendy ORD , SIZEOF oraz rzutowania dla typu wyliczeniowego. var d: Days; d:=friday; writeln(ord(d)); writeln(ord(sunday)); writeln(sizeof(days)); writeln(sizeof(monday)); d:=days(20); case d of sunday: writeln('sunday'); end; Aktualnie kompilator Mad-Pascal nie sprawdzi poprawno\u015bci typ\u00f3w wyliczeniowych dla operacji IF ELSE .","title":"Wyliczeniowe"},{"location":"typy/#rzeczywiste","text":"Type Range Size in bytes SHORTREAL (Q8.8) -128..127 2 REAL (Q24.8) -8388608..8388607 4 SINGLE (IEEE-754) 1.5E-45 .. 3.4E38 4 FLOAT (IEEE-754) 1.5E-45 .. 3.4E38 4 FLOAT16 (IEEE-754) 65504 .. -65504 2 Konwersja typu FLOAT , SINGLE do liczby ca\u0142kowitej dost\u0119pna jest tylko w zakresie INTEGER . Typ INTEGER nie pozwoli zaprezentowa\u0107 maksymalnej warto\u015bci 3.4E38 typu FLOAT SINGLE .","title":"Rzeczywiste"},{"location":"typy/#znakowe","text":"Type Range Size in bytes CHAR ATASCII (0 .. 255) 1 STRING 1 .. 255 256 PCHAR 0 .. 65535 2 Ci\u0105g znak\u00f3w STRING reprezentowany jest jako tablica o mo\u017cliwym maksymalnym rozmiarze [0..255] (w FPC ten typ to SHORTSTRING ). Pierwszym bajtem takiej tablicy [0] jest d\u0142ugo\u015b\u0107 ci\u0105gu z zakresu 0..255 . Od bajtu [1..] zaczyna si\u0119 w\u0142a\u015bciwy ci\u0105g znak\u00f3w. W FPC STRING nie jest r\u00f3wnoznaczny z SHORTSTRING , inaczej ustalamy adresy dla FPC STRING , inaczej dla SHORTSTRING . var P: PChar; s: string; P:=pointer(s); P:=pointer(@s); var P: PChar; s: string[255]; // shortstring P:=pointer(@s); // s[0] P:=pointer(@s[1]); Ci\u0105g znak\u00f3w PCHAR reprezentowany jest przez wska\u017anik do typu CHAR . Znakiem ko\u0144ca ci\u0105gu PCHAR jest znak #0 . Dopuszczalne jest u\u017cycie dodatkowych znak\u00f3w po ko\u0144cowym apostrofie, takich jak * , ~ . Znak * oznacza ci\u0105g w inwersie, tylda ~ ci\u0105g w kodach ANTIC-a . Innym sposobem modyfikacji wyprowadzanych znak\u00f3w jest u\u017cycie systemowej zmiennej TextAttr , ka\u017cdy znak wyprowadzany na ekran jest poddawany operacji ORA TextAttr (domy\u015blnie TextAttr = 0 ). a: string = 'Atari'*; // ci\u0105g znak\u00f3w w inwersie b: string = 'Spectrum'~; // ci\u0105g znak\u00f3w w kodach ANTIC-a c: char = 'X'~*; // znak w inwersie, kodach ANTIC-a","title":"Znakowe"},{"location":"typy/#wskaznikowe","text":"Type Range Size in bytes POINTER 0 .. 65535 2 Wska\u017aniki w Mad-Pascal mog\u0105 by\u0107 typowane i bez okre\u015blonego typu, np.: a: ^word; // wska\u017anik typowany na s\u0142owo b: pointer; // wska\u017anik bez typu Niezaincjowany wska\u017anik najcz\u0119\u015bciej b\u0119dzie mia\u0142 adres $0000 , nale\u017cy zadba\u0107 aby przed jego wykorzystaniem zaincjowa\u0107 go adresem odpowiedniej zmiennej, np.: a := @tmp; // wska\u017anikowi A zostaje przypisany adres zmiennej TMP Je\u015bli tego nie zrobimy to w przypadku uruchomienia takiego programu na PC spowodujemy b\u0142\u0105d ochrony pami\u0119ci Access Violation . Zwi\u0119kszanie wska\u017anika przez INC zwi\u0119kszy go o rozmiar typu na jaki wskazuje. Zmniejszenie wska\u017anika przez DEC zmniejszy go o rozmiar typu na jaki wskazuje. Je\u015bli typ jest nieokre\u015blony, w\u00f3wczas domy\u015bln\u0105 warto\u015bci\u0105 zwi\u0119kszania/zmniejszanie b\u0119dzie 1 . Dla wska\u017anik\u00f3w dopuszczalne s\u0105 operacje relacji = , <> , < , <= , > , >= , oraz operacje arytmetyczne + oraz - . Przy pomocy wska\u017anika mo\u017cemy dokona\u0107 rzutowania zmiennej na inny typ: var s: single; d: cardinal; begin s := 3.14; d:=PCardinal(@s)^; // d = $4048F5C3 end;","title":"Wska\u017anikowe"},{"location":"typy/#tablice-statyczne","text":"Tablice w Mad-Pascal s\u0105 tylko statyczne, jednowymiarowe lub dwuwymiarowe z pocz\u0105tkowym indeksem r\u00f3wnym 0 , np.: var tb: array [0..100] of word; var tb2: array [0..15, 0..31] of Boolean; var tab: array [0..7] of array [0..31] of byte; var tab256: array [byte] of word; var [striped] tb: array [0..99] of cardinal; W przypadku pocz\u0105tkowego indeksu innego ni\u017c zero zostanie wygenerowany b\u0142\u0105d Error: Array lower bound is not zero . W pami\u0119ci tablica reprezentowana jest przez wska\u017anik POINTER , wska\u017anik jest adresem tablicy w pami\u0119ci WORD . Najszybsz\u0105 metod\u0105 odwo\u0142ania si\u0119 do tablicy nie przekraczaj\u0105cej 256 bajt\u00f3w z poziomu assemblera jest zastosowanie przedrostka ADR. , np.: asm lda adr.tb,y ; bezpo\u015brednie odwo\u0142anie do tablicy TB lda tb ; odwo\u0142anie do wska\u017anika tablicy TB end; Kompilator generuje kod dla tablic zale\u017cnie od ich deklaracji: gdy nie przekracza 256 bajt\u00f3w array [0..255] of byte; array [0..127] of word; array [0..63] of cardinal; Gdy liczba bajt\u00f3w zajmowanych przez tablic\u0119 nie przekracza 256 bajt\u00f3w generowany jest najszybszy kod odwo\u0142uj\u0105cy si\u0119 bezpo\u015brednio do adresu tablicy (przedrostek ADR. ) z pomini\u0119ciem wska\u017anika. Dla takiej tablicy nie ma mo\u017cliwo\u015bci zmiany adresu. ldy #118 lda adr.tb,y gdy liczba element\u00f3w tablicy wynosi 1 array [0..0] of type; Gdy liczba element\u00f3w tablicy wynosi 1 jest ona traktowana specjalnie. Generowany kod odwo\u0142uje si\u0119 do tablicy poprzez wzka\u017anik. Istnieje mo\u017cliwo\u015b\u0107 ustalenia nowego adresu takiej tablicy. lda TB add I tay lda TB+1 adc #$00 sta bp+1 lda (bp),y gdy przekracza 256 bajt\u00f3w array [0..255+1] of byte; array [0..127+1] of word; array [0..63+1] of cardinal; Gdy liczba bajt\u00f3w zajmowanych przez tablic\u0119 przekracza 256 bajt\u00f3w generowany kod odwo\u0142uje si\u0119 do tablicy poprzez wska\u017anik. Istnieje mo\u017cliwo\u015b\u0107 ustalenia nowego adresu takiej tablicy. lda TB add I tay lda TB+1 adc #$00 sta bp+1 lda (bp),y","title":"Tablice statyczne"},{"location":"typy/#tablice-striped","text":"Dla poni\u017cszego przyk\u0142ady kompilator musi pomno\u017cy\u0107 indeks przez dwa, aby uzyska\u0107 dost\u0119p do ka\u017cdego elementu. array [0..7] of word; Uk\u0142ad pami\u0119ci takiej tablicy b\u0119dzie nast\u0119puj\u0105cy: LHLHLHLHLHLHLHLH Je\u015bli oznaczymy tablic\u0119 jako STRIPED [striped] array [0..7] of word; wygeneruje to nast\u0119puj\u0105c\u0105 struktur\u0119 w pami\u0119ci: LLLLLLLLHHHHHHHH Modyfikator STRIPED mo\u017cna stosowa\u0107 tylko dla tablic z typem prostym ( WORD , CARDINAL , SMALLINT , INTEGER , SHORTREAL , REAL , FLOAT16 , POINTER ). Modyfikator STRIPED nie zadzia\u0142a dla tablic z indeksem wi\u0119kszym ni\u017c 255 .","title":"Tablice STRIPED"},{"location":"typy/#inicjalizacja-tablic","text":"Inicjalizacja tablicy CONST lub VAR przebiega w ten sam spos\u00f3b. Po s\u0142owie okre\u015blaj\u0105cym typ danych tablicy umieszczamy znak = i kolejne elementy tablicy mi\u0119dzy nawiasami okr\u0105g\u0142ymi ( val0, val1, ... ) : const PBox : array [0..1] of word = (12,10); var PBox : array [0..1] of word = (12,10); W przypadku tablicy dwuwymiarowej: PBox : array [0..1, 0..1] of word = ( (12,10) , (1,6) ); Tablic\u0119 typu CHAR mo\u017cemy zaincjowa\u0107 przez STRING : PBox : array [0..4] of char = 'Hello'; Mo\u017cliwa jest inicjalizacja tablicy bez podawania jej rozmiaru, korzystamy wtedy z nawias\u00f3w kwadratowych [ ] : PBox : array of char = ['H', 'e', 'l', 'l', 'o']; PBox : array of word = [1,2,3,4,5]; PBox : array of char = 'Hello'; // bez nawias\u00f3w [ ]","title":"Inicjalizacja tablic"},{"location":"typy/#bin2csv","text":"Mo\u017cliwe jest zaincjowanie tablicy typu BYTE plikiem binarnym, u\u017cywamy wtedy dyrektywy kompilatora {$bin2csv filename} : tb: array of byte = [ {$bin2csv filename} ]; tb: array [0..11] of byte = ( 1,2,3, {$bin2csv filename} );","title":"$bin2csv"},{"location":"typy/#eval","text":"Innym sposobem zaincjowania tablicy zadanego typu jest u\u017cycie dyrektywy {$eval par1[,par2],\"expression\"} : tb: array of cardinal = [ {$eval 100,\":1*32\"} ]; tb: array of pointer = [ {$eval 24,\"SCR_ADDRESS+:1*40\"} ]; tb: array [0..11] of byte = ( {$eval 3,4,\":1*:2\"} );","title":"$eval"},{"location":"typy/#rekordy","text":"W pami\u0119ci rekord reprezentowany jest przez wska\u017anik POINTER . type TPoint = record x,y: byte end; var px: TPoint; Domy\u015blnie rekordy w Mad-Pascal s\u0105 typu PACKED . Rozmiar ca\u0142kowity p\u00f3l rekordu ograniczony jest do 256 bajt\u00f3w. Je\u015bli zale\u017cy nam na zachowaniu kompatybilno\u015bci z FPC nale\u017cy dodatkowo poprzedzi\u0107 s\u0142owo RECORD s\u0142owem PACKED . Bez tego rozmiar pami\u0119ci jaki zajmuje rekord b\u0119dzie m\u00f3g\u0142 si\u0119 r\u00f3\u017cni\u0107, b\u0119dzie mniej zajmowa\u0142 pami\u0119ci na 6502 , potencjalnie wi\u0119cej o kilka bajt\u00f3w na PC . type TPoint = packed record x,y: byte end; var px: TPoint; Dost\u0119p do p\u00f3l rekordu z poziomu asm: mwa px bp2 ldy #px.x-DATAORIGIN lda (bp2),y","title":"Rekordy"},{"location":"typy/#tablica-z-rekordami","text":"Mad-Pascal obs\u0142uguje tylko tablice wska\u017anik\u00f3w rekord\u00f3w. type TPoint = record x,y: byte end; var tab: array [0..3] of ^TPoint; Taka tablica musi zosta\u0107 zaincjowana odpowiednimi adresami rekord\u00f3w, domy\u015blnie na pocz\u0105tku wszystkie pola takiej tablicy s\u0105 wyzerowane. Pierwszy spos\u00f3b zaincjowania tablicy wska\u017anik\u00f3w rekord\u00f3w: var a1,a2,a3,a4: TPoint; begin tab[0] := @a1; tab[1] := @a2; tab[2] := @a3; tab[3] := @a4; end. Drugi spos\u00f3b: begin GetMem(tab[0], sizeof(TPoint)); GetMem(tab[1], sizeof(TPoint)); GetMem(tab[2], sizeof(TPoint)); GetMem(tab[3], sizeof(TPoint)); end. Dost\u0119p do p\u00f3l rekordu z takiej tablicy: writeln(tab[1].x); writeln(tab[1].y);","title":"Tablica z rekordami"},{"location":"typy/#obiektowe","text":"Obiekty to rekordy z dodatkowymi metodami. W pami\u0119ci obiekt reprezentowany jest przez wska\u017anik POINTER . type TRMT = Object player: pointer; modul: pointer; procedure Init(a: byte); assembler; procedure Play; assembler; procedure Stop; assembler; end; W obiektach mo\u017cliwe jest u\u017cycie procedur CONSTRUCTOR oraz DESTRUCTOR . Wywo\u0142anie takich procedur odbywa si\u0119 tylko r\u0119cznie.","title":"Obiektowe"},{"location":"typy/#proceduralne","text":"W pami\u0119ci zmienne typu proceduralnego reprezentowane s\u0105 przez wska\u017anik POINTER . type tprc = procedure (a: byte; c: word); tfun = function (a:smallint; x: single): byte; var fn: function (a,b,c: byte): word; Dla typu proceduralnego procedury/funkcje z argumentami wymagaj\u0105 u\u017cycia modyfikatora STDCALL , co wymusi u\u017cycie stosu programowego. var fn: function (a,b: word): word; function test(a,b,c,d: word): word; stdcall; begin end; begin fn := @test; fn(1,2); end; Dla procedur z argumentami zamiast modyfikatora STDCALL dopuszczalny jest modyfikator REGISTER , pod warunkiem \u017ce b\u0119d\u0105 to maksymalnie trzy argumenty. var prc: procedure (a,b: word); procedure test(a,b,c: cardinal); register; begin // a -> EDX // b -> ECX // c -> EAX end; begin prc := @test; prc(3,6); end; W przypadku kiedy nie przekazujemy do procedury/funkcji argument\u00f3w u\u017cycie modyfikatora nie jest konieczne.","title":"Proceduralne"},{"location":"typy/#plikowe-binarne","text":"Typ FILE reprezentuje uchwyt do pliku oraz definiuje rozmiar rekordu. type ftype = array [0..63] of cardinal; var f: file; // rekord domy\u015blny =128 bajt\u00f3w f: file of byte; // rekord 1 bajt f: file of ftype; // rekord 256 bajt\u00f3w (ftype = 64 * 4) W pami\u0119ci XE/XL uchwyt FILE reprezentowany jest przez wska\u017anik POINTER do tablicy o strukturze (rozmiar 12 bajt\u00f3w): .struct s@file pfname .word ; pointer to string with filename record .word ; record size chanel .byte ; channel *$10 eof .byte ; EOF status buffer .word ; load/write buffer nrecord .word ; number of records for load/write numread .word ; pointer to variable, length of loaded data .ends Do procedur, funkcji typ FILE mo\u017ce by\u0107 przekazywany tylko jako zmienna. Typy, procedury i funkcje zwi\u0105zane z plikami binarnymi: Assign - Close - Reset - Rewrite - BlockRead - BlockWrite - FileExists - IOResult","title":"Plikowe binarne"},{"location":"typy/#plikowe-tekstowe","text":"Typ TEXT reprezentuje uchwyt do pliku tekstowego. var t: text; f: textfile; W pami\u0119ci XE/XL uchwyt TEXT reprezentowany jest przez wska\u017anik POINTER do tablicy o strukturze (rozmiar 12 bajt\u00f3w): .struct s@file pfname .word ; pointer to string with filename record .word ; record size chanel .byte ; channel *$10 eof .byte ; EOF status buffer .word ; load/write buffer nrecord .word ; number of records for load/write numread .word ; pointer to variable, length of loaded data .ends Do procedur, funkcji typ TEXT mo\u017ce by\u0107 przekazywany tylko jako zmienna. Typy, procedury i funkcje zwi\u0105zane z plikami tekstowymi: Assign - Close - Reset - Rewrite - Append - Readln - Writeln - FileExists - IOResult","title":"Plikowe tekstowe"},{"location":"typy/#nieoznaczone","text":"procedure Something (var Data); procedure Something (const Data); Brak podania typu parametru oznacza \u017ce do procedury/funkcji zostanie przekazany tylko adres parametru bez oznaczenia typu. Jest to odpowiednikiem nast\u0119puj\u0105cej deklaracji C/C++: void Something(void* Data); Wewn\u0105trz procedury/funkcji z nieoznaczonym parametrem, je\u015bli nieoznaczony parametr jest u\u017cywany w wyra\u017ceniu lub warto\u015b\u0107 musi by\u0107 do niego przypisana, zawsze nale\u017cy u\u017cy\u0107 rzutowania typu. var x: word; procedure test(var a); begin writeln(PWord(@a)^); // = 95 PWord(@a)^ := 11; end; begin x:=95; test(x); // = 11 end.","title":"Nieoznaczone"},{"location":"wprowadzenie/","text":"Wst\u0119p Mad-Pascal (MP) jest 32-bitowym kompilatorem Turbo Pascala dla Atari XE/XL . W za\u0142o\u017ceniu jest kompatybilny z Free Pascal Compilator (FPC) (prze\u0142\u0105cznik -MDelphi powinien by\u0107 aktywny), co oznacza mo\u017cliwo\u015b\u0107 otrzymania kodu uruchomieniowego dla XE/XL , PC i ka\u017cdej innej platformy dla kt\u00f3rej istnieje FPC . Mad-Pascal nie jest portem FPC , zosta\u0142 napisany na podstawie kompilator\u00f3w SUB-Pascal (2009), XD-Pascal (2010), kt\u00f3rych autorem jest Vasiliy Tereshkov . Program, kt\u00f3ry zadzia\u0142a na Atari mo\u017ce mie\u0107 problem na PC je\u017celi np. nie zaincjowali\u015bmy wska\u017anik\u00f3w adresem zmiennej, b\u0119dziemy pr\u00f3bowali zapisywa\u0107 co\u015b pod adresem $0000 (b\u0142\u0105d ochrony pami\u0119ci). Mocn\u0105 stron\u0105 Mad-Pascal jest szybka i wygodna mo\u017cliwo\u015b\u0107 do\u0142\u0105czania wstawek assemblerowych. Program z wstawkami ASM nie b\u0119dzie dzia\u0142a\u0142 na innej platformie ni\u017c XE/XL. MP wykorzystuje 64KB pami\u0119ci podstawowej, korzystanie z pami\u0119ci rozszerzonej udost\u0119pnia TMemoryStream . Alokacja zmiennych jest statyczna, nie ma dynamicznego zarz\u0105dzania pami\u0119ci\u0105. Parametry przekazywane do funkcji i procedur s\u0105 przez warto\u015b\u0107, zmienn\u0105 lub sta\u0142\u0105. Dost\u0119pne s\u0105: If Case For While Repeat statements Compound statements Label Goto statements Arithmetic and boolean operators Procedures and functions with up to 8 parameters. Returned value of a function is assigned to a predefined RESULT variable Static local variables Primitive data types, all types except the ShortReal / Real type are compatible. Pointers are dereferenced as pointers to Word : Cardinal Word Byte Boolean String PChar Char Integer SmallInt ShortInt Pointer File Text ShortReal Real fixed-point Float Single Float16 One-dimensional and Two-dimensional arrays (with zero lower bound) of any primitive type. Arrays are treated as pointers to their origins (like in C) and can be passed to subroutines as parameters Predefined type string [N] which is equivalent to array [0..N] of Char Type aliases. Records Objects Separate program modules Separate library modules Recursion Uk\u0142ad katalog\u00f3w W katalogu z Mad-Pascal wymagana jest obecno\u015b\u0107 odpowiednich plik\u00f3w i podkatalog\u00f3w: mp\\ mp.exe base\\ rtl_default.asm rtl6502_a8.asm rtl6502_c4p.asm rtl6502_c64.asm rtl6502_neo.asm rtl6502_raw.asm atari\\ c4p\\ c64\\ common\\ neo\\ raw\\ runtime\\ lib\\ aplib.pas atari.pas blowfish.pas c64.pas ... src\\ targets\\ crt.inc graph.inc system.inc Kompilacja Aby skompilowa\u0107 \u017ar\u00f3d\u0142o Mad-Pascala nale\u017cy u\u017cy\u0107 kompilatora z pakietu Free Pascal Compiler ( FPC ), dost\u0119pnego na stronie projektu freepascal.org . Uruchamiamy instalator, wybieramy katalog w kt\u00f3rym zostanie zainstalowany FPC . Wa\u017cne jest aby nie u\u017cywa\u0107 w nazwie katalogu znaku wykrzyknika ! czy innych niestandardowych znak\u00f3w. Je\u015bli nie uda nam si\u0119 skompilowa\u0107 \u017cadnego pliku, najpewniej winna jest nie standardowa nazwa \u015bcie\u017cki. Linia komend uruchamiaj\u0105ca kompilacj\u0119 mo\u017ce wygl\u0105da\u0107 nast\u0119puj\u0105co (wielko\u015b\u0107 liter w nazwach parametr\u00f3w ma znaczenie): fpc -Mdelphi -v -O3 mp.pas -Mdelphi pozwala kompilowa\u0107 plik w formacie Delphi -v wy\u015bwietla wszystkie komunikaty b\u0142\u0119d\u00f3w i ostrze\u017ce\u0144 -O3 dokonuje optymalizacji kodu Biblioteki LIB BLIBS WLIBS Linki Free Pascal Reference Guide Mad Pascal - AtariArea (PL) Mad Pascal - AtariOnline (PL) Mad Pascal - AtariAge (ENG) Mad Pascal examples - AtariAge (ENG) Games in Mad Pascal - AtariAge (ENG) Atari XE/XL Pascal Compilers s","title":"Wprowadzenie"},{"location":"wprowadzenie/#_1","text":"","title":""},{"location":"wprowadzenie/#wstep","text":"Mad-Pascal (MP) jest 32-bitowym kompilatorem Turbo Pascala dla Atari XE/XL . W za\u0142o\u017ceniu jest kompatybilny z Free Pascal Compilator (FPC) (prze\u0142\u0105cznik -MDelphi powinien by\u0107 aktywny), co oznacza mo\u017cliwo\u015b\u0107 otrzymania kodu uruchomieniowego dla XE/XL , PC i ka\u017cdej innej platformy dla kt\u00f3rej istnieje FPC . Mad-Pascal nie jest portem FPC , zosta\u0142 napisany na podstawie kompilator\u00f3w SUB-Pascal (2009), XD-Pascal (2010), kt\u00f3rych autorem jest Vasiliy Tereshkov . Program, kt\u00f3ry zadzia\u0142a na Atari mo\u017ce mie\u0107 problem na PC je\u017celi np. nie zaincjowali\u015bmy wska\u017anik\u00f3w adresem zmiennej, b\u0119dziemy pr\u00f3bowali zapisywa\u0107 co\u015b pod adresem $0000 (b\u0142\u0105d ochrony pami\u0119ci). Mocn\u0105 stron\u0105 Mad-Pascal jest szybka i wygodna mo\u017cliwo\u015b\u0107 do\u0142\u0105czania wstawek assemblerowych. Program z wstawkami ASM nie b\u0119dzie dzia\u0142a\u0142 na innej platformie ni\u017c XE/XL. MP wykorzystuje 64KB pami\u0119ci podstawowej, korzystanie z pami\u0119ci rozszerzonej udost\u0119pnia TMemoryStream . Alokacja zmiennych jest statyczna, nie ma dynamicznego zarz\u0105dzania pami\u0119ci\u0105. Parametry przekazywane do funkcji i procedur s\u0105 przez warto\u015b\u0107, zmienn\u0105 lub sta\u0142\u0105. Dost\u0119pne s\u0105: If Case For While Repeat statements Compound statements Label Goto statements Arithmetic and boolean operators Procedures and functions with up to 8 parameters. Returned value of a function is assigned to a predefined RESULT variable Static local variables Primitive data types, all types except the ShortReal / Real type are compatible. Pointers are dereferenced as pointers to Word : Cardinal Word Byte Boolean String PChar Char Integer SmallInt ShortInt Pointer File Text ShortReal Real fixed-point Float Single Float16 One-dimensional and Two-dimensional arrays (with zero lower bound) of any primitive type. Arrays are treated as pointers to their origins (like in C) and can be passed to subroutines as parameters Predefined type string [N] which is equivalent to array [0..N] of Char Type aliases. Records Objects Separate program modules Separate library modules Recursion","title":"Wst\u0119p"},{"location":"wprowadzenie/#ukad-katalogow","text":"W katalogu z Mad-Pascal wymagana jest obecno\u015b\u0107 odpowiednich plik\u00f3w i podkatalog\u00f3w: mp\\ mp.exe base\\ rtl_default.asm rtl6502_a8.asm rtl6502_c4p.asm rtl6502_c64.asm rtl6502_neo.asm rtl6502_raw.asm atari\\ c4p\\ c64\\ common\\ neo\\ raw\\ runtime\\ lib\\ aplib.pas atari.pas blowfish.pas c64.pas ... src\\ targets\\ crt.inc graph.inc system.inc","title":"Uk\u0142ad katalog\u00f3w"},{"location":"wprowadzenie/#kompilacja","text":"Aby skompilowa\u0107 \u017ar\u00f3d\u0142o Mad-Pascala nale\u017cy u\u017cy\u0107 kompilatora z pakietu Free Pascal Compiler ( FPC ), dost\u0119pnego na stronie projektu freepascal.org . Uruchamiamy instalator, wybieramy katalog w kt\u00f3rym zostanie zainstalowany FPC . Wa\u017cne jest aby nie u\u017cywa\u0107 w nazwie katalogu znaku wykrzyknika ! czy innych niestandardowych znak\u00f3w. Je\u015bli nie uda nam si\u0119 skompilowa\u0107 \u017cadnego pliku, najpewniej winna jest nie standardowa nazwa \u015bcie\u017cki. Linia komend uruchamiaj\u0105ca kompilacj\u0119 mo\u017ce wygl\u0105da\u0107 nast\u0119puj\u0105co (wielko\u015b\u0107 liter w nazwach parametr\u00f3w ma znaczenie): fpc -Mdelphi -v -O3 mp.pas -Mdelphi pozwala kompilowa\u0107 plik w formacie Delphi -v wy\u015bwietla wszystkie komunikaty b\u0142\u0119d\u00f3w i ostrze\u017ce\u0144 -O3 dokonuje optymalizacji kodu","title":"Kompilacja"},{"location":"wprowadzenie/#biblioteki","text":"LIB BLIBS WLIBS","title":"Biblioteki"},{"location":"wprowadzenie/#linki","text":"Free Pascal Reference Guide Mad Pascal - AtariArea (PL) Mad Pascal - AtariOnline (PL) Mad Pascal - AtariAge (ENG) Mad Pascal examples - AtariAge (ENG) Games in Mad Pascal - AtariAge (ENG) Atari XE/XL Pascal Compilers s","title":"Linki"},{"location":"zasoby/","text":"Pliki zasob\u00f3w Sk\u0142adnia plik\u00f3w RC Pliki RC s\u0105 zwyk\u0142ymi plikami tekstowymi. Zawieraj\u0105 list\u0119 zasob\u00f3w, kt\u00f3re nale\u017cy w\u0142\u0105czy\u0107 do kompilowanego pliku. Podstawowy element sk\u0142adni wygl\u0105da nast\u0119puj\u0105co: NazwaZasobu TypZasobu NazwaPliku [0 0 0 0 0 0 0 0] RCLABEL RCTYPE RCFILE [PAR0, PAR1, PAR2, PAR3, PAR4, PAR5, PAR6, PAR7] W tre\u015bci pliku RC mog\u0105 znale\u017a\u0107 si\u0119 komentarze, poprzedzone znakiem ; lub # . Przyk\u0142ad pliku RC : ; to jest player MPT mpt_player MPTPLAY # to jest modul mpt_modul MPT 'porazka.mpt' dane RCDATA 'dane.xex' 6 Typ zasobu okre\u015bla format w\u0142\u0105czanego pliku. Typ zasobu Opis RCDATA Dowolny typ danych, np.: label RCDATA 'filename' label RCDATA 'filename' OFFSET EXTMEM Dowolny typ danych \u0142adowany do pami\u0119ci dodatkowej PORTB , adres \u0142adowania ustalany jest na podstawie RCLABEL RCASM Plik w assemblerze, kt\u00f3ry zostanie do\u0142\u0105czony i zasemblowany (makra nie s\u0105 dozwolone). DOSFILE Plik z nag\u0142\u00f3wkiem Atari DOS , adres \u0142adowania takiego pliku powinien by\u0107 identyczny jak RCLABEL LIBRARY Skompilowany modu\u0142 LIBRARY , \u0142adowany do banku RCLABEL RELOC Plik relokowalny w formacie Mad Assemblera , plik zostanie poddany relokacji pod wskazany adres RCLABEL RMT Plik modu\u0142u Raster Music Tracker-a , plik zostanie poddany relokacji pod wskazany adres RCLABEL MPT Plik modu\u0142u Music ProTracker-a , plik zostanie poddany relokacji pod wskazany adres RCLABEL CMC Plik modu\u0142u Chaos Music Composer-a , plik zostanie poddany relokacji pod wskazany adres RCLABEL SAPR Plik z danymi SAP-R, \u0142adowany pod wskazany adres RCLABEL PP Plik spakowny Power Packer -em, \u0142adowany pod wskazany adres RCLABEL RMTPLAY Player dla modu\u0142u RMT , \u0142adowany na pocz\u0105tek strony pami\u0119ci od adresu RCLABEL , jako RCFILE podajemy plik .FEAT , PAR0 tryb playera 0..3: 0 => compile RMTplayer for 4 tracks mono 1 => compile RMTplayer for 8 tracks stereo 2 => compile RMTplayer for 4 tracks stereo L1 R2 R3 L4 3 => compile RMTplayer for 4 tracks stereo L1 L2 R3 R4 oraz opcjonalnie PAR1 jako adres dla zmiennych na stronie zerowej (domy\u015blnie $E0 ) RMTPLAY2 Player dla modu\u0142u RMT , \u0142adowany na pocz\u0105tek strony pami\u0119ci od adresu RCLABEL , jako RCFILE podajemy plik .FEAT , PAR0 tryb playera 0..3: 0 => compile RMTplayer for 4 tracks mono 1 => compile RMTplayer for 8 tracks stereo 2 => compile RMTplayer for 4 tracks stereo L1 R2 R3 L4 3 => compile RMTplayer for 4 tracks stereo L1 L2 R3 R4 oraz opcjonalnie PAR1 jako adres dla zmiennych na stronie zerowej (domy\u015blnie $E0 ) SAPRPLAY Player SAP-R LZSS, nie wymaga podawania nazwy pliku RCFILE , adres RCLABEL tylko od pocz\u0105tku strony MPTPLAY Player dla modu\u0142u MPT , nie wymaga podawania nazwy pliku RCFILE CMCPLAY Player dla modu\u0142u CMC , nie wymaga podawania nazwy pliku RCFILE XBMP Plik BMP Windows Bitmap (8 BitsPerPixel) \u0142adowany do pami\u0119ci VBXE pod wskazany adres RCLABEL , od indeksu koloru PAR0 -> color select , w palecie kolor\u00f3w VBXE PAR1 -> palette select Mo\u017cliwo\u015b\u0107 \u0142adowania zasob\u00f3w pod ROM CMC RAM / ROM CMCPLAY RAM / ROM DOSFILE RAM / ROM EXTMEM LIBRARY PORTB MPT RAM / ROM MPTPLAY RAM / ROM PP RAM / ROM RCASM RAM / ROM RCDATA RAM / ROM RELOC RAM RMT RAM / ROM RMTPLAY RAM RMTPLAY2 RAM / ROM XBMP SAPR RAM / ROM SAPRPLAY RAM / ROM W\u0142\u0105czenie do aplikacji pliku RC W kodzie \u017ar\u00f3d\u0142owym programu nale\u017cy wpisa\u0107 dyrektyw\u0119 kompilatora (np. na pocz\u0105tku sekcji implementacji): {$R mojezasoby.rc} Dodatkowo nale\u017cy poda\u0107 w kodzie programu warto\u015b\u0107 dla etykiet RCLABEL odpowiednich zasob\u00f3w, np.: const mpt_player = $8000; mpt_modul = $9000; W\u0142\u0105czenie pliku RC nast\u0119puje w momencie kompilacji programu. Je\u015bli adres zasobu wskazuje adres $BC20.. , kt\u00f3ry normalnie zajmuje program ANTIC -a w\u00f3wczas wy\u0142\u0105czany jest ANTIC . Przy uruchomieniu programu nale\u017cy wpisa\u0107 odpowiedni\u0105 warto\u015b\u0107 do rejestru DMACTL aby w\u0142\u0105czy\u0107 obraz z powrotem. Je\u015bli adres zasobu wskazuje adres pod ROM z przedzia\u0142u $E000..$E3FF w\u00f3wczac wymuszana jest definicja symbolu NOROMFONT , kt\u00f3ry zapobiega przepisaniu zestawu znak\u00f3w gdy aktywujemy dyrektyw\u0119 {$define romoff} . Dost\u0119p do zasob\u00f3w. Zasoby umieszczane s\u0105 pod wskazanymi RCLABEL adresami w pami\u0119ci. Wyj\u0105tkiem s\u0105 zasoby RCDATA , SAPR , PP dla kt\u00f3rych mo\u017cliwe jest pomini\u0119cie definicji RCLABEL w kodzie programu. W przypadku braku definicji RCLABEL zas\u00f3b zostaje do\u0142\u0105czony do kompilowanego programu, dost\u0119p mo\u017cliwy jest poprzez procedur\u0119 GetResourceHandle . GetResourceHandle(pointer, 'rclabel'); Procedura GetResourceHandle ustala warto\u015b\u0107 wska\u017anika POINTER dla zasobu RCLABEL . SizeOfResource(variable, 'rclabel'); Procedura SizeOfResource zwraca d\u0142ugo\u015b\u0107 zasobu RCLABEL w zmiennej VARIABLE . RCASM W zasobach ASM nie ma mo\u017cliwo\u015bci u\u017cywania makr. SAPRPLAY Player SAP-R LZSS wymaga podania adresu od pocz\u0105tku strony pami\u0119ci. G\u0142\u00f3wny kod playera zajmuje $0300 bajt\u00f3w, bufory $0900 , w sumie $0C00 bajt\u00f3w. SAP-R jest to plik z kolejnymi warto\u015bciami rejestr\u00f3w POKEY -a ( $D200..$D208 ). Zapis pliku SAP-R umo\u017cliwia emulator Altirra , lub program RMT2LZSS .","title":"Pliki zasob\u00f3w"},{"location":"zasoby/#_1","text":"","title":""},{"location":"zasoby/#pliki-zasobow","text":"","title":"Pliki zasob\u00f3w"},{"location":"zasoby/#skadnia-plikow-rc","text":"Pliki RC s\u0105 zwyk\u0142ymi plikami tekstowymi. Zawieraj\u0105 list\u0119 zasob\u00f3w, kt\u00f3re nale\u017cy w\u0142\u0105czy\u0107 do kompilowanego pliku. Podstawowy element sk\u0142adni wygl\u0105da nast\u0119puj\u0105co: NazwaZasobu TypZasobu NazwaPliku [0 0 0 0 0 0 0 0] RCLABEL RCTYPE RCFILE [PAR0, PAR1, PAR2, PAR3, PAR4, PAR5, PAR6, PAR7] W tre\u015bci pliku RC mog\u0105 znale\u017a\u0107 si\u0119 komentarze, poprzedzone znakiem ; lub # . Przyk\u0142ad pliku RC : ; to jest player MPT mpt_player MPTPLAY # to jest modul mpt_modul MPT 'porazka.mpt' dane RCDATA 'dane.xex' 6 Typ zasobu okre\u015bla format w\u0142\u0105czanego pliku. Typ zasobu Opis RCDATA Dowolny typ danych, np.: label RCDATA 'filename' label RCDATA 'filename' OFFSET EXTMEM Dowolny typ danych \u0142adowany do pami\u0119ci dodatkowej PORTB , adres \u0142adowania ustalany jest na podstawie RCLABEL RCASM Plik w assemblerze, kt\u00f3ry zostanie do\u0142\u0105czony i zasemblowany (makra nie s\u0105 dozwolone). DOSFILE Plik z nag\u0142\u00f3wkiem Atari DOS , adres \u0142adowania takiego pliku powinien by\u0107 identyczny jak RCLABEL LIBRARY Skompilowany modu\u0142 LIBRARY , \u0142adowany do banku RCLABEL RELOC Plik relokowalny w formacie Mad Assemblera , plik zostanie poddany relokacji pod wskazany adres RCLABEL RMT Plik modu\u0142u Raster Music Tracker-a , plik zostanie poddany relokacji pod wskazany adres RCLABEL MPT Plik modu\u0142u Music ProTracker-a , plik zostanie poddany relokacji pod wskazany adres RCLABEL CMC Plik modu\u0142u Chaos Music Composer-a , plik zostanie poddany relokacji pod wskazany adres RCLABEL SAPR Plik z danymi SAP-R, \u0142adowany pod wskazany adres RCLABEL PP Plik spakowny Power Packer -em, \u0142adowany pod wskazany adres RCLABEL RMTPLAY Player dla modu\u0142u RMT , \u0142adowany na pocz\u0105tek strony pami\u0119ci od adresu RCLABEL , jako RCFILE podajemy plik .FEAT , PAR0 tryb playera 0..3: 0 => compile RMTplayer for 4 tracks mono 1 => compile RMTplayer for 8 tracks stereo 2 => compile RMTplayer for 4 tracks stereo L1 R2 R3 L4 3 => compile RMTplayer for 4 tracks stereo L1 L2 R3 R4 oraz opcjonalnie PAR1 jako adres dla zmiennych na stronie zerowej (domy\u015blnie $E0 ) RMTPLAY2 Player dla modu\u0142u RMT , \u0142adowany na pocz\u0105tek strony pami\u0119ci od adresu RCLABEL , jako RCFILE podajemy plik .FEAT , PAR0 tryb playera 0..3: 0 => compile RMTplayer for 4 tracks mono 1 => compile RMTplayer for 8 tracks stereo 2 => compile RMTplayer for 4 tracks stereo L1 R2 R3 L4 3 => compile RMTplayer for 4 tracks stereo L1 L2 R3 R4 oraz opcjonalnie PAR1 jako adres dla zmiennych na stronie zerowej (domy\u015blnie $E0 ) SAPRPLAY Player SAP-R LZSS, nie wymaga podawania nazwy pliku RCFILE , adres RCLABEL tylko od pocz\u0105tku strony MPTPLAY Player dla modu\u0142u MPT , nie wymaga podawania nazwy pliku RCFILE CMCPLAY Player dla modu\u0142u CMC , nie wymaga podawania nazwy pliku RCFILE XBMP Plik BMP Windows Bitmap (8 BitsPerPixel) \u0142adowany do pami\u0119ci VBXE pod wskazany adres RCLABEL , od indeksu koloru PAR0 -> color select , w palecie kolor\u00f3w VBXE PAR1 -> palette select","title":"Sk\u0142adnia plik\u00f3w RC"},{"location":"zasoby/#mozliwosc-adowania-zasobow-pod-rom","text":"CMC RAM / ROM CMCPLAY RAM / ROM DOSFILE RAM / ROM EXTMEM LIBRARY PORTB MPT RAM / ROM MPTPLAY RAM / ROM PP RAM / ROM RCASM RAM / ROM RCDATA RAM / ROM RELOC RAM RMT RAM / ROM RMTPLAY RAM RMTPLAY2 RAM / ROM XBMP SAPR RAM / ROM SAPRPLAY RAM / ROM","title":"Mo\u017cliwo\u015b\u0107 \u0142adowania zasob\u00f3w pod ROM"},{"location":"zasoby/#waczenie-do-aplikacji-pliku-rc","text":"W kodzie \u017ar\u00f3d\u0142owym programu nale\u017cy wpisa\u0107 dyrektyw\u0119 kompilatora (np. na pocz\u0105tku sekcji implementacji): {$R mojezasoby.rc} Dodatkowo nale\u017cy poda\u0107 w kodzie programu warto\u015b\u0107 dla etykiet RCLABEL odpowiednich zasob\u00f3w, np.: const mpt_player = $8000; mpt_modul = $9000; W\u0142\u0105czenie pliku RC nast\u0119puje w momencie kompilacji programu. Je\u015bli adres zasobu wskazuje adres $BC20.. , kt\u00f3ry normalnie zajmuje program ANTIC -a w\u00f3wczas wy\u0142\u0105czany jest ANTIC . Przy uruchomieniu programu nale\u017cy wpisa\u0107 odpowiedni\u0105 warto\u015b\u0107 do rejestru DMACTL aby w\u0142\u0105czy\u0107 obraz z powrotem. Je\u015bli adres zasobu wskazuje adres pod ROM z przedzia\u0142u $E000..$E3FF w\u00f3wczac wymuszana jest definicja symbolu NOROMFONT , kt\u00f3ry zapobiega przepisaniu zestawu znak\u00f3w gdy aktywujemy dyrektyw\u0119 {$define romoff} .","title":"W\u0142\u0105czenie do aplikacji pliku RC"},{"location":"zasoby/#dostep-do-zasobow","text":"Zasoby umieszczane s\u0105 pod wskazanymi RCLABEL adresami w pami\u0119ci. Wyj\u0105tkiem s\u0105 zasoby RCDATA , SAPR , PP dla kt\u00f3rych mo\u017cliwe jest pomini\u0119cie definicji RCLABEL w kodzie programu. W przypadku braku definicji RCLABEL zas\u00f3b zostaje do\u0142\u0105czony do kompilowanego programu, dost\u0119p mo\u017cliwy jest poprzez procedur\u0119 GetResourceHandle . GetResourceHandle(pointer, 'rclabel'); Procedura GetResourceHandle ustala warto\u015b\u0107 wska\u017anika POINTER dla zasobu RCLABEL . SizeOfResource(variable, 'rclabel'); Procedura SizeOfResource zwraca d\u0142ugo\u015b\u0107 zasobu RCLABEL w zmiennej VARIABLE .","title":"Dost\u0119p do zasob\u00f3w."},{"location":"zasoby/#rcasm","text":"W zasobach ASM nie ma mo\u017cliwo\u015bci u\u017cywania makr.","title":"RCASM"},{"location":"zasoby/#saprplay","text":"Player SAP-R LZSS wymaga podania adresu od pocz\u0105tku strony pami\u0119ci. G\u0142\u00f3wny kod playera zajmuje $0300 bajt\u00f3w, bufory $0900 , w sumie $0C00 bajt\u00f3w. SAP-R jest to plik z kolejnymi warto\u015bciami rejestr\u00f3w POKEY -a ( $D200..$D208 ). Zapis pliku SAP-R umo\u017cliwia emulator Altirra , lub program RMT2LZSS .","title":"SAPRPLAY"},{"location":"zmienne/","text":"VAR S\u0142owo VAR rozpoczyna sekcj\u0119 deklaracji zmiennych. var label: type; label: type = value; var a: word; b: byte = 1; c: Boolean = true; s: string = 'Atari'; tb: array [0..3] of byte = (0,1,2,3); VOLATILE Modyfikator VOLATILE oznacza zmienn\u0105 jako tzw. ulotn\u0105. Oznaczenie jako VOLATILE powoduje wy\u0142\u0105czenie optymalizacji kodu wynikowego dla tej zmiennej, jest to przydatne w przypadku rejestr\u00f3w sprz\u0119towych kt\u00f3rych warto\u015bci mog\u0105 ulega\u0107 zmianie przy ka\u017cdym kolejnym odczycie. var [volatile] joy : byte absolute $ff08; pio : byte absolute $fd30; begin repeat pio := $ff; joy := 2; if (joy xor $ff) = 1 then writeln('UP'); until false; end. STRIPED Modyfikator STRIPED pozwala dla tablic nie przekraczaj\u0105cych maksymalnej liczby element\u00f3w 256 , typu prostego ( WORD , SMALLINT , CARDINAL , INTEGER , SHORTREAL , REAL , POINTER ) zmieni\u0107 spos\u00f3b alokacji danych. var [striped] tab: array [0..255] of cardinal; adr.tab adr.tab+$100 adr.tab+$200 adr.tab+$300 ABSOLUTE Modyfikator ABSOLUTE pozwala ustali\u0107 adres w pami\u0119ci dla zmiennych VAR . var a: byte absolute $0600; tb: array [0..255] of byte absolute $a000; tab: array [0..3] of byte; v: integer absolute tab; procedure test(var buf); var ptr: PByte absolute buf; REGISTER Modyfikator REGISTER ustala adres pami\u0119ci dla zmiennych VAR na stronie zerowej (maksymalnie mo\u017cna przydzieli\u0107 16 bajt\u00f3w). var a: byte register; c: integer register; UWAGA: Z tego samego obszaru 16 bajt\u00f3w strony zerowej korzysta kompilator alokuj\u0105c tam swoje programowe rejestry EDX ECX EAX dlatego u\u017cycie modyfikatora REGISTER nie jest mo\u017cliwe kiedy procedura lub funkcja r\u00f3wnie\u017c korzysta z REGISTER . procedure test(a,b,c: integer); register; Umieszczenie zmiennych na stronie zerowej oznacza ich szybsze przetwarzanie przez CPU 6502 , pozwala te\u017c kompilatorowi w przypadku typu PByte lepiej optymalizowa\u0107 kod. var ptr: PByte register; begin ptr:=pointer($bc40); ptr[5]:=ord('A'~); end. zostanie wygenerowany lda #$40 sta PTR lda #$BC sta PTR+1 ldy #$05 lda #$21 sta (PTR),y Je\u015bli ptr nie zostanie umieszczone na stronie zerowej, wynikiem b\u0119dzie lda #$40 sta PTR sta :bp2 lda #$BC sta PTR+1 sta :bp2+1 ldy #$05 lda #$21 sta (:bp2),y","title":"Zmienne"},{"location":"zmienne/#_1","text":"","title":""},{"location":"zmienne/#var","text":"S\u0142owo VAR rozpoczyna sekcj\u0119 deklaracji zmiennych. var label: type; label: type = value; var a: word; b: byte = 1; c: Boolean = true; s: string = 'Atari'; tb: array [0..3] of byte = (0,1,2,3);","title":"VAR"},{"location":"zmienne/#volatile","text":"Modyfikator VOLATILE oznacza zmienn\u0105 jako tzw. ulotn\u0105. Oznaczenie jako VOLATILE powoduje wy\u0142\u0105czenie optymalizacji kodu wynikowego dla tej zmiennej, jest to przydatne w przypadku rejestr\u00f3w sprz\u0119towych kt\u00f3rych warto\u015bci mog\u0105 ulega\u0107 zmianie przy ka\u017cdym kolejnym odczycie. var [volatile] joy : byte absolute $ff08; pio : byte absolute $fd30; begin repeat pio := $ff; joy := 2; if (joy xor $ff) = 1 then writeln('UP'); until false; end.","title":"VOLATILE"},{"location":"zmienne/#striped","text":"Modyfikator STRIPED pozwala dla tablic nie przekraczaj\u0105cych maksymalnej liczby element\u00f3w 256 , typu prostego ( WORD , SMALLINT , CARDINAL , INTEGER , SHORTREAL , REAL , POINTER ) zmieni\u0107 spos\u00f3b alokacji danych. var [striped] tab: array [0..255] of cardinal; adr.tab adr.tab+$100 adr.tab+$200 adr.tab+$300","title":"STRIPED"},{"location":"zmienne/#absolute","text":"Modyfikator ABSOLUTE pozwala ustali\u0107 adres w pami\u0119ci dla zmiennych VAR . var a: byte absolute $0600; tb: array [0..255] of byte absolute $a000; tab: array [0..3] of byte; v: integer absolute tab; procedure test(var buf); var ptr: PByte absolute buf;","title":"ABSOLUTE"},{"location":"zmienne/#register","text":"Modyfikator REGISTER ustala adres pami\u0119ci dla zmiennych VAR na stronie zerowej (maksymalnie mo\u017cna przydzieli\u0107 16 bajt\u00f3w). var a: byte register; c: integer register; UWAGA: Z tego samego obszaru 16 bajt\u00f3w strony zerowej korzysta kompilator alokuj\u0105c tam swoje programowe rejestry EDX ECX EAX dlatego u\u017cycie modyfikatora REGISTER nie jest mo\u017cliwe kiedy procedura lub funkcja r\u00f3wnie\u017c korzysta z REGISTER . procedure test(a,b,c: integer); register; Umieszczenie zmiennych na stronie zerowej oznacza ich szybsze przetwarzanie przez CPU 6502 , pozwala te\u017c kompilatorowi w przypadku typu PByte lepiej optymalizowa\u0107 kod. var ptr: PByte register; begin ptr:=pointer($bc40); ptr[5]:=ord('A'~); end. zostanie wygenerowany lda #$40 sta PTR lda #$BC sta PTR+1 ldy #$05 lda #$21 sta (PTR),y Je\u015bli ptr nie zostanie umieszczone na stronie zerowej, wynikiem b\u0119dzie lda #$40 sta PTR sta :bp2 lda #$BC sta PTR+1 sta :bp2+1 ldy #$05 lda #$21 sta (:bp2),y","title":"REGISTER"}]}